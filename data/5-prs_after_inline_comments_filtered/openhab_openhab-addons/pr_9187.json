{"pr_number": 9187, "pr_title": "[homeconnect] Initial contribution", "pr_createdAt": "2020-11-30T19:03:01Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9187", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536994880", "bodyText": "Generally set directly when defining the variable.\nSame comment for all classes.", "author": "lolodomo", "createdAt": "2020-12-06T09:12:44Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final Queue<Event> eventQueue;\n+\n+    private final Logger logger;\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(EVENT_QUEUE_SIZE));\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2NDAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r544964021", "bodyText": "Is this required? I like it more the way it is. All my variable definitions are made in the constructor. I don't want to mix it.", "author": "bruestel", "createdAt": "2020-12-17T10:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyNjQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545026453", "bodyText": "All other official bindings I look at in the past are using the other way.\nAn official reviewer will let you know if this is required or not.", "author": "lolodomo", "createdAt": "2020-12-17T11:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg5MzQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558893478", "bodyText": "Changed it.", "author": "bruestel", "createdAt": "2021-01-16T13:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NTA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536995040", "bodyText": "Connect", "author": "lolodomo", "createdAt": "2020-12-06T09:13:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final Queue<Event> eventQueue;\n+\n+    private final Logger logger;\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(EVENT_QUEUE_SIZE));\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Conncet API. This helps to reduce the", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5ODMyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536998320", "bodyText": "Why not using the constant you defined in HomeConnectBindingConstants ?\nSame comment for other methods.", "author": "lolodomo", "createdAt": "2020-12-06T09:32:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+        jsonParser = new JsonParser();\n+        communicationQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(COMMUNICATION_QUEUE_SIZE));\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(\"/api/homeappliances\");\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(\"/api/homeappliances/\" + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, \"BSH.Common.Setting.AmbientLightEnabled\");", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2NTQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r544965440", "bodyText": "I used the API client class in another private project. Will adjust it. It's better to use constants.", "author": "bruestel", "createdAt": "2020-12-17T10:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4ODkwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538688908", "bodyText": "You can simplufy your class by extending BaseDynamicStateDescriptionProvider like in most of other bindings.", "author": "lolodomo", "createdAt": "2020-12-08T18:20:03Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.type;\n+\n+import java.util.Locale;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic thing values.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class HomeConnectDynamicStateDescriptionProvider implements DynamicStateDescriptionProvider {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM4MDUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r546380523", "bodyText": "Thanks for the hint. I was able to remove a couple of lines of code. \ud83d\udc4d", "author": "bruestel", "createdAt": "2020-12-20T13:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4ODkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY5MTU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538691572", "bodyText": "\"were sent\" I believe", "author": "lolodomo", "createdAt": "2020-12-08T18:22:38Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+\n+/**\n+ * The {@link EventHandler} is responsible for handling events, which where send via Server-Sent event interface.", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538703672", "bodyText": "Implements ThingHandlerService.\nThis will simplify a lot of your thing handler factory.\nIn your bridge handler add, the method getServices.", "author": "lolodomo", "createdAt": "2020-12-08T18:34:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5NTg1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545095859", "bodyText": "I don't get this. Can you please give me more context.", "author": "bruestel", "createdAt": "2020-12-17T13:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk4MzExOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548983118", "bodyText": "Below I provided the code changes.", "author": "lolodomo", "createdAt": "2020-12-26T13:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg5Mzc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558893764", "bodyText": "Changed it", "author": "bruestel", "createdAt": "2021-01-16T13:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwNTIxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538705217", "bodyText": "DEBUG level is better", "author": "lolodomo", "createdAt": "2020-12-08T18:35:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwNzA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538707075", "bodyText": "Add .withRepresentationProperty(HA_ID)", "author": "lolodomo", "createdAt": "2020-12-08T18:37:35Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538709005", "bodyText": "What's the utility of this line ?", "author": "lolodomo", "createdAt": "2020-12-08T18:39:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5NTM0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545095343", "bodyText": "Changed it to if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)), due to other refactoring.\nThis filters the discovered Home Connect appliances. Only certain thing types are allowed. I think I've copied it from another binding.", "author": "bruestel", "createdAt": "2020-12-17T13:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMzM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548503385", "bodyText": "My understanding of this line is that you will get the HA_ID for each thing, but that's all. It will do nothing and looks as useless.", "author": "lolodomo", "createdAt": "2020-12-24T11:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgzMTA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558831058", "bodyText": "Yes it became useless. I will remove it.", "author": "bruestel", "createdAt": "2021-01-16T09:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538710047", "bodyText": "You could use Map<String, Object> properties = Map.of(HA_ID, appliance.getHaId());", "author": "lolodomo", "createdAt": "2020-12-08T18:40:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5ODQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545098452", "bodyText": "Cannot change it now. I need to be Java 1.8 compatible.", "author": "bruestel", "createdAt": "2020-12-17T13:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904407", "bodyText": "Why do you need to be Java 8 compatible?", "author": "fwolter", "createdAt": "2021-03-10T22:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMTEzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538711135", "bodyText": "DEBUG level is sufficient.", "author": "lolodomo", "createdAt": "2020-12-08T18:41:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjIxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538712215", "bodyText": "Rather use removeOlderResults(getTimestampOfLastScan(), bridgeHandler.getThing().getUID()); to remove only things attached to your bridge.", "author": "lolodomo", "createdAt": "2020-12-08T18:42:57Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        super.stopScan();\n+        removeOlderResults(getTimestampOfLastScan());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538712522", "bodyText": "Rather use removeOlderResults(new Date().getTime(), bridgeHandler.getThing().getUID()); to remove only things attached to your bridge.", "author": "lolodomo", "createdAt": "2020-12-08T18:43:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMzUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538713519", "bodyText": "Once you use representation property, you don't need anymore to check if the thing already exists.", "author": "lolodomo", "createdAt": "2020-12-08T18:44:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538715485", "bodyText": "Using the ThingHandlerService solution, you don't have anymore to do that.", "author": "lolodomo", "createdAt": "2020-12-08T18:47:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final HomeConnectServlet homeConnectServlet;\n+\n+    @Activate\n+    public HomeConnectHandlerFactory(@Reference OAuthFactory oAuthFactory,\n+            @Reference HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider,\n+            @Reference HomeConnectServlet homeConnectServlet) {\n+        this.oAuthFactory = oAuthFactory;\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        this.homeConnectServlet = homeConnectServlet;\n+\n+        discoveryServiceRegistrations = new HashMap<>();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_API_BRIDGE.equals(thingTypeUID)) {\n+            HomeConnectBridgeHandler bridgeHandler = new HomeConnectBridgeHandler((Bridge) thing, oAuthFactory,\n+                    homeConnectServlet);\n+\n+            // configure discovery service\n+            HomeConnectDiscoveryService discoveryService = new HomeConnectDiscoveryService(bridgeHandler);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNjEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538716101", "bodyText": "Can be removed if you use the ThingHandlerService solution.", "author": "lolodomo", "createdAt": "2020-12-08T18:48:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final HomeConnectServlet homeConnectServlet;\n+\n+    @Activate\n+    public HomeConnectHandlerFactory(@Reference OAuthFactory oAuthFactory,\n+            @Reference HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider,\n+            @Reference HomeConnectServlet homeConnectServlet) {\n+        this.oAuthFactory = oAuthFactory;\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        this.homeConnectServlet = homeConnectServlet;\n+\n+        discoveryServiceRegistrations = new HashMap<>();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_API_BRIDGE.equals(thingTypeUID)) {\n+            HomeConnectBridgeHandler bridgeHandler = new HomeConnectBridgeHandler((Bridge) thing, oAuthFactory,\n+                    homeConnectServlet);\n+\n+            // configure discovery service\n+            HomeConnectDiscoveryService discoveryService = new HomeConnectDiscoveryService(bridgeHandler);\n+            discoveryServiceRegistrations.put(bridgeHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));\n+\n+            return bridgeHandler;\n+        } else if (THING_TYPE_DISHWASHER.equals(thingTypeUID)) {\n+            return new HomeConnectDishwasherHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_OVEN.equals(thingTypeUID)) {\n+            return new HomeConnectOvenHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_WASHER.equals(thingTypeUID)) {\n+            return new HomeConnectWasherHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_WASHER_DRYER.equals(thingTypeUID)) {\n+            return new HomeConnectWasherDryerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_DRYER.equals(thingTypeUID)) {\n+            return new HomeConnectDryerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_FRIDGE_FREEZER.equals(thingTypeUID)) {\n+            return new HomeConnectFridgeFreezerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_COFFEE_MAKER.equals(thingTypeUID)) {\n+            return new HomeConnectCoffeeMakerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_HOOD.equals(thingTypeUID)) {\n+            return new HomeConnectHoodHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_COOKTOP.equals(thingTypeUID)) {\n+            return new HomeConnectCooktopHandler(thing, dynamicStateDescriptionProvider);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    protected void removeHandler(ThingHandler thingHandler) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNjMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538716333", "bodyText": "Can be removed if you use the ThingHandlerService solution.", "author": "lolodomo", "createdAt": "2020-12-08T18:48:52Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcyMDEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538720132", "bodyText": "DEBUG or WARN level", "author": "lolodomo", "createdAt": "2020-12-08T18:54:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcyOTk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538729941", "bodyText": "If the purpose of a kind of cache, rather than using something from Apache Commons, you have already one cache class in the openHAB core framework.", "author": "lolodomo", "createdAt": "2020-12-08T19:03:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMTQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538731468", "bodyText": "A switch/case might be more appropriate.", "author": "lolodomo", "createdAt": "2020-12-08T19:05:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEwNTk3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545105970", "bodyText": "matter of taste", "author": "bruestel", "createdAt": "2020-12-17T13:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMzQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538733486", "bodyText": "isThingReadyToHandleCommand() is true, you should not have to do all this stuff.\nGenerally we have a variable bridgeHandler which is set in initialize method.", "author": "lolodomo", "createdAt": "2020-12-08T19:09:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTExNTgyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545115824", "bodyText": "I simplified it. It's a left over", "author": "bruestel", "createdAt": "2020-12-17T14:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734151", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:10:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDgyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734824", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:11:08Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTExNzM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545117359", "bodyText": "Will change it to info. The user should know why his or her command didn't worked.", "author": "bruestel", "createdAt": "2020-12-17T14:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDg4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734886", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:11:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736069", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:12:56Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736389", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:13:25Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjcxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736714", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:13:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MTkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538741936", "bodyText": "This call will trigger HTTP requests. You should run in a separate thread to be sure that initialize() will return fast.", "author": "lolodomo", "createdAt": "2020-12-08T19:21:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMyMDk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563320952", "bodyText": "This is now done.", "author": "lolodomo", "createdAt": "2021-01-24T17:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MTkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MjQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538742453", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:22:34Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MzM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538743371", "bodyText": "DEBUG lovel", "author": "lolodomo", "createdAt": "2020-12-08T19:24:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMzMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591913314", "bodyText": "Yes, debug.", "author": "fwolter", "createdAt": "2021-03-10T22:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MzM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744299", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:25:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM4MTU2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r546381563", "bodyText": "The api client should be present. If not, something really serious is going wrong.", "author": "bruestel", "createdAt": "2020-12-20T14:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591914143", "bodyText": "In this case you could throw an unchecked exception to make things easier. But I won't insist on changing it.", "author": "fwolter", "createdAt": "2021-03-10T22:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDM4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744388", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:25:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDc5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744798", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:26:20Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NjE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538746157", "bodyText": "Use UnDefType.UNDEF rather than UnDefType.NULL.\nUnDefType.NULL is normally not used by bindiongs, it is the init state of any channel before it is first set.", "author": "lolodomo", "createdAt": "2020-12-08T19:28:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM4MTg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r546381846", "bodyText": "Thanks for the hint. Will replace it.", "author": "bruestel", "createdAt": "2020-12-20T14:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NjE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538750641", "bodyText": "This is generally something done in initialize() / bridgeStatusChanged()", "author": "lolodomo", "createdAt": "2020-12-08T19:35:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMyMDg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563320869", "bodyText": "This is done now in initialize too.", "author": "lolodomo", "createdAt": "2021-01-24T17:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNjI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591916254", "bodyText": "Can it be removed here, then?", "author": "fwolter", "createdAt": "2021-03-10T22:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MjQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538752432", "bodyText": "One time again, once the bridge is ONLINE, you should have a variable that give you the bridge handler.", "author": "lolodomo", "createdAt": "2020-12-08T19:38:11Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538754727", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:41:54Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755330", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:42:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755650", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:43:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755716", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:43:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTgzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755832", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:43:40Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756028", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:44:03Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756439", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:44:36Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756502", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:44:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756664", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:00Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756744", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njg3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756874", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756950", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757314", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757531", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757655", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:39Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzczMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757733", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758152", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758227", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758340", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODQxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758418", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:51Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758475", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:48:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758545", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:48:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538762419", "bodyText": "Then set this.reinitializationFuture1 to null ?", "author": "lolodomo", "createdAt": "2020-12-08T19:54:23Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected State cachePutIfAbsentAndGet(ChannelUID channelUID, Map<ChannelUID, State> cache,\n+            SupplierWithException<State> supplier)\n+            throws AuthorizationException, ApplianceOfflineException, CommunicationException {\n+\n+        // noinspection SynchronizationOnLocalVariableOrMethodParameter\n+        synchronized (cache) {\n+            State state = cache.get(channelUID);\n+            if (state == null) {\n+                state = supplier.get();\n+                cache.put(channelUID, state);\n+            }\n+            return state;\n+        }\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelTemperature.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        createStateDescription(option, this::convertWasherSpinSpeed)\n+                                .ifPresent(stateDescription -> channelSpinSpeed\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        createStateDescription(option, this::convertWasherTemperature)\n+                                .ifPresent(stateDescription -> channelTemperature\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        createStateDescription(option, this::mapStringType)\n+                                .ifPresent(stateDescription -> channelDryingTarget\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private Optional<StateDescription> createStateDescription(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        ArrayList<StateOption> stateOptions = new ArrayList<>();\n+        option.getAllowedValues().forEach(av -> stateOptions.add(new StateOption(av, stateConverter.apply(av))));\n+\n+        @Nullable\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+        return stateDescription == null ? Optional.empty() : Optional.of(stateDescription);\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MzAwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538763007", "bodyText": "Then set this.reinitializationFuture2 to null ?", "author": "lolodomo", "createdAt": "2020-12-08T19:55:14Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected State cachePutIfAbsentAndGet(ChannelUID channelUID, Map<ChannelUID, State> cache,\n+            SupplierWithException<State> supplier)\n+            throws AuthorizationException, ApplianceOfflineException, CommunicationException {\n+\n+        // noinspection SynchronizationOnLocalVariableOrMethodParameter\n+        synchronized (cache) {\n+            State state = cache.get(channelUID);\n+            if (state == null) {\n+                state = supplier.get();\n+                cache.put(channelUID, state);\n+            }\n+            return state;\n+        }\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelTemperature.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        createStateDescription(option, this::convertWasherSpinSpeed)\n+                                .ifPresent(stateDescription -> channelSpinSpeed\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        createStateDescription(option, this::convertWasherTemperature)\n+                                .ifPresent(stateDescription -> channelTemperature\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        createStateDescription(option, this::mapStringType)\n+                                .ifPresent(stateDescription -> channelDryingTarget\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private Optional<StateDescription> createStateDescription(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        ArrayList<StateOption> stateOptions = new ArrayList<>();\n+        option.getAllowedValues().forEach(av -> stateOptions.add(new StateOption(av, stateConverter.apply(av))));\n+\n+        @Nullable\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+        return stateDescription == null ? Optional.empty() : Optional.of(stateDescription);\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);\n+        }\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor2() {\n+        this.reinitializationFuture2 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && !accessible.get()) {\n+                logger.debug(\"Offline monitor 2: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 2: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor2();\n+                }\n+            } else {\n+                scheduleOfflineMonitor2();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_2_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor2() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture2;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NjE4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538766183", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:00:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2Njk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538766956", "bodyText": "All the code than can take time should be run in a separate thread to be sure to have a fast run of initialize()", "author": "lolodomo", "createdAt": "2020-12-08T20:01:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODEyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538768123", "bodyText": "This is normally handled by the thing manager when it disposes your handler.", "author": "lolodomo", "createdAt": "2020-12-08T20:03:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538770318", "bodyText": "Then set this.reinitializationFuture to null ?", "author": "lolodomo", "createdAt": "2020-12-08T20:07:08Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {\n+                logger.info(\"Clear oAuth credential store. bridge={}\", getThing().getLabel());\n+                oAuthClientService.remove();\n+            } catch (OAuthException e) {\n+                logger.error(\"Could not clear oAuth credentials. bridge={}\", getThing().getLabel(), e);\n+            }\n+\n+            if (isInitialized()) {\n+                // persist new configuration and reinitialize handler\n+                dispose();\n+                updateConfiguration(configuration);\n+                initialize();\n+            } else {\n+                // persist new configuration and notify Thing Manager\n+                updateConfiguration(configuration);\n+                @Nullable\n+                ThingHandlerCallback callback = getCallback();\n+                if (callback != null) {\n+                    callback.configurationUpdated(this.getThing());\n+                } else {\n+                    logger.warn(\n+                            \"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                            this.getClass().getSimpleName());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return api client instance\n+     */\n+    public HomeConnectApiClient getApiClient() {\n+        return apiClient;\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return event source client instance\n+     */\n+    public HomeConnectEventSourceClient getEventSourceClient() {\n+        return eventSourceClient;\n+    }\n+\n+    /**\n+     * Get children of bridge\n+     *\n+     * @return list of child handlers\n+     */\n+    public List<AbstractHomeConnectThingHandler> getThingHandler() {\n+        return getThing().getThings().stream()\n+                .filter(thing -> thing.getHandler() instanceof AbstractHomeConnectThingHandler)\n+                .map(thing -> (AbstractHomeConnectThingHandler) thing.getHandler()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Get {@link ApiBridgeConfiguration}.\n+     *\n+     * @return bridge configuration (clientId, clientSecret, etc.)\n+     */\n+    public ApiBridgeConfiguration getConfiguration() {\n+        return getConfigAs(ApiBridgeConfiguration.class);\n+    }\n+\n+    /**\n+     * Get {@link OAuthClientService} instance.\n+     *\n+     * @return oAuth client service instance\n+     */\n+    public OAuthClientService getOAuthClientService() {\n+        return oAuthClientService;\n+    }\n+\n+    private void cleanup() {\n+        ArrayList<ApiRequest> apiRequestHistory = new ArrayList<>();\n+        apiRequestHistory.addAll(apiClient.getLatestApiRequests());\n+        this.apiRequestHistory = apiRequestHistory;\n+        apiClient.getLatestApiRequests().clear();\n+\n+        ArrayList<Event> eventHistory = new ArrayList<>();\n+        eventHistory.addAll(eventSourceClient.getLatestEvents());\n+        this.eventHistory = eventHistory;\n+        eventSourceClient.getLatestEvents().clear();\n+        eventSourceClient.dispose();\n+\n+        oAuthFactory.ungetOAuthService(oAuthServiceHandleId);\n+        homeConnectServlet.removeBridgeHandler(this);\n+    }\n+\n+    private synchronized void scheduleReinitialize() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n+        if (reinitializationFuture != null && !reinitializationFuture.isDone()) {\n+            logger.debug(\"Reinitialization is already scheduled. Starting in {} seconds. bridge={}\",\n+                    reinitializationFuture.getDelay(TimeUnit.SECONDS), getThing().getLabel());\n+        } else {\n+            this.reinitializationFuture = scheduler.schedule(() -> {\n+                cleanup();\n+                initialize();\n+            }, HomeConnectBridgeHandler.REINITIALIZATION_DELAY, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized void stopReinitializer() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(true);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjQwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772404", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:10:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772816", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:11:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Mjg5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772893", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:11:28Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MzIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538773218", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:11:56Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectCoffeeMakerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MzM2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538773363", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:12:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link HomeConnectCooktopHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n+\n+    public HomeConnectCooktopHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+\n+        // specific SSE event handlers\n+        handlers.put(EVENT_ACTIVE_PROGRAM, (event) -> {\n+            defaultActiveProgramEventHandler().handle(event);\n+            if (event.getValue() != null) {\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent((c) -> updateChannel(c.getUID()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectCooktopHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774278", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:13:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774336", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:13:53Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDUxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774510", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:14:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectDishwasherHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774849", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:14:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTA0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775041", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:07Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+\n+            // only handle these commands if operation state allows it\n+            if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                // set drying target option\n+                if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                    getApiClient().ifPresent(apiClient -> {\n+                        try {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        } catch (ApplianceOfflineException e) {\n+                            logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                                    command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                            updateStatus(OFFLINE);\n+                            resetChannelsOnOfflineEvent();\n+                            resetProgramStateChannels();\n+                        } catch (CommunicationException e) {\n+                            logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+                        } catch (AuthorizationException e) {\n+                            logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                            handleAuthenticationError(e);\n+                        }\n+                    });\n+                }\n+            } else {\n+                logger.debug(\"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                        command, operationState, getThingLabel(), getThingHaId());\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectDryerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775188", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775255", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:26Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775297", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTM5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775397", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:42Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775450", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTQ5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775493", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:55Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775567", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:16:02Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTYzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775634", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:16:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776174", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:16:54Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjIyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776228", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776328", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:11Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776417", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:17Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Njc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776750", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSelectedProgramStateDescription() {\n+        // update hood program actions\n+        if (isBridgeOffline() || !isThingAccessibleViaServerSentEvents()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId()).forEach(availableProgram -> {\n+                    if (PROGRAM_HOOD_AUTOMATIC.equals(availableProgram.getKey())) {\n+                        stateOptions.add(new StateOption(COMMAND_AUTOMATIC, mapStringType(availableProgram.getKey())));\n+                    } else if (PROGRAM_HOOD_DELAYED_SHUT_OFF.equals(availableProgram.getKey())) {\n+                        stateOptions.add(\n+                                new StateOption(COMMAND_DELAYED_SHUT_OFF, mapStringType(availableProgram.getKey())));\n+                    } else if (PROGRAM_HOOD_VENTING.equals(availableProgram.getKey())) {\n+                        try {\n+                            apiClient.get().getProgramOptions(getThingHaId(), PROGRAM_HOOD_VENTING).forEach(option -> {\n+                                if (OPTION_HOOD_VENTING_LEVEL.equalsIgnoreCase(option.getKey())) {\n+                                    option.getAllowedValues().stream().filter(s -> !STAGE_FAN_OFF.equalsIgnoreCase(s))\n+                                            .forEach(s -> stateOptions.add(createVentingStateOption(s)));\n+                                } else if (OPTION_HOOD_INTENSIVE_LEVEL.equalsIgnoreCase(option.getKey())) {\n+                                    option.getAllowedValues().stream()\n+                                            .filter(s -> !STAGE_INTENSIVE_STAGE_OFF.equalsIgnoreCase(s))\n+                                            .forEach(s -> stateOptions.add(createVentingStateOption(s)));\n+                                }\n+                            });\n+                        } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                            logger.warn(\"Could not fetch hood program options. error={}\", e.getMessage());\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_01));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_02));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_03));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_04));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_05));\n+                            stateOptions.add(createVentingStateOption(STAGE_INTENSIVE_STAGE_1));\n+                            stateOptions.add(createVentingStateOption(STAGE_INTENSIVE_STAGE_2));\n+                        }\n+                    }\n+                });\n+                stateOptions.add(new StateOption(COMMAND_STOP, \"Stop\"));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_HOOD_ACTIONS_STATE)\n+                            .ifPresent(channel -> getDynamicStateDescriptionProvider()\n+                                    .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    @Override\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_HOOD_ACTIONS_STATE).ifPresent(channel -> getDynamicStateDescriptionProvider()\n+                .removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectHoodHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Njk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776986", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:18:11Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NzE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777152", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:18:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NzUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777503", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:19:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        cavityTemperatureFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            @Nullable\n+            String operationState = getOperationState();\n+            boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature;\n+\n+            if (STATE_OPERATION_RUN.equals(operationState)) {\n+                getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(c -> {\n+                    if (manuallyUpdateCavityTemperature) {\n+                        logger.debug(\"Update cavity temperature manually via API. haId={}\", getThingHaId());\n+                        updateChannel(c.getUID());\n+                    } else {\n+                        logger.debug(\"Update cavity temperature via SSE, don't need to fetch manually. haId={}\",\n+                                getThingHaId());\n+                    }\n+                });\n+            }\n+        }, CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, CAVITY_TEMPERATURE_SCHEDULER_PERIOD, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        @Nullable\n+        ScheduledFuture<?> cavityTemperatureFuture = this.cavityTemperatureFuture;\n+        if (cavityTemperatureFuture != null) {\n+            cavityTemperatureFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectOvenHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE)\n+                .ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Nzc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777768", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:19:23Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectWasherDryerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778101", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:19:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778433", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:20:12Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectWasherHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODY4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778681", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:20:36Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778735", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:20:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779070", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:21:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779147", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:21:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779473", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:21:54Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTY5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779696", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:22:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779764", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:22:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780369", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:23:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780403", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:23:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780831", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:24:07Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                    String value;\n+                    String unit;\n+\n+                    if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                            || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                        unit = quantity.getUnit().toString();\n+                        value = String.valueOf(quantity.intValue());\n+                    } else {\n+                        logger.debug(\"Converting target setpoint temperature from {}{} to \u00b0C value. thing={}, haId={}\",\n+                                quantity.intValue(), quantity.getUnit().toString(), getThingLabel(), getThingHaId());\n+                        unit = \"\u00b0C\";\n+                        value = String.valueOf(\n+                                quantity.getUnit().getConverterToAny(SIUnits.CELSIUS).convert(quantity).intValue());\n+                        logger.debug(\"{}{}\", value, unit);\n+                    }\n+\n+                    logger.debug(\"Set setpoint temperature to {} {}. thing={}, haId={}\", value, unit, getThingLabel(),\n+                            getThingHaId());\n+\n+                    if (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setFridgeSetpointTemperature(getThingHaId(), value, unit);\n+                    } else if (CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setFreezerSetpointTemperature(getThingHaId(), value, unit);\n+                    }\n+\n+                } else if (command instanceof OnOffType && apiClient.isPresent()) {\n+                    if (CHANNEL_FREEZER_SUPER_MODE.equals(channelUID.getId())) {\n+                        apiClient.get().setFreezerSuperMode(getThingHaId(), OnOffType.ON.equals(command));\n+                    } else if (CHANNEL_REFRIGERATOR_SUPER_MODE.equals(channelUID.getId())) {\n+                        apiClient.get().setFridgeSuperMode(getThingHaId(), OnOffType.ON.equals(command));\n+                    }\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                        command.toFullString(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                        command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                handleAuthenticationError(e);\n+            } catch (IncommensurableException | UnconvertibleException e) {\n+                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(), e.getMessage());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NjEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540866102", "bodyText": "Use the implicit last argument to the logging functions to log exceptions:\nlogger.error(\"Could not parse event! haId={}\", haId, e);\n(Valid verywhere `e.getMessage() is passed to a logging method)", "author": "t-8ch", "createdAt": "2020-12-11T11:01:33Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.EVENT;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.NOTIFY;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.STATUS;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.valueOfType;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSourceListener;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener extends EventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger;\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final Queue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            Queue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    @Override\n+    public void onOpen(@Nullable EventSource eventSource, @Nullable Response response) {\n+        logger.debug(\"Event source listener channel opened ({}).\", haId);\n+    }\n+\n+    @Override\n+    public void onEvent(@Nullable EventSource eventSource, @Nullable String id, @Nullable String type,\n+            @Nullable String data) {\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    @Override\n+    public void onClosed(@Nullable EventSource eventSource) {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    @Override\n+    public void onFailure(@Nullable EventSource eventSource, @Nullable Throwable throwable,\n+            @Nullable Response response) {\n+        @Nullable\n+        String throwableMessage = throwable != null ? throwable.getMessage() : null;\n+        @Nullable\n+        String throwableClass = throwable != null ? throwable.getClass().getName() : null;\n+        @Nullable\n+        String responseCode = response != null ? String.valueOf(response.code()) : null;\n+\n+        String responseBody = \"\";\n+        try {\n+            if (response != null) {\n+                @Nullable\n+                ResponseBody responseBodyObject = response.body();\n+                if (responseBodyObject != null) {\n+                    responseBody = responseBodyObject.string();\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Could not get HTTP response body as string.\", e);\n+        }\n+\n+        logger.debug(\n+                \"Event source listener connection failure occurred. haId={}, responseCode={}, responseBody={}, throwable={}, throwableMessage={}\",\n+                haId, responseCode, responseBody, throwableClass, throwableMessage);\n+\n+        if (response != null) {\n+            response.close();\n+        }\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            if (\"429\".equals(responseCode)) {\n+                logger.warn(\n+                        \"More than 10 active event monitoring channels was reached. Further event monitoring requests are blocked. haId={}\",\n+                        haId);\n+                eventListener.onRateLimitReached();\n+            } else {\n+                eventListener.onClosed();\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    private ScheduledFuture<?> createMonitor(ScheduledExecutorService scheduler) {\n+        return scheduler.scheduleWithFixedDelay(() -> {\n+            logger.trace(\"Check event source connection ({}). Last event package received at {}.\", haId,\n+                    lastEventReceived);\n+            if (lastEventReceived != null\n+                    && ChronoUnit.MINUTES.between(lastEventReceived, now()) > SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT) {\n+                logger.warn(\"Dead event source connection detected ({}).\", haId);\n+\n+                client.unregisterEventListener(eventListener);\n+\n+                try {\n+                    eventListener.onClosed();\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+                }\n+                stopMonitor();\n+            }\n+        }, SSE_MONITOR_INITIAL_DELAY, SSE_MONITOR_INTERVAL, TimeUnit.MINUTES);\n+    }\n+\n+    private void stopMonitor() {\n+        logger.debug(\"Dispose event source connection monitor of appliance ({}).\", haId);\n+        eventSourceMonitorFuture.cancel(true);\n+    }\n+\n+    private List<Event> mapEventSourceEventToEvent(String haId, EventType type, @Nullable String data) {\n+        List<Event> events = new ArrayList<>();\n+\n+        if ((STATUS.equals(type) || EVENT.equals(type) || NOTIFY.equals(type)) && data != null && !isEmpty(data)\n+                && !EMPTY_DATA.equals(data)) {\n+            try {\n+                JsonObject responseObject = jsonParser.parse(data).getAsJsonObject();\n+                JsonArray items = responseObject.getAsJsonArray(\"items\");\n+\n+                items.forEach(item -> {\n+                    JsonObject obj = (JsonObject) item;\n+                    @Nullable\n+                    String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                    @Nullable\n+                    String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull()\n+                            ? obj.get(\"value\").getAsString()\n+                            : null;\n+                    @Nullable\n+                    String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+                    @Nullable\n+                    String name = obj.get(\"name\") != null ? obj.get(\"name\").getAsString() : null;\n+                    @Nullable\n+                    String uri = obj.get(\"uri\") != null ? obj.get(\"uri\").getAsString() : null;\n+                    @Nullable\n+                    EventLevel level = obj.get(\"level\") != null\n+                            ? EventLevel.valueOfLevel(obj.get(\"level\").getAsString())\n+                            : null;\n+                    @Nullable\n+                    EventHandling handling = obj.get(\"handling\") != null\n+                            ? EventHandling.valueOfHandling(obj.get(\"handling\").getAsString())\n+                            : null;\n+                    @Nullable\n+                    Long timestamp = obj.get(\"timestamp\") != null ? obj.get(\"timestamp\").getAsLong() : null;\n+                    @Nullable\n+                    ZonedDateTime creation = timestamp != null\n+                            ? ZonedDateTime.ofInstant(Instant.ofEpochSecond(timestamp),\n+                                    TimeZone.getDefault().toZoneId())\n+                            : null;\n+\n+                    events.add(new Event(haId, type, key, name, uri, creation, level, handling, value, unit));\n+                });\n+            } catch (IllegalStateException e) {\n+                logger.error(\"Could not parse event! haId={}, error={}\", haId, e.getMessage());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540867130", "bodyText": "Is this meant to stay this way?\nIt shouldn't.", "author": "t-8ch", "createdAt": "2020-12-11T11:03:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_HOST;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_PORT;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.ProxySetupException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+import okhttp3.OkHttpClient;\n+import okhttp3.OkHttpClient.Builder;\n+import okhttp3.Request;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class OkHttpHelper {\n+    private static final String HEADER_AUTHORIZATION = \"Authorization\";\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OkHttpHelper.class);\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1))).withInitialTokens(0)).build();\n+\n+    public static Builder builder(boolean enableRateLimiting) {\n+        Builder builder;\n+        if (HTTP_PROXY_ENABLED) {\n+            LOGGER.warn(\"Using http proxy! {}:{}\", HTTP_PROXY_HOST, HTTP_PROXY_PORT);\n+            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(HTTP_PROXY_HOST, HTTP_PROXY_PORT));\n+\n+            try {\n+                TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNjAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545136017", "bodyText": "Removed it. I used it to reproduce error cases while using a proxy.", "author": "bruestel", "createdAt": "2020-12-17T14:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540868629", "bodyText": "Is the timezone information useful here?\nShould be java.time.Instant in my opinion.\n(Same  goes for all usages of ZonedDateTime", "author": "t-8ch", "createdAt": "2020-12-11T11:05:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.time.ZonedDateTime;\n+import java.util.UUID;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * API request model.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class ApiRequest {\n+    private final String id;\n+    private final ZonedDateTime time;\n+    private final HomeConnectRequest homeConnectRequest;\n+    private final @Nullable HomeConnectResponse homeConnectResponse;\n+\n+    public ApiRequest(ZonedDateTime time, HomeConnectRequest homeConnectRequest,", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545135502", "bodyText": "Yes it is very useful to debug problems. I just changed it before creating this pull request. One tester was in a different time zone and it was very confusing.", "author": "bruestel", "createdAt": "2020-12-17T14:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0MDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545140557", "bodyText": "Where was the Instant logged?\nIt should be serialized as ISO8601 string which is unambiguous.", "author": "t-8ch", "createdAt": "2020-12-17T14:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1NjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545156625", "bodyText": "The Instant is visible in the binding UI request and event log.\n\nI also use it in the event and request log export (json format).\n\nI'm not persisting the Instant object (like a log file etc.), it's only used in a in-memory FIFO queue.", "author": "bruestel", "createdAt": "2020-12-17T15:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540869444", "bodyText": "Could be a java.time.Instant", "author": "t-8ch", "createdAt": "2020-12-11T11:07:12Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Date;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Token model\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Token {\n+\n+    private final String accessToken;\n+    private final String refreshToken;\n+    private final long accessTokenExpiration;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMjUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591902524", "bodyText": "If you don't want to make it Instant, you could at least add the time suffix to the field name.", "author": "fwolter", "createdAt": "2021-03-10T21:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzOTA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624639059", "bodyText": "Added suffix", "author": "bruestel", "createdAt": "2021-05-02T06:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MDIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540870218", "bodyText": "You can directly assign the logger here.\nIt will remove the requirement to add it to all constructors and clutter those.\nprivate final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);", "author": "t-8ch", "createdAt": "2020-12-11T11:08:34Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540871069", "bodyText": "Should be a java.time.Duration to have proper typing.", "author": "t-8ch", "createdAt": "2020-12-11T11:09:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzOTk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624639948", "bodyText": "Added suffix to SEARCH_TIME.\n    private static final int SEARCH_TIME_SEC = 20;\n\n...\n    public HomeConnectDiscoveryService() {\n        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME_SEC, true);\n    }\n\nSEARCH_TIME is used as int constructor parameter for org.openhab.core.config.discovery.AbstractDiscoveryService . If I use a Duration I have to cast long Duration.getSeconds() back to int.", "author": "bruestel", "createdAt": "2021-05-02T06:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MjM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540872394", "bodyText": "java.time API would be better, not that it would make a lot of difference here.", "author": "t-8ch", "createdAt": "2020-12-11T11:12:10Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzMzU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545133588", "bodyText": "Changed it to System.currentTimeMillis()", "author": "bruestel", "createdAt": "2020-12-17T14:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MjM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NzMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540877327", "bodyText": "Why not ISO8601?", "author": "t-8ch", "createdAt": "2020-12-11T11:21:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MDYwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624640607", "bodyText": "Will change it to ISO_OFFSET_DATE_TIME", "author": "bruestel", "createdAt": "2021-05-02T06:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NzMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NDM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540884384", "bodyText": "Doesn't seem to do much.\nIt would make more sense to get the proxy configuration from where the rest of OpenHab also get its from, so all components behave uniformly.", "author": "t-8ch", "createdAt": "2020-12-11T11:34:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link HomeConnectBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBindingConstants {\n+\n+    public static final String BINDING_ID = \"homeconnect\";\n+\n+    public static final String HA_ID = \"haId\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_API_BRIDGE = new ThingTypeUID(BINDING_ID, \"api_bridge\");\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+    public static final ThingTypeUID THING_TYPE_WASHER = new ThingTypeUID(BINDING_ID, \"washer\");\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washerdryer\");\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridgefreezer\");\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+    public static final ThingTypeUID THING_TYPE_COFFEE_MAKER = new ThingTypeUID(BINDING_ID, \"coffeemaker\");\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+    public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    // SSE Event types\n+    public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String EVENT_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String EVENT_CONNECTED = \"CONNECTED\";\n+    public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n+    public static final String EVENT_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String EVENT_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n+    public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+    public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String EVENT_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String EVENT_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String EVENT_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String EVENT_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String EVENT_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String EVENT_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String EVENT_FRIDGE_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String EVENT_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+    public static final String EVENT_FRIDGE_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String EVENT_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.BeanContainerEmpty\";\n+    public static final String EVENT_COFFEEMAKER_WATER_TANK_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.WaterTankEmpty\";\n+    public static final String EVENT_COFFEEMAKER_DRIP_TRAY_FULL = \"ConsumerProducts.CoffeeMaker.Event.DripTrayFull\";\n+    public static final String EVENT_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String EVENT_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_STATE = \"Cooking.Common.Setting.Lighting\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String EVENT_AMBIENT_LIGHT_STATE = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String EVENT_AMBIENT_LIGHT_COLOR_STATE = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+\n+    // Channel IDs\n+    public static final String CHANNEL_DOOR_STATE = \"door_state\";\n+    public static final String CHANNEL_ELAPSED_PROGRAM_TIME = \"elapsed_program_time\";\n+    public static final String CHANNEL_POWER_STATE = \"power_state\";\n+    public static final String CHANNEL_OPERATION_STATE = \"operation_state\";\n+    public static final String CHANNEL_ACTIVE_PROGRAM_STATE = \"active_program_state\";\n+    public static final String CHANNEL_SELECTED_PROGRAM_STATE = \"selected_program_state\";\n+    public static final String CHANNEL_BASIC_ACTIONS_STATE = \"basic_actions_state\";\n+    public static final String CHANNEL_REMOTE_START_ALLOWANCE_STATE = \"remote_start_allowance_state\";\n+    public static final String CHANNEL_REMOTE_CONTROL_ACTIVE_STATE = \"remote_control_active_state\";\n+    public static final String CHANNEL_LOCAL_CONTROL_ACTIVE_STATE = \"local_control_active_state\";\n+    public static final String CHANNEL_REMAINING_PROGRAM_TIME_STATE = \"remaining_program_time_state\";\n+    public static final String CHANNEL_PROGRAM_PROGRESS_STATE = \"program_progress_state\";\n+    public static final String CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE = \"oven_current_cavity_temperature\";\n+    public static final String CHANNEL_SETPOINT_TEMPERATURE = \"setpoint_temperature\";\n+    public static final String CHANNEL_DURATION = \"duration\";\n+    public static final String CHANNEL_WASHER_TEMPERATURE = \"laundry_care_washer_temperature\";\n+    public static final String CHANNEL_WASHER_SPIN_SPEED = \"laundry_care_washer_spin_speed\";\n+    public static final String CHANNEL_WASHER_IDOS1 = \"laundry_care_washer_idos1\";\n+    public static final String CHANNEL_WASHER_IDOS2 = \"laundry_care_washer_idos2\";\n+    public static final String CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE = \"setpoint_temperature_refrigerator\";\n+    public static final String CHANNEL_REFRIGERATOR_SUPER_MODE = \"super_mode_refrigerator\";\n+    public static final String CHANNEL_FREEZER_SETPOINT_TEMPERATURE = \"setpoint_temperature_freezer\";\n+    public static final String CHANNEL_FREEZER_SUPER_MODE = \"super_mode_freezer\";\n+    public static final String CHANNEL_DRYER_DRYING_TARGET = \"dryer_drying_target\";\n+    public static final String CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE = \"coffeemaker_drip_tray_full_state\";\n+    public static final String CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE = \"coffeemaker_water_tank_empty_state\";\n+    public static final String CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE = \"coffeemaker_bean_container_empty_state\";\n+    public static final String CHANNEL_HOOD_VENTING_LEVEL = \"hood_venting_level\";\n+    public static final String CHANNEL_HOOD_INTENSIVE_LEVEL = \"hood_intensive_level\";\n+    public static final String CHANNEL_HOOD_ACTIONS_STATE = \"hood_program_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_STATE = \"functional_light_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"functional_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_STATE = \"ambient_light_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"ambient_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_COLOR_STATE = \"ambient_light_color_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"ambient_light_custom_color_state\";\n+\n+    // List of all supported devices\n+    public static final Set<ThingTypeUID> SUPPORTED_DEVICE_THING_TYPES_UIDS = Stream.of(THING_TYPE_API_BRIDGE,\n+            THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+            THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // Discoverable devices\n+    public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n+            .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // List of state values\n+    public static final String STATE_POWER_OFF = \"BSH.Common.EnumType.PowerState.Off\";\n+    public static final String STATE_POWER_ON = \"BSH.Common.EnumType.PowerState.On\";\n+    public static final String STATE_POWER_STANDBY = \"BSH.Common.EnumType.PowerState.Standby\";\n+    public static final String STATE_DOOR_OPEN = \"BSH.Common.EnumType.DoorState.Open\";\n+    public static final String STATE_DOOR_LOCKED = \"BSH.Common.EnumType.DoorState.Locked\";\n+    public static final String STATE_DOOR_CLOSED = \"BSH.Common.EnumType.DoorState.Closed\";\n+    public static final String STATE_OPERATION_READY = \"BSH.Common.EnumType.OperationState.Ready\";\n+    public static final String STATE_OPERATION_FINISHED = \"BSH.Common.EnumType.OperationState.Finished\";\n+    public static final String STATE_OPERATION_RUN = \"BSH.Common.EnumType.OperationState.Run\";\n+    public static final String STATE_EVENT_PRESENT_STATE_OFF = \"BSH.Common.EnumType.EventPresentState.Off\";\n+\n+    // List of program options\n+    public static final String OPTION_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String OPTION_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String OPTION_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String OPTION_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String OPTION_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String OPTION_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String OPTION_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String OPTION_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String OPTION_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String OPTION_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String OPTION_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String OPTION_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+\n+    // List of stages\n+    public static final String STAGE_FAN_OFF = \"Cooking.Hood.EnumType.Stage.FanOff\";\n+    public static final String STAGE_FAN_STAGE_01 = \"Cooking.Hood.EnumType.Stage.FanStage01\";\n+    public static final String STAGE_FAN_STAGE_02 = \"Cooking.Hood.EnumType.Stage.FanStage02\";\n+    public static final String STAGE_FAN_STAGE_03 = \"Cooking.Hood.EnumType.Stage.FanStage03\";\n+    public static final String STAGE_FAN_STAGE_04 = \"Cooking.Hood.EnumType.Stage.FanStage04\";\n+    public static final String STAGE_FAN_STAGE_05 = \"Cooking.Hood.EnumType.Stage.FanStage05\";\n+    public static final String STAGE_INTENSIVE_STAGE_OFF = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStageOff\";\n+    public static final String STAGE_INTENSIVE_STAGE_1 = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1\";\n+    public static final String STAGE_INTENSIVE_STAGE_2 = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStage2\";\n+    public static final String STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR = \"BSH.Common.EnumType.AmbientLightColor.CustomColor\";\n+\n+    // List of programs\n+    public static final String PROGRAM_HOOD_AUTOMATIC = \"Cooking.Common.Program.Hood.Automatic\";\n+    public static final String PROGRAM_HOOD_VENTING = \"Cooking.Common.Program.Hood.Venting\";\n+    public static final String PROGRAM_HOOD_DELAYED_SHUT_OFF = \"Cooking.Common.Program.Hood.DelayedShutOff\";\n+\n+    // Network and oAuth constants\n+    public static final String API_BASE_URL = \"https://api.home-connect.com\";\n+    public static final String API_SIMULATOR_BASE_URL = \"https://simulator.home-connect.com\";\n+    public static final String OAUTH_TOKEN_PATH = \"/security/oauth/token\";\n+    public static final String OAUTH_AUTHORIZE_PATH = \"/security/oauth/authorize\";\n+    public static final String OAUTH_SCOPE = \"IdentifyAppliance Monitor Settings Dishwasher-Control Washer-Control Dryer-Control WasherDryer-Control CoffeeMaker-Control Hood-Control CleaningRobot-Control\";\n+\n+    // Operation states\n+    public static final String OPERATION_STATE_INACTIVE = \"BSH.Common.EnumType.OperationState.Inactive\";\n+    public static final String OPERATION_STATE_READY = \"BSH.Common.EnumType.OperationState.Ready\";\n+    public static final String OPERATION_STATE_DELAYED_START = \"BSH.Common.EnumType.OperationState.DelayedStart\";\n+    public static final String OPERATION_STATE_RUN = \"BSH.Common.EnumType.OperationState.Run\";\n+    public static final String OPERATION_STATE_PAUSE = \"BSH.Common.EnumType.OperationState.Pause\";\n+    public static final String OPERATION_STATE_ACTION_REQUIRED = \"BSH.Common.EnumType.OperationState.ActionRequired\";\n+    public static final String OPERATION_STATE_FINISHED = \"BSH.Common.EnumType.OperationState.Finished\";\n+    public static final String OPERATION_STATE_ERROR = \"BSH.Common.EnumType.OperationState.Error\";\n+    public static final String OPERATION_STATE_ABORTING = \"BSH.Common.EnumType.OperationState.Aborting\";\n+\n+    // Commands\n+    public static final String COMMAND_START = \"start\";\n+    public static final String COMMAND_STOP = \"stop\";\n+    public static final String COMMAND_SELECTED = \"selected\";\n+    public static final String COMMAND_VENTING_1 = \"venting1\";\n+    public static final String COMMAND_VENTING_2 = \"venting2\";\n+    public static final String COMMAND_VENTING_3 = \"venting3\";\n+    public static final String COMMAND_VENTING_4 = \"venting4\";\n+    public static final String COMMAND_VENTING_5 = \"venting5\";\n+    public static final String COMMAND_VENTING_INTENSIVE_1 = \"ventingIntensive1\";\n+    public static final String COMMAND_VENTING_INTENSIVE_2 = \"ventingIntensive2\";\n+    public static final String COMMAND_AUTOMATIC = \"automatic\";\n+    public static final String COMMAND_DELAYED_SHUT_OFF = \"delayed\";\n+\n+    // proxy settings\n+    public static final boolean HTTP_PROXY_ENABLED = false;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyMzQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545123441", "bodyText": "Removed it", "author": "bruestel", "createdAt": "2020-12-17T14:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540885839", "bodyText": "I would prefer to have the URL handling at the very outset of the binding and use full URI/Strings throught the plumbing.\nThis would also make it possible for users to specify their own URLs for testing etc.", "author": "t-8ch", "createdAt": "2020-12-11T11:37:26Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyNjkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545126939", "bodyText": "The Home Connect ecosystem only uses two addresses. One for production and one for the simulated environment. There is no need to specify a custom URL.", "author": "bruestel", "createdAt": "2020-12-17T14:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0NDIwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545144208", "bodyText": "What about using a mock service for tests?\nOr maybe someone reimplements the service as a self-hosted version.\nCurrently all low-level components have to contain the same conditional and know about all possible URLs.\nWhen the URLs pulled farther up the stack (maybe even to the bridge settings itself)\nit will be much easier to enable those usecases. It also simplifies to low-level components.", "author": "t-8ch", "createdAt": "2020-12-17T14:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2OTQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545169479", "bodyText": "What about using a mock service for tests?\n\nIf you mock the Home Connect API (maybe in a unit test), you don't necessarily need to change the API URL.\n\nOr maybe someone reimplements the service as a self-hosted version.\n\nThe Home Connect system is closed source. There are no open clients. At least I haven't heard of it yet. The official App is using a different protocol to communicate.\n\nCurrently all low-level components have to contain the same conditional and know about all possible URLs.\n\nWe are talking about two URLs. In the bridge configuration the user can decide whether to use the simulated or the productive environment. https://developer.home-connect.com/docs/general/endpoints_dataencoding\n\nWhen the URLs pulled farther up the stack (maybe even to the bridge settings itself)\nit will be much easier to enable those usecases. It also simplifies to low-level components.\n\nI think the bridge don't need to know details about the API. The knowledge of the API endpoint is not needed. The user shouldn't know about it. It would confuse the users if they can edit the URL in the bridge configuration.", "author": "bruestel", "createdAt": "2020-12-17T15:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE4MTc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545181786", "bodyText": "What about using a mock service for tests?\nIf you mock the Home Connect API (maybe in a unit test), you don't necessarily need to change the API URL.\n\n\nThe imagination was to use something like wiremock to mock the API on the HTTP level.\n\n\nOr maybe someone reimplements the service as a self-hosted version.\nThe Home Connect system is closed source. There are no open clients. At least I haven't heard of it yet. The official\nApp is using a different protocol to communicate.\n\n\nThis is more about an open API server.\nHomekit is also closed source, and yet OpenHab implements it's interface.\n\n\nWhen the URLs pulled farther up the stack (maybe even to the bridge settings itself)\nit will be much easier to enable those usecases. It also simplifies to low-level components.\nI think the bridge don't need to know details about the API. The knowledge of the API endpoint is not needed.\n\n\nThe user shouldn't know about it. It would confuse the users if they can edit the URL in the bridge configuration.\nIt would be the default value of an advanced setting, not visible to users.\nNo component actually has to know about the distinction between prod and sandbox.\nIf you want, leave it as is.\nIt's just a pet-peeve of mine when enumerations of configurations are passed around instead of the raw configuration value.\nIt complicates the code and reduces the functionality without any upsides.", "author": "t-8ch", "createdAt": "2020-12-17T15:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NjE4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540886184", "bodyText": "Now that OpenHab depends on Java 11, the new Java 11 HTTP client could be used, slashing the size of the binding considerably.", "author": "t-8ch", "createdAt": "2020-12-11T11:38:08Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "url": "https://github.com/openhab/openhab-addons/commit/c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2020-12-20T16:38:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548500781", "bodyText": "I am surprised the class is empty. Normally, there is a method to get the state options + the handling of the reference to ChannelTypeI18nLocalizationService .", "author": "lolodomo", "createdAt": "2020-12-24T11:26:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.type;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.binding.BaseDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic values.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class HomeConnectDynamicStateDescriptionProvider extends BaseDynamicStateDescriptionProvider {\n+", "originalCommit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxNzI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558917248", "bodyText": "Please add this code to your class:\n\n    @Reference\n    protected void setChannelTypeI18nLocalizationService(\n            final ChannelTypeI18nLocalizationService channelTypeI18nLocalizationService) {\n        this.channelTypeI18nLocalizationService = channelTypeI18nLocalizationService;\n    }\n\n    protected void unsetChannelTypeI18nLocalizationService(\n            final ChannelTypeI18nLocalizationService channelTypeI18nLocalizationService) {\n        this.channelTypeI18nLocalizationService = null;\n    }", "author": "lolodomo", "createdAt": "2021-01-16T15:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MTkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585781925", "bodyText": "Was done, included in my PR.", "author": "lolodomo", "createdAt": "2021-03-02T17:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMjIyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548502226", "bodyText": "Replace appliance.getHaId() by HA_ID. What is expected is the parameter name, not its value.", "author": "lolodomo", "createdAt": "2020-12-24T11:32:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.debug(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withRepresentationProperty(appliance.getHaId())", "originalCommit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2bab267d8b772fc4a62951e9bc00f5d1e5e8cad", "url": "https://github.com/openhab/openhab-addons/commit/b2bab267d8b772fc4a62951e9bc00f5d1e5e8cad", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T11:05:11Z", "type": "forcePushed"}, {"oid": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "url": "https://github.com/openhab/openhab-addons/commit/5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "message": "Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T13:15:27Z", "type": "forcePushed"}, {"oid": "979af11d1f80ae7c43b80407039a64f1675b8502", "url": "https://github.com/openhab/openhab-addons/commit/979af11d1f80ae7c43b80407039a64f1675b8502", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T13:38:47Z", "type": "forcePushed"}, {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "url": "https://github.com/openhab/openhab-addons/commit/9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T13:46:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxOTQxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558919410", "bodyText": "Minor: please fix the comment as now the bridgeHandler is no more a parameter of the constructor.", "author": "lolodomo", "createdAt": "2021-01-16T15:07:41Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2ODkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563268915", "bodyText": "Ok", "author": "bruestel", "createdAt": "2021-01-24T10:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxOTQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk3MjQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558972456", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T17:26:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MDEyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558980120", "bodyText": "Is there a reason to not use the scheduler provided by the thing handler ?", "author": "lolodomo", "createdAt": "2021-01-16T17:46:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3MjU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563272591", "bodyText": "No :-)", "author": "bruestel", "createdAt": "2021-01-24T10:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MTU4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558981580", "bodyText": "It may be better to first cancel your job before calling super.dispose()", "author": "lolodomo", "createdAt": "2021-01-16T17:49:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.debug(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.debug(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        cavityTemperatureFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            @Nullable\n+            String operationState = getOperationState();\n+            boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature;\n+\n+            if (STATE_OPERATION_RUN.equals(operationState)) {\n+                getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(c -> {\n+                    if (manuallyUpdateCavityTemperature) {\n+                        logger.debug(\"Update cavity temperature manually via API. haId={}\", getThingHaId());\n+                        updateChannel(c.getUID());\n+                    } else {\n+                        logger.debug(\"Update cavity temperature via SSE, don't need to fetch manually. haId={}\",\n+                                getThingHaId());\n+                    }\n+                });\n+            }\n+        }, CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, CAVITY_TEMPERATURE_SCHEDULER_PERIOD, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2ODg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563268879", "bodyText": "Will change it", "author": "bruestel", "createdAt": "2021-01-24T10:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4NjYwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558986606", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:02:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2OTE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563269172", "bodyText": "Agree", "author": "bruestel", "createdAt": "2021-01-24T10:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4NjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzg4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558987883", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:05:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2OTQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563269476", "bodyText": "Agree", "author": "bruestel", "createdAt": "2021-01-24T10:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558987942", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:05:48Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989012", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:08:33Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3MDE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563270157", "bodyText": "I switched to a switch statement.", "author": "bruestel", "createdAt": "2021-01-24T10:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989076", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:08:38Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTEwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989105", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:08:44Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989915", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T18:11:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link HomeConnectCooktopHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n+\n+    public HomeConnectCooktopHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3NjQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563276452", "bodyText": "Will remove and test it.", "author": "bruestel", "createdAt": "2021-01-24T11:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3ODUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563278521", "bodyText": "I don't say this is useless, I rather say that it is not called at the right place ;)", "author": "lolodomo", "createdAt": "2021-01-24T11:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3OTI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563279278", "bodyText": "I think it is useless at that place, as it resets some channels back to UnDefType.UNDEF.\nIt should be only used if a program finished or if something went wrong (API error etc.).", "author": "bruestel", "createdAt": "2021-01-24T11:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558990022", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T18:11:42Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDI2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558990263", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T18:12:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r559004792", "bodyText": "If method is called while your thing (bridge) was not yet initialized, oAuthClientService will be null.\nIt would be safer to check that this variable is not null.", "author": "lolodomo", "createdAt": "2021-01-16T18:56:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928933", "bodyText": "Maybe it should be made Nullable.", "author": "fwolter", "createdAt": "2021-03-10T22:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MTQ3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624641471", "bodyText": "will adjust it", "author": "bruestel", "createdAt": "2021-05-02T06:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NDE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564794169", "bodyText": "It looks like this class is not used.", "author": "lolodomo", "createdAt": "2021-01-26T19:59:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/exception/ProxySetupException.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * HTTP proxy setup exception\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class ProxySetupException extends RuntimeException {", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MzE2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585783165", "bodyText": "Now deleted (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NDE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NTMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564795313", "bodyText": "Call to super() is useless I believe", "author": "lolodomo", "createdAt": "2021-01-26T20:01:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * HTTP response model.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectResponse {\n+    private final int code;\n+    private final Map<String, String> header;\n+    private final @Nullable String body;\n+\n+    public HomeConnectResponse(int code, Map<String, String> header, @Nullable String body) {\n+        super();", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585783605", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5ODQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564798430", "bodyText": "Please don't use org.apache.commons.lang.StringUtils, we search to remove tthis dependency.\nThis can easily be replaced I believe.", "author": "lolodomo", "createdAt": "2021-01-26T20:06:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        String path = BASE_PATH + haId + \"/programs/available/\" + programKey;\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.code() == HTTP_OK) {\n+                return responseBody;\n+            }\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(asList(HTTP_OK, HTTP_NOT_FOUND), request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.code() == HTTP_OK) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(ACCEPT, BSH_JSON_V1).delete()\n+                .build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, Response response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, Response response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HTTP_UNAUTHORIZED) && response.code() == HTTP_UNAUTHORIZED) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = \"\";\n+            try {\n+                responseBody = mapToString(response.body());\n+            } catch (IOException e) {\n+                logger.error(\"Could not get HTTP response body as string.\", e);\n+            }\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.code())) {\n+            int code = response.code();\n+            String message = response.message();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = \"\";\n+            try {\n+                responseBody = mapToString(response.body());\n+            } catch (IOException e) {\n+                logger.error(\"Could not get HTTP response body as string.\", e);\n+            }\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            if (code == HTTP_CONFLICT && containsIgnoreCase(responseBody, \"error\")", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MzgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585783838", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5ODQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5OTc0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564799741", "bodyText": "Please remove use of org.apache.commons.lang.StringUtils\nShould be easy here.", "author": "lolodomo", "createdAt": "2021-01-26T20:08:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NDA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585784058", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5OTc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxMjIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564812214", "bodyText": "Please add the missing parameter haId", "author": "lolodomo", "createdAt": "2021-01-26T20:30:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = new CircularQueue<>(EVENT_QUEUE_SIZE);\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Connect API. This helps to reduce the\n+     * amount of request you would usually need to update all channels.\n+     *\n+     * Checkout rate limits of the API at. https://developer.home-connect.com/docs/general/ratelimiting\n+     *\n+     * @param eventListener appliance event listener", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NDg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585784869", "bodyText": "Done (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxMjIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDMwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564820309", "bodyText": "Please add the missing parameter unit", "author": "lolodomo", "createdAt": "2021-01-26T20:44:33Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NDMwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585784302", "bodyText": "Done (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDYwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564820603", "bodyText": "Please add the missing parameter unit", "author": "lolodomo", "createdAt": "2021-01-26T20:45:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NTYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585785631", "bodyText": "Done (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564830030", "bodyText": "Please remove use of org.apache.commons.lang.StringUtils", "author": "lolodomo", "createdAt": "2021-01-26T21:01:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,628 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzk0OTAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r567949021", "bodyText": "Yes, will do. One user reported it on the weekend. In some circumstances Apache Commons was missing in the OH3 environment.", "author": "bruestel", "createdAt": "2021-02-01T16:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NTI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585785283", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMjE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564832143", "bodyText": "You need to try a second time ?", "author": "lolodomo", "createdAt": "2021-01-26T21:05:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,628 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MTgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624641830", "bodyText": "Left over. Will remove it", "author": "bruestel", "createdAt": "2021-05-02T06:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMjE0Mw=="}], "type": "inlineReview"}, {"oid": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "url": "https://github.com/openhab/openhab-addons/commit/77806786a7e91f9029fb1ba90a236d87ca371f7e", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T16:55:29Z", "type": "forcePushed"}, {"oid": "edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "url": "https://github.com/openhab/openhab-addons/commit/edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T16:59:18Z", "type": "forcePushed"}, {"oid": "4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "url": "https://github.com/openhab/openhab-addons/commit/4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T17:06:32Z", "type": "forcePushed"}, {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d", "url": "https://github.com/openhab/openhab-addons/commit/d87bf3c15b837ef0487e30f37e609e29f9aa438d", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T17:13:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591873349", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n          \n          \n            \n                        .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n          \n          \n            \n                        .collect(Collectors.toSet());\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Set\n          \n          \n            \n                        .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP);", "author": "fwolter", "createdAt": "2021-03-10T21:09:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link HomeConnectBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBindingConstants {\n+\n+    public static final String BINDING_ID = \"homeconnect\";\n+\n+    public static final String HA_ID = \"haId\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_API_BRIDGE = new ThingTypeUID(BINDING_ID, \"api_bridge\");\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+    public static final ThingTypeUID THING_TYPE_WASHER = new ThingTypeUID(BINDING_ID, \"washer\");\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washerdryer\");\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridgefreezer\");\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+    public static final ThingTypeUID THING_TYPE_COFFEE_MAKER = new ThingTypeUID(BINDING_ID, \"coffeemaker\");\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+    public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    // Setting\n+    public static final String SETTING_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String SETTING_LIGHTING = \"Cooking.Common.Setting.Lighting\";\n+    public static final String SETTING_AMBIENT_LIGHT_ENABLED = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String SETTING_LIGHTING_BRIGHTNESS = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_BRIGHTNESS = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_COLOR = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String SETTING_AMBIENT_LIGHT_CUSTOM_COLOR = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+    public static final String SETTING_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String SETTING_REFRIGERATOR_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String SETTING_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+\n+    // Status\n+    public static final String STATUS_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String STATUS_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String STATUS_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String STATUS_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String STATUS_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+\n+    // SSE Event types\n+    public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+    public static final String EVENT_POWER_STATE = SETTING_POWER_STATE;\n+    public static final String EVENT_CONNECTED = \"CONNECTED\";\n+    public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n+    public static final String EVENT_DOOR_STATE = STATUS_DOOR_STATE;\n+    public static final String EVENT_OPERATION_STATE = STATUS_OPERATION_STATE;\n+    public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n+    public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = STATUS_REMOTE_CONTROL_START_ALLOWED;\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = STATUS_REMOTE_CONTROL_ACTIVE;\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = STATUS_LOCAL_CONTROL_ACTIVE;\n+    public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String EVENT_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String EVENT_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String EVENT_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String EVENT_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String EVENT_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String EVENT_FREEZER_SETPOINT_TEMPERATURE = SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+    public static final String EVENT_FRIDGE_SETPOINT_TEMPERATURE = SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+    public static final String EVENT_FREEZER_SUPER_MODE = SETTING_FREEZER_SUPER_MODE;\n+    public static final String EVENT_FRIDGE_SUPER_MODE = SETTING_REFRIGERATOR_SUPER_MODE;\n+    public static final String EVENT_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.BeanContainerEmpty\";\n+    public static final String EVENT_COFFEEMAKER_WATER_TANK_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.WaterTankEmpty\";\n+    public static final String EVENT_COFFEEMAKER_DRIP_TRAY_FULL = \"ConsumerProducts.CoffeeMaker.Event.DripTrayFull\";\n+    public static final String EVENT_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String EVENT_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_STATE = SETTING_LIGHTING;\n+    public static final String EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = SETTING_LIGHTING_BRIGHTNESS;\n+    public static final String EVENT_AMBIENT_LIGHT_STATE = SETTING_AMBIENT_LIGHT_ENABLED;\n+    public static final String EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE = SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+    public static final String EVENT_AMBIENT_LIGHT_COLOR_STATE = SETTING_AMBIENT_LIGHT_COLOR;\n+    public static final String EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+\n+    // Channel IDs\n+    public static final String CHANNEL_DOOR_STATE = \"door_state\";\n+    public static final String CHANNEL_ELAPSED_PROGRAM_TIME = \"elapsed_program_time\";\n+    public static final String CHANNEL_POWER_STATE = \"power_state\";\n+    public static final String CHANNEL_OPERATION_STATE = \"operation_state\";\n+    public static final String CHANNEL_ACTIVE_PROGRAM_STATE = \"active_program_state\";\n+    public static final String CHANNEL_SELECTED_PROGRAM_STATE = \"selected_program_state\";\n+    public static final String CHANNEL_BASIC_ACTIONS_STATE = \"basic_actions_state\";\n+    public static final String CHANNEL_REMOTE_START_ALLOWANCE_STATE = \"remote_start_allowance_state\";\n+    public static final String CHANNEL_REMOTE_CONTROL_ACTIVE_STATE = \"remote_control_active_state\";\n+    public static final String CHANNEL_LOCAL_CONTROL_ACTIVE_STATE = \"local_control_active_state\";\n+    public static final String CHANNEL_REMAINING_PROGRAM_TIME_STATE = \"remaining_program_time_state\";\n+    public static final String CHANNEL_PROGRAM_PROGRESS_STATE = \"program_progress_state\";\n+    public static final String CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE = \"oven_current_cavity_temperature\";\n+    public static final String CHANNEL_SETPOINT_TEMPERATURE = \"setpoint_temperature\";\n+    public static final String CHANNEL_DURATION = \"duration\";\n+    public static final String CHANNEL_WASHER_TEMPERATURE = \"laundry_care_washer_temperature\";\n+    public static final String CHANNEL_WASHER_SPIN_SPEED = \"laundry_care_washer_spin_speed\";\n+    public static final String CHANNEL_WASHER_IDOS1 = \"laundry_care_washer_idos1\";\n+    public static final String CHANNEL_WASHER_IDOS2 = \"laundry_care_washer_idos2\";\n+    public static final String CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE = \"setpoint_temperature_refrigerator\";\n+    public static final String CHANNEL_REFRIGERATOR_SUPER_MODE = \"super_mode_refrigerator\";\n+    public static final String CHANNEL_FREEZER_SETPOINT_TEMPERATURE = \"setpoint_temperature_freezer\";\n+    public static final String CHANNEL_FREEZER_SUPER_MODE = \"super_mode_freezer\";\n+    public static final String CHANNEL_DRYER_DRYING_TARGET = \"dryer_drying_target\";\n+    public static final String CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE = \"coffeemaker_drip_tray_full_state\";\n+    public static final String CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE = \"coffeemaker_water_tank_empty_state\";\n+    public static final String CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE = \"coffeemaker_bean_container_empty_state\";\n+    public static final String CHANNEL_HOOD_VENTING_LEVEL = \"hood_venting_level\";\n+    public static final String CHANNEL_HOOD_INTENSIVE_LEVEL = \"hood_intensive_level\";\n+    public static final String CHANNEL_HOOD_ACTIONS_STATE = \"hood_program_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_STATE = \"functional_light_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"functional_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_STATE = \"ambient_light_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"ambient_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_COLOR_STATE = \"ambient_light_color_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"ambient_light_custom_color_state\";\n+\n+    // List of all supported devices\n+    public static final Set<ThingTypeUID> SUPPORTED_DEVICE_THING_TYPES_UIDS = Stream.of(THING_TYPE_API_BRIDGE,\n+            THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+            THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // Discoverable devices\n+    public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n+            .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM0MTY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593341656", "bodyText": "This is Java 11 syntax only, isn't it ?\n@bruestel tries to maintain a common code for OH 2.5 and OH3.", "author": "lolodomo", "createdAt": "2021-03-12T17:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyMTUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600221507", "bodyText": "Will change it", "author": "bruestel", "createdAt": "2021-03-24T07:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3NjAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591876008", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2021-03-10T21:14:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591882899", "bodyText": "As this pattern occurs quite often, you could simplify code by including the message in the exception. Then, you only need to log the message once, where the exception is caught finally.\nAlso, take care to handle the InterruptedException appropriately. The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n          \n          \n            \n                        logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n          \n          \n            \n                        trackAndLogApiRequest(null, request, null, null, null);\n          \n          \n            \n                        throw new CommunicationException(e);\n          \n          \n            \n                    }\n          \n          \n            \n                    } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n          \n          \n            \n                        trackAndLogApiRequest(null, request, null, null, null);\n          \n          \n            \n                        throw new CommunicationException(\"Failed to fetch home appliances\", e);\n          \n          \n            \n                    }", "author": "fwolter", "createdAt": "2021-03-10T21:25:41Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyNDAyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600224020", "bodyText": "The trackAndLogApiRequest just logs the HTTP request for the web UI. If debug logging level is enabled it also prints the request to the console.\n--> if debug level is set to info or higher, the user won't be able to recognize the communication problem\nI would like to distinguish request from \"normal\" logging.", "author": "bruestel", "createdAt": "2021-03-24T07:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MjI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624642260", "bodyText": "@fwolter Can I resolve this conversation?", "author": "bruestel", "createdAt": "2021-05-02T06:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NzM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647350", "bodyText": "Yes", "author": "fwolter", "createdAt": "2021-05-02T07:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4ODE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591888151", "bodyText": "As this can also happen if the JSON contains unexpected data, this should be warn. error can be used if a bug in your code has been detected, for example.", "author": "fwolter", "createdAt": "2021-03-10T21:34:12Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId + \"/programs/available/\" + programKey);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.getStatus() == HttpStatus.OK_200) {\n+                return responseBody;\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(asList(HttpStatus.OK_200, HttpStatus.NOT_FOUND_404), request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.DELETE, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, ContentResponse response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, ContentResponse response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HttpStatus.UNAUTHORIZED_401)\n+                && response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.getStatus())) {\n+            int code = response.getStatus();\n+            String message = response.getReason();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            responseBody = responseBody == null ? \"\" : responseBody;\n+            if (code == HttpStatus.CONFLICT_409 && responseBody.toLowerCase().contains(\"error\")\n+                    && responseBody.toLowerCase().contains(\"offline\")) {\n+                throw new ApplianceOfflineException(code, message, responseBody);\n+            } else {\n+                throw new CommunicationException(code, message, responseBody);\n+            }\n+        }\n+    }\n+\n+    private Program mapToProgram(String json) {\n+        ArrayList<Option> optionList = new ArrayList<>();\n+        JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+        JsonObject data = responseObject.getAsJsonObject(\"data\");\n+        Program result = new Program(data.get(\"key\").getAsString(), optionList);\n+        JsonArray options = data.getAsJsonArray(\"options\");\n+\n+        options.forEach(option -> {\n+            JsonObject obj = (JsonObject) option;\n+\n+            @Nullable\n+            String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+            @Nullable\n+            String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull() ? obj.get(\"value\").getAsString()\n+                    : null;\n+            @Nullable\n+            String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+\n+            optionList.add(new Option(key, value, unit));\n+        });\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgram> mapToAvailablePrograms(String json, String haId) {\n+        ArrayList<AvailableProgram> result = new ArrayList<>();\n+\n+        try {\n+            JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+\n+            JsonArray programs = responseObject.getAsJsonObject(\"data\").getAsJsonArray(\"programs\");\n+            programs.forEach(program -> {\n+                JsonObject obj = (JsonObject) program;\n+                @Nullable\n+                String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                JsonObject constraints = obj.getAsJsonObject(\"constraints\");\n+                boolean available = constraints.get(\"available\") != null && constraints.get(\"available\").getAsBoolean();\n+                @Nullable\n+                String execution = constraints.get(\"execution\") != null ? constraints.get(\"execution\").getAsString()\n+                        : null;\n+\n+                if (key != null && execution != null) {\n+                    result.add(new AvailableProgram(key, available, execution));\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.error(\"Could not parse available programs response! haId={}, error={}\", haId, e.getMessage());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyNDU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600224568", "bodyText": "will change it", "author": "bruestel", "createdAt": "2021-03-24T07:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4ODE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4OTA5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591889099", "bodyText": "Is there any reason why you don't use DTOs for the mapping methods?", "author": "fwolter", "createdAt": "2021-03-10T21:35:48Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId + \"/programs/available/\" + programKey);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.getStatus() == HttpStatus.OK_200) {\n+                return responseBody;\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(asList(HttpStatus.OK_200, HttpStatus.NOT_FOUND_404), request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.DELETE, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, ContentResponse response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, ContentResponse response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HttpStatus.UNAUTHORIZED_401)\n+                && response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.getStatus())) {\n+            int code = response.getStatus();\n+            String message = response.getReason();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            responseBody = responseBody == null ? \"\" : responseBody;\n+            if (code == HttpStatus.CONFLICT_409 && responseBody.toLowerCase().contains(\"error\")\n+                    && responseBody.toLowerCase().contains(\"offline\")) {\n+                throw new ApplianceOfflineException(code, message, responseBody);\n+            } else {\n+                throw new CommunicationException(code, message, responseBody);\n+            }\n+        }\n+    }\n+\n+    private Program mapToProgram(String json) {\n+        ArrayList<Option> optionList = new ArrayList<>();\n+        JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+        JsonObject data = responseObject.getAsJsonObject(\"data\");\n+        Program result = new Program(data.get(\"key\").getAsString(), optionList);\n+        JsonArray options = data.getAsJsonArray(\"options\");\n+\n+        options.forEach(option -> {\n+            JsonObject obj = (JsonObject) option;\n+\n+            @Nullable\n+            String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+            @Nullable\n+            String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull() ? obj.get(\"value\").getAsString()\n+                    : null;\n+            @Nullable\n+            String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+\n+            optionList.add(new Option(key, value, unit));\n+        });\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgram> mapToAvailablePrograms(String json, String haId) {\n+        ArrayList<AvailableProgram> result = new ArrayList<>();\n+\n+        try {\n+            JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+\n+            JsonArray programs = responseObject.getAsJsonObject(\"data\").getAsJsonArray(\"programs\");\n+            programs.forEach(program -> {\n+                JsonObject obj = (JsonObject) program;\n+                @Nullable\n+                String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                JsonObject constraints = obj.getAsJsonObject(\"constraints\");\n+                boolean available = constraints.get(\"available\") != null && constraints.get(\"available\").getAsBoolean();\n+                @Nullable\n+                String execution = constraints.get(\"execution\") != null ? constraints.get(\"execution\").getAsString()\n+                        : null;\n+\n+                if (key != null && execution != null) {\n+                    result.add(new AvailableProgram(key, available, execution));\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.error(\"Could not parse available programs response! haId={}, error={}\", haId, e.getMessage());\n+        }\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgramOption> mapToAvailableProgramOption(String json, String haId) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyNTI3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600225272", "bodyText": "No there is no reason for it.", "author": "bruestel", "createdAt": "2021-03-24T07:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4OTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MTgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591891816", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed.", "author": "fwolter", "createdAt": "2021-03-10T21:40:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.sse.SseEventSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, SseEventSource> eventSourceConnections;\n+    private final Map<SseEventSource, HomeConnectEventSourceListener> eventSourceListeners;\n+    private final ScheduledExecutorService scheduler;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+\n+    public HomeConnectEventSourceClient(ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            OAuthClientService oAuthClientService, boolean simulated, ScheduledExecutorService scheduler,\n+            @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceConnections = new HashMap<>();\n+        eventSourceListeners = new HashMap<>();\n+        eventQueue = new CircularQueue<>(EVENT_QUEUE_SIZE);\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Connect API. This helps to reduce the\n+     * amount of request you would usually need to update all channels.\n+     *\n+     * Checkout rate limits of the API at. https://developer.home-connect.com/docs/general/ratelimiting\n+     *\n+     * @param haId appliance id\n+     * @param eventListener appliance event listener\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public synchronized void registerEventListener(final String haId, final HomeConnectEventListener eventListener)\n+            throws CommunicationException, AuthorizationException {\n+        logger.debug(\"Register event listener for '{}': {}\", haId, eventListener);\n+\n+        if (!eventSourceConnections.containsKey(eventListener)) {\n+            logger.debug(\"Create new event source listener for '{}'.\", haId);\n+            Client client = clientBuilder.readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).register(\n+                    new HomeConnectStreamingRequestFilter(HttpHelper.getAuthorizationHeader(oAuthClientService)))\n+                    .build();\n+            SseEventSource eventSource = eventSourceFactory\n+                    .newSource(client.target(apiUrl + \"/api/homeappliances/\" + haId + \"/events\"));\n+            HomeConnectEventSourceListener eventSourceListener = new HomeConnectEventSourceListener(haId, eventListener,\n+                    this, scheduler, eventQueue);\n+            eventSource.register(eventSourceListener::onEvent, eventSourceListener::onError,\n+                    eventSourceListener::onComplete);\n+            eventSourceListeners.put(eventSource, eventSourceListener);\n+            eventSourceConnections.put(eventListener, eventSource);\n+            eventSource.open();\n+        }\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener) {\n+        unregisterEventListener(eventListener, false, false);\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     * @param completed true when the event source is known as already completed by the server\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener, boolean completed) {\n+        unregisterEventListener(eventListener, false, completed);\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     * @param immediate true when the unregistering of the event source has to be fast\n+     * @param completed true when the event source is known as already completed by the server\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener, boolean immediate,\n+            boolean completed) {\n+        if (eventSourceConnections.containsKey(eventListener)) {\n+            @Nullable\n+            SseEventSource eventSource = eventSourceConnections.get(eventListener);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIzMTAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600231030", "bodyText": "will fix it", "author": "bruestel", "createdAt": "2021-03-24T07:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MjY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591892664", "bodyText": "See above. Suffix.", "author": "fwolter", "createdAt": "2021-03-10T21:41:28Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893144", "bodyText": "See above. Could be removed. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T21:42:14Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893544", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2021-03-10T21:42:57Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIzNjc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600236778", "bodyText": "Unfortunately not, at this point all HomeConnectEventListener implementations get informed about a new event. Any class which is implementing this interface could throw an exception. To ensure that all listeners get the event, the errors are caught.", "author": "bruestel", "createdAt": "2021-03-24T07:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5Mzg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893882", "bodyText": "See above. Concrete type. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T21:43:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    public void onComplete() {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener, true);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIzNjkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600236923", "bodyText": "Same as above", "author": "bruestel", "createdAt": "2021-03-24T07:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5Mzg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591895901", "bodyText": "If I see correctly, this is run in a framework thread, which shouldn't be blocked by sleeps. You could submit an executor task with a delay.", "author": "fwolter", "createdAt": "2021-03-10T21:47:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    public void onComplete() {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener, true);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    public void onError(Throwable error) {\n+        @Nullable\n+        String throwableMessage = error.getMessage();\n+        String throwableClass = error.getClass().getName();\n+\n+        logger.debug(\"Event source listener connection failure occurred. haId={}, throwable={}, throwableMessage={}\",\n+                haId, throwableClass, throwableMessage);\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            if (throwableMessage != null\n+                    && throwableMessage.contains(String.valueOf(HttpStatus.TOO_MANY_REQUESTS_429))) {\n+                logger.warn(\n+                        \"More than 10 active event monitoring channels was reached. Further event monitoring requests are blocked. haId={}\",\n+                        haId);\n+                eventListener.onRateLimitReached();\n+            } else {\n+                // The SSE connection is closed by the server every 24 hours.\n+                // When you try to reconnect, it often fails with a NotAuthorizedException (401) for the next few\n+                // seconds. So we wait few seconds before trying again.\n+                if (error instanceof NotAuthorizedException) {\n+                    logger.debug(\n+                            \"Event source listener connection failure due to unauthorized exception : wait 5 seconds... haId={}\",\n+                            haId);\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException e1) {\n+                    }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM0NzkwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593347903", "bodyText": "No this is not handled by a framework thread.\nI believe it is handled by a thread created by JAX-RS SSE.\nScheduling a task with a delay here will add complexity to the code IMHO.", "author": "lolodomo", "createdAt": "2021-03-12T17:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Mzc4NDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593784437", "bodyText": "I would consider JAX-RS SSE as part of the framework. I couldn't figure out at first glance which thread pool is used or if any is used at all. If it is a shared thread pool, sleep must not be used. You could break into it and check the stack trace.\nI don't think it would make the code much more complicated.", "author": "fwolter", "createdAt": "2021-03-13T18:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0MDMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600240326", "bodyText": "Would it be ok to change it to:\n                if (error instanceof NotAuthorizedException) {\n                    logger.debug(\n                            \"Event source listener connection failure due to unauthorized exception : wait 5 seconds... haId={}\",\n                            haId);\n\n                    scheduler.schedule(() -> eventListener.onClosed(), 5, TimeUnit.SECONDS);\n                } else {\n                    eventListener.onClosed();\n                }", "author": "bruestel", "createdAt": "2021-03-24T07:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ3NTA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r602475063", "bodyText": "Sure!", "author": "fwolter", "createdAt": "2021-03-26T17:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591897838", "bodyText": "Is this bucket valid for all Things/accounts by intention, as it is static? I would expect the rate limiting only valid per account.", "author": "fwolter", "createdAt": "2021-03-10T21:50:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM1NzcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593357725", "bodyText": "You're certainly right.\n@bruestel : do you agree ?", "author": "lolodomo", "createdAt": "2021-03-12T17:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0NTU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600245540", "bodyText": "Yes, good thought. Thanks @fwolter . I will move the code to the HomeConnectApiClient. Each account is using it's own client instance.", "author": "bruestel", "createdAt": "2021-03-24T07:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591898419", "bodyText": "If you need to access the logger in a static way, you can make it a static field. This should be debug or warn.", "author": "fwolter", "createdAt": "2021-03-10T21:51:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ0OTkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619449919", "bodyText": "Does the error message suite the exception type? An InterruptedException is thrown when the current Thread is interrupted. E.g. when OH is shut down.\nBindings should only log to error if something severe happened, like the detection of a bug in your code. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging\nThis method throws InterruptedException, but it is cought here.", "author": "fwolter", "createdAt": "2021-04-23T19:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MjU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624642569", "bodyText": "Changed log level to debug and adjusted error message. \"Could not consume from bucket! clientId={}, error={}\"", "author": "bruestel", "createdAt": "2021-05-02T06:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591899971", "bodyText": "As you already set the exception's cause, you don't need to also add the message.", "author": "fwolter", "createdAt": "2021-03-10T21:54:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());\n+            }\n+        }\n+        return request.send();\n+    }\n+\n+    public static String formatJsonBody(@Nullable String jsonString) {\n+        if (jsonString == null) {\n+            return \"\";\n+        }\n+        try {\n+            JsonObject json = JSON_PARSER.parse(jsonString).getAsJsonObject();\n+            return GSON.toJson(json);\n+        } catch (Exception e) {\n+            return jsonString;\n+        }\n+    }\n+\n+    public static String getAuthorizationHeader(OAuthClientService oAuthClientService)\n+            throws AuthorizationException, CommunicationException {\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            // refresh the token if it's about to expire\n+            if (accessTokenResponse != null\n+                    && accessTokenResponse.isExpired(LocalDateTime.now(), OAUTH_EXPIRE_BUFFER)) {\n+                LoggerFactory.getLogger(HttpHelper.class).debug(\"Requesting a refresh of the access token.\");\n+                accessTokenResponse = oAuthClientService.refreshToken();\n+            }\n+\n+            if (accessTokenResponse != null) {\n+                String lastToken = lastAccessToken;\n+                if (lastToken == null) {\n+                    LoggerFactory.getLogger(HttpHelper.class).debug(\"The used access token was created at {}\",\n+                            accessTokenResponse.getCreatedOn().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n+                } else if (!lastToken.equals(accessTokenResponse.getAccessToken())) {\n+                    LoggerFactory.getLogger(HttpHelper.class).debug(\"The access token changed. New one created at {}\",\n+                            accessTokenResponse.getCreatedOn().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n+                }\n+                lastAccessToken = accessTokenResponse.getAccessToken();\n+                return BEARER + accessTokenResponse.getAccessToken();\n+            } else {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"No access token available! Fatal error.\");\n+                throw new AuthorizationException(\"No access token available!\");\n+            }\n+        } catch (IOException e) {\n+            @Nullable\n+            String errorMessage = e.getMessage();\n+            throw new CommunicationException(errorMessage != null ? errorMessage : \"IOException\", e);\n+        } catch (OAuthException | OAuthResponseException e) {\n+            @Nullable\n+            String errorMessage = e.getMessage();\n+            throw new AuthorizationException(errorMessage != null ? errorMessage : \"oAuth exception\", e);\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0Njk0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600246949", "bodyText": "I did it because the exception message is shown in the UI. Makes it easier for the users to see what's wrong.", "author": "bruestel", "createdAt": "2021-03-24T07:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ3NzEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r602477136", "bodyText": "You could move this code to where the exception is translated into a string to pass it as status detail message. That would remove the redundant error message.", "author": "fwolter", "createdAt": "2021-03-26T17:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMzU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591903583", "bodyText": "This could by null due to concurrency.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n          \n          \n            \n                private @Nullable HomeConnectBridgeHandler bridgeHandler;", "author": "fwolter", "createdAt": "2021-03-10T22:00:35Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0OTQ2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600249460", "bodyText": "will change it", "author": "bruestel", "createdAt": "2021-03-24T08:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904014", "bodyText": "This could be removed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {\n          \n          \n            \n                public void setThingHandler(ThingHandler handler) {", "author": "fwolter", "createdAt": "2021-03-10T22:01:28Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService}.\n+     *\n+     */\n+    public HomeConnectDiscoveryService() {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904764", "bodyText": "See above. Concrete type. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T22:02:55Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService}.\n+     *\n+     */\n+    public HomeConnectDiscoveryService() {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {\n+        if (handler instanceof HomeConnectBridgeHandler) {\n+            this.bridgeHandler = (HomeConnectBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (thingTypeUID != null) {\n+                    logger.debug(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties).withRepresentationProperty(HA_ID)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTM2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905365", "bodyText": "See above. Suffix.", "author": "fwolter", "createdAt": "2021-03-10T22:04:02Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905691", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-03-10T22:04:39Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM1MTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593351069", "bodyText": "You mean here using logger.trace ?\nThis is a typical DEBUG log you can find in many bindings.", "author": "lolodomo", "createdAt": "2021-03-12T17:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1MTg1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619451856", "bodyText": "This is already logged by the framework and can therefore be removed. See the popular loggers table: https://www.openhab.org/docs/administration/logging.html#defining-what-to-log", "author": "fwolter", "createdAt": "2021-04-23T19:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905963", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2021-03-10T22:05:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591907411", "bodyText": "Actually this is handled by the framework. Any child Things are set to OFFLINE if the bridge is offline. This is done if the child Things are UNKNOWN or ONLINE.", "author": "fwolter", "createdAt": "2021-03-10T22:07:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NDEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624644104", "bodyText": "Is it harmful if I put it explicitly? I do it because the initialize() method can also be called by a scheduler (\"monitor\") within the binding.", "author": "bruestel", "createdAt": "2021-05-02T07:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NzU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647567", "bodyText": "No, you can leave it as is.", "author": "fwolter", "createdAt": "2021-05-02T07:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591907740", "bodyText": "See above. Logging could be removed. Same for below.", "author": "fwolter", "createdAt": "2021-03-10T22:08:02Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591909783", "bodyText": "You could add the message to updateStatus() as an argument, to display it in the UI. The log message can be removed, then. Same for below.", "author": "fwolter", "createdAt": "2021-03-10T22:11:53Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1MjM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619452370", "bodyText": "Can you comment on my comment?", "author": "fwolter", "createdAt": "2021-04-23T19:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NTA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624645076", "bodyText": "In my opinion, the message 'Could not handle command...' in the Thing status is not appropriate. It is an error message as a result of an action. I think it is ok to set the status to OFFLINE without a message.", "author": "bruestel", "createdAt": "2021-05-02T07:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NzkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647931", "bodyText": "If it can only fail if the device is offline, you could add \"Communication timed out\" or so, to the status detail message.\nWill the Thing come online again, when it is reachable again?", "author": "fwolter", "createdAt": "2021-05-02T07:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY2MjIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624662214", "bodyText": "Yes will come online again. Will change it as suggested.", "author": "bruestel", "createdAt": "2021-05-02T09:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMDA3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591910071", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-03-10T22:12:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMjQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591912498", "bodyText": "Are these checks necessary? If I see correctly, the Thing is set OFFLINE if there is no bridge or the bridge is offline. Then, the third check would be sufficient.", "author": "fwolter", "createdAt": "2021-03-10T22:16:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2MDc4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600260782", "bodyText": "Yes the thing should be offline when the bridge is not present.\nI added it to make sure everything is fine before executing a command. Sometimes concurrent processes run, so I wanted to be sure. I think the check doesn't hurt and I would like to keep it.", "author": "bruestel", "createdAt": "2021-03-24T08:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591914566", "bodyText": "Can you use isThingReadyToHandleCommand() here?", "author": "fwolter", "createdAt": "2021-03-10T22:20:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2NDA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600264068", "bodyText": "yes", "author": "bruestel", "createdAt": "2021-03-24T08:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNTg5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591915892", "bodyText": "What is the reason for catching RuntimeExceptions? Actually, these are handled by the framework.", "author": "fwolter", "createdAt": "2021-03-10T22:23:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2NTExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600265112", "bodyText": "leftover", "author": "bruestel", "createdAt": "2021-03-24T08:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNTg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxODYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591918616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n          \n          \n            \n                            STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n          \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n          \n          \n            \n                            OnOffType.from(!STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()))));", "author": "fwolter", "createdAt": "2021-03-10T22:28:17Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxOTE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591919167", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(\n          \n          \n            \n                            channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n          \n          \n            \n                    return event -> getThingChannel(channelId)\n          \n          \n            \n                            .ifPresent(channel -> updateState(channel.getUID(), OnOffType.from(event.getValueAsBoolean())));", "author": "fwolter", "createdAt": "2021-03-10T22:29:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyMDEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591920130", "bodyText": "See above. Use from(). Please check all.", "author": "fwolter", "createdAt": "2021-03-10T22:31:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyMzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591923672", "bodyText": "Can you use isThingReadyToHandleCommand() here?", "author": "fwolter", "createdAt": "2021-03-10T22:38:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelTemperature.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelDryingTarget.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        channelSpinSpeed\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherSpinSpeed)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        channelTemperature\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherTemperature)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                                .setStateOptions(channel.getUID(), createStateOptions(option, this::mapStringType)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private List<StateOption> createStateOptions(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        return option.getAllowedValues().stream().map(av -> new StateOption(av, stateConverter.apply(av)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591924952", "bodyText": "Is there any difference between the two, beside the delay?", "author": "fwolter", "createdAt": "2021-03-10T22:40:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelTemperature.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelDryingTarget.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        channelSpinSpeed\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherSpinSpeed)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        channelTemperature\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherTemperature)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                                .setStateOptions(channel.getUID(), createStateOptions(option, this::mapStringType)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private List<StateOption> createStateOptions(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        return option.getAllowedValues().stream().map(av -> new StateOption(av, stateConverter.apply(av)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    reinitialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);\n+            this.reinitializationFuture1 = null;\n+        }\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor2() {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0Nzg0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647847", "bodyText": "It's complicated :-D\nMonitor 1\nChecks every 30 minutes if thing is ONLINE again (isBridgeOnline() && isThingOffline()). This is the 'normal' monitor.\nMonitor 2\nChecks every 4 minutes if thing is accessible again (isBridgeOnline() && !accessible.get()). Things can be OFFLINE but still be connect to the cloud. The appliances are not really OFFLINE, they are just turned off and in the UI it's shown as OFFLINE.\nIf an appliance is not connected, it's usually caused by a network or Home Connect service problem.", "author": "bruestel", "createdAt": "2021-05-02T07:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0ODQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624648432", "bodyText": "OK", "author": "fwolter", "createdAt": "2021-05-02T07:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNTUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591925519", "bodyText": "See above. Suffix.", "author": "fwolter", "createdAt": "2021-03-10T22:41:44Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNjQ5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591926499", "bodyText": "Is there any reason for logging the OH version?", "author": "fwolter", "createdAt": "2021-03-10T22:43:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2ODI5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600268293", "bodyText": "leftover from previous logging system", "author": "bruestel", "createdAt": "2021-03-24T08:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNjQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNzUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591927530", "bodyText": "These can be null if the user forgets to specify them with textual configuration.", "author": "fwolter", "createdAt": "2021-03-10T22:45:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link ApiBridgeConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiBridgeConfiguration {\n+\n+    private @NonNullByDefault({}) String clientId;\n+    private @NonNullByDefault({}) String clientSecret;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzcyODUxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593728518", "bodyText": "I would suggest to set it by default to an empty string and then check in the thing handler initialization that the value is not empty. If value is empty, you set a CONFIGURATION_ERROR.\nprivate String clientId = \"\";", "author": "lolodomo", "createdAt": "2021-03-13T09:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNzUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODIwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928209", "bodyText": "See above. Could be removed. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T22:47:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928503", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-03-10T22:47:36Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(true);\n+    }\n+\n+    public void reinitialize() {\n+        logger.debug(\"Reinitialize bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(false);\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyOTIwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591929201", "bodyText": "See above, info and error.", "author": "fwolter", "createdAt": "2021-03-10T22:49:00Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(true);\n+    }\n+\n+    public void reinitialize() {\n+        logger.debug(\"Reinitialize bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(false);\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {\n+                logger.info(\"Clear oAuth credential store. bridge={}\", getThing().getLabel());\n+                oAuthClientService.remove();\n+            } catch (OAuthException e) {\n+                logger.error(\"Could not clear oAuth credentials. bridge={}\", getThing().getLabel(), e);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzMzIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591933236", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n          \n          \n            \n                private static final List<String> INACTIVE_STATE = List.of(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "author": "fwolter", "createdAt": "2021-03-10T22:56:52Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzMzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591933773", "bodyText": "The super type should be used where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n          \n          \n            \n                protected void configureChannelUpdateHandlers(Map<String, ChannelUpdateHandler> handlers) {", "author": "fwolter", "createdAt": "2021-03-10T22:57:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNDM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591934370", "bodyText": "You could handle these exceptions in the abstract class, as they seem to be repeated in each handler.", "author": "fwolter", "createdAt": "2021-03-10T22:59:00Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+\n+            // only handle these commands if operation state allows it\n+            if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                // set drying target option\n+                if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                    getApiClient().ifPresent(apiClient -> {\n+                        try {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        } catch (ApplianceOfflineException e) {\n+                            logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                                    command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                            updateStatus(OFFLINE);\n+                            resetChannelsOnOfflineEvent();\n+                            resetProgramStateChannels();\n+                        } catch (CommunicationException e) {\n+                            logger.debug(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+                        } catch (AuthorizationException e) {\n+                            logger.debug(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                            handleAuthenticationError(e);\n+                        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY3OTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624679730", "bodyText": "Very good point. Moved them to the abstract class. Was able to remove a lot of boilerplate code.", "author": "bruestel", "createdAt": "2021-05-02T11:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNDM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591935053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                                QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n          \n          \n            \n                                QuantityType<?> quantity = (QuantityType<?>) command;", "author": "fwolter", "createdAt": "2021-03-10T23:00:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzODAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591938032", "bodyText": "If the unit is Fahrenheit, it needs to be converted to celsius by calling quantity.toUnit(CELSIUS). Keep in mind that toUnit() can return null if the unit cannot be converted.\nWhat is the purpose of the else branch? Are there any other units (beside Kelvin) which can be converted to a temperature?", "author": "fwolter", "createdAt": "2021-03-10T23:06:39Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                    String value;\n+                    String unit;\n+\n+                    if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                            || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                        unit = quantity.getUnit().toString();\n+                        value = String.valueOf(quantity.intValue());\n+                    } else {\n+                        logger.debug(\"Converting target setpoint temperature from {}{} to \u00b0C value. thing={}, haId={}\",\n+                                quantity.intValue(), quantity.getUnit().toString(), getThingLabel(), getThingHaId());\n+                        unit = \"\u00b0C\";\n+                        value = String.valueOf(\n+                                quantity.getUnit().getConverterToAny(SIUnits.CELSIUS).convert(quantity).intValue());\n+                        logger.debug(\"{}{}\", value, unit);\n+                    }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzOTMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591939336", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;", "author": "fwolter", "createdAt": "2021-03-10T23:09:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzOTY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591939649", "bodyText": "See above. from()", "author": "fwolter", "createdAt": "2021-03-10T23:09:56Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MDUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591940521", "bodyText": "This seems redundant tothe dishwasher. Can you re-use the code?", "author": "fwolter", "createdAt": "2021-03-10T23:11:52Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.UNDEF);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.UNDEF);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTQyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591941425", "bodyText": "This seems to be used quite often. You could make it a global constant.", "author": "fwolter", "createdAt": "2021-03-10T23:13:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI5MzI0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600293244", "bodyText": "It differs sometimes", "author": "bruestel", "createdAt": "2021-03-24T09:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591941724", "bodyText": "See above", "author": "fwolter", "createdAt": "2021-03-10T23:14:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjExNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591942115", "bodyText": "See above. Make wildcard. Same for below.", "author": "fwolter", "createdAt": "2021-03-10T23:15:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof QuantityType) {\n+                        // set setpoint temperature\n+                        if (CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591942457", "bodyText": "This seems to be redundant to the FridgeFreeze handler.", "author": "fwolter", "createdAt": "2021-03-10T23:15:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof QuantityType) {\n+                        // set setpoint temperature\n+                        if (CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDcxMDg3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624710871", "bodyText": "moved it to abstract class", "author": "bruestel", "createdAt": "2021-05-02T15:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NDg2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591944862", "bodyText": "See above. Logging to error.", "author": "fwolter", "createdAt": "2021-03-10T23:21:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NTE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591945146", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-03-10T23:21:51Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NTM0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591945345", "bodyText": "See above. Handled by the framework.", "author": "fwolter", "createdAt": "2021-03-10T23:22:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);\n+            httpService.unregister(SERVLET_PATH);\n+            httpService.unregister(ASSETS_PATH);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not unregister Home Connect servlet. Failed wth {}\", e.getMessage());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591948207", "bodyText": "You could make this a method to be able to re-use it. Then, you get also rid of the curly brackets at the cases.", "author": "fwolter", "createdAt": "2021-03-10T23:24:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);\n+            httpService.unregister(SERVLET_PATH);\n+            httpService.unregister(ASSETS_PATH);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not unregister Home Connect servlet. Failed wth {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws IOException {\n+        if (request == null || response == null) {\n+            return;\n+        }\n+        response.setContentType(DEFAULT_CONTENT_TYPE);\n+        response.setCharacterEncoding(UTF_8.name());\n+\n+        String path = request.getPathInfo();\n+        if (path == null || path.isEmpty() || path.equals(ROOT_PATH)) {\n+            @Nullable\n+            String code = request.getParameter(PARAM_CODE);\n+            @Nullable\n+            String state = request.getParameter(PARAM_STATE);\n+            if (code != null && state != null && !code.trim().isEmpty() && !state.trim().isEmpty()) {\n+                getBridgeAuthenticationPage(request, response, code, state);\n+            } else {\n+                getBridgesPage(request, response);\n+            }\n+        } else if (pathMatches(path, REQUEST_COUNT_PATH)) {\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (action != null && bridgeId != null && !action.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getApiRequestsPerSecondCsv(response, bridgeId);\n+            } else {\n+                getRequestCountPage(request, response);\n+            }\n+        } else if (pathMatches(path, APPLIANCES_PATH)) {\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String thingId = request.getParameter(PARAM_THING_ID);\n+            if (action != null && thingId != null && !action.trim().isEmpty() && !thingId.trim().isEmpty()) {\n+                processApplianceActions(response, action, thingId);\n+            } else {\n+                getAppliancesPage(request, response);\n+            }\n+        } else if (pathMatches(path, REQUEST_LOG_PATH)) {\n+            @Nullable\n+            String export = request.getParameter(PARAM_EXPORT);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (export != null && bridgeId != null && !export.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getRequestLogExport(response, bridgeId);\n+            } else {\n+                getRequestLogPage(request, response);\n+            }\n+        } else if (pathMatches(path, EVENT_LOG_PATH)) {\n+            @Nullable\n+            String export = request.getParameter(PARAM_EXPORT);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (export != null && bridgeId != null && !export.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getEventLogExport(response, bridgeId);\n+            } else {\n+                getEventLogPage(request, response);\n+            }\n+        } else {\n+            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws IOException {\n+        if (request == null || response == null) {\n+            return;\n+        }\n+        response.setContentType(\"text/html; charset=UTF-8\");\n+        response.setCharacterEncoding(\"UTF-8\");\n+\n+        String path = request.getPathInfo();\n+        if (path == null || path.isEmpty() || path.equals(ROOT_PATH)) {\n+            if (request.getParameter(PARAM_ACTION) != null && request.getParameter(PARAM_BRIDGE_ID) != null) {\n+                postBridgesPage(request, response);\n+            } else {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+            }\n+        } else if (pathMatches(path, APPLIANCES_PATH)) {\n+            String requestPayload = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String thingId = request.getParameter(PARAM_THING_ID);\n+            @Nullable\n+            String targetPath = request.getParameter(PARAM_PATH);\n+\n+            if ((ACTION_PUT_RAW.equals(action) || ACTION_GET_RAW.equals(action)) && thingId != null\n+                    && targetPath != null && action != null) {\n+                processRawApplianceActions(response, action, thingId, targetPath, requestPayload);\n+            } else {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+            }\n+        } else {\n+            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+        }\n+    }\n+\n+    /**\n+     * Add Home Connect bridge handler to configuration servlet, to allow user to authenticate against Home Connect API.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public void addBridgeHandler(HomeConnectBridgeHandler bridgeHandler) {\n+        bridgeHandlers.add(bridgeHandler);\n+    }\n+\n+    /**\n+     * Remove Home Connect bridge handler from configuration servlet.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public void removeBridgeHandler(HomeConnectBridgeHandler bridgeHandler) {\n+        bridgeHandlers.remove(bridgeHandler);\n+    }\n+\n+    private void getRequestCountPage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n+        if (bridgeHandlers.isEmpty()) {\n+            getBridgesPage(request, response);\n+        } else {\n+            WebContext context = new WebContext(request, response, request.getServletContext());\n+            context.setVariable(\"bridgeHandlers\", bridgeHandlers);\n+            templateEngine.process(\"requests\", context, response.getWriter());\n+        }\n+    }\n+\n+    private void getApiRequestsPerSecondCsv(HttpServletResponse response, String bridgeId) throws IOException {\n+        Optional<HomeConnectBridgeHandler> bridgeHandler = getBridgeHandler(bridgeId);\n+        if (bridgeHandler.isPresent()) {\n+            response.setContentType(\"text/csv\");\n+            PrintWriter writer = response.getWriter();\n+\n+            writer.println(String.format(\"%s,%s\", \"time\", \"requests\"));\n+            bridgeHandler.get().getApiClient().getLatestApiRequests().forEach(apiRequest -> writer.println(\n+                    String.format(\"%s,%s\", apiRequest.getTime().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME), 1)));\n+        } else {\n+            response.sendError(HttpStatus.BAD_REQUEST_400, \"Unknown bridge\");\n+        }\n+    }\n+\n+    private void getAppliancesPage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n+        WebContext context = new WebContext(request, response, request.getServletContext());\n+        context.setVariable(\"bridgeHandlers\", bridgeHandlers);\n+        templateEngine.process(\"appliances\", context, response.getWriter());\n+    }\n+\n+    private void processApplianceActions(HttpServletResponse response, String action, String thingId)\n+            throws IOException {\n+        Optional<HomeConnectBridgeHandler> bridgeHandler = getBridgeHandlerForThing(thingId);\n+        Optional<AbstractHomeConnectThingHandler> thingHandler = getThingHandler(thingId);\n+\n+        if (bridgeHandler.isPresent() && thingHandler.isPresent()) {\n+            try {\n+                response.setContentType(MediaType.APPLICATION_JSON);\n+                String haId = thingHandler.get().getThingHaId();\n+\n+                switch (action) {\n+                    case ACTION_SHOW_DETAILS: {\n+                        @Nullable\n+                        String actionResponse = bridgeHandler.get().getApiClient().getRaw(haId,\n+                                \"/api/homeappliances/\" + haId);\n+                        response.getWriter().write(actionResponse != null ? actionResponse : \"{}\");", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0ODkyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624648926", "bodyText": "Unfortunately, I don't exactly understand your suggestion. Could you please give me a hand.", "author": "bruestel", "createdAt": "2021-05-02T07:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMTc3MTcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r631771705", "bodyText": "Like so:\n...\n                    case ACTION_ALL_PROGRAMS: {\n                        write(response, bridgeHandler, haId, \"/programs\");\n                        break;\n                    }\n...\n    private void write(HttpServletResponse response, Optional<HomeConnectBridgeHandler> bridgeHandler, String haId,\n            String suffix)\n            throws CommunicationException, AuthorizationException, ApplianceOfflineException, IOException {\n        String actionResponse = bridgeHandler.get().getApiClient().getRaw(haId, \"/api/homeappliances/\" + haId + suffix);\n        response.getWriter().write(actionResponse != null ? actionResponse : EMPTY_RESPONSE);\n    }", "author": "fwolter", "createdAt": "2021-05-13T12:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMTc4OTEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r631789137", "bodyText": "I merge it for now. You could file a follow-up PR.", "author": "fwolter", "createdAt": "2021-05-13T12:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw=="}], "type": "inlineReview"}, {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "url": "https://github.com/openhab/openhab-addons/commit/61c803d47eb79e1579e7962736369b3c0d9dbd99", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-03-08T17:33:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1NDU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619454570", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.\nPlease check all.", "author": "fwolter", "createdAt": "2021-04-23T19:36:10Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1277 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL_SEC = 2;\n+    private static final int OFFLINE_MONITOR_1_DELAY_MIN = 30;\n+    private static final int OFFLINE_MONITOR_2_DELAY_MIN = 4;\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY_MIN = 10;\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL_SEC));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(final Map<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final Map<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (!isThingReadyToHandleCommand()) {\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);", "originalCommit": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzNzUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624637531", "bodyText": "will change it", "author": "bruestel", "createdAt": "2021-05-02T06:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1NDU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1Nzk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619457957", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded.\nThe log message could be removed, as the status update is already logged by the framework and displayed in the UI.", "author": "fwolter", "createdAt": "2021-04-23T19:43:34Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY_SEC = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory,\n+                config);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());", "originalCommit": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzNzcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624637722", "bodyText": "will remove it", "author": "bruestel", "createdAt": "2021-05-02T06:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1Nzk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1ODMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619458318", "bodyText": "See above. Remove log message.", "author": "fwolter", "createdAt": "2021-04-23T19:44:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY_SEC = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory,\n+                config);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY_SEC);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);", "originalCommit": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "url": "https://github.com/openhab/openhab-addons/commit/7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:31Z", "type": "commit"}, {"oid": "21f01062b30ff53fc6e59be90afc9556602eb9b0", "url": "https://github.com/openhab/openhab-addons/commit/21f01062b30ff53fc6e59be90afc9556602eb9b0", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "ba0589cba09faab8de11cba443adda6d175a3d74", "url": "https://github.com/openhab/openhab-addons/commit/ba0589cba09faab8de11cba443adda6d175a3d74", "message": "[homeconnect] Applied review feedback and improved README\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "15ea75b12c9c11bac1803c32ed3c944cddc4f6e0", "url": "https://github.com/openhab/openhab-addons/commit/15ea75b12c9c11bac1803c32ed3c944cddc4f6e0", "message": "[homeconnect] Remove Okhttp dependency\n\nUse the Jetty HTTP client provided by the core framework\nUse JAX-RS SSE for SSE\n\nAlso remove dependency on org.apache.commons.lang.*\n\nFix: cancel any job when disposing thing handler\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "1099fcfd28997a8c6ae2e223a4756d31d3869954", "url": "https://github.com/openhab/openhab-addons/commit/1099fcfd28997a8c6ae2e223a4756d31d3869954", "message": "Consider all review comments except the one relative to bucket4j\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "aa71ba75ee064eaa8ddb78766ef89f03eb45f378", "url": "https://github.com/openhab/openhab-addons/commit/aa71ba75ee064eaa8ddb78766ef89f03eb45f378", "message": "Review comment: way to use bucket4j\n\nIncrease OAUTH_EXPIRE_BUFFER to 30 seconds\n\nSet the variable ignoreEventSourceClosedEvent to true at beginning of\nregisterEventListener\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "7eed8286d12f5010bcc42aa477b391df905d66e2", "url": "https://github.com/openhab/openhab-addons/commit/7eed8286d12f5010bcc42aa477b391df905d66e2", "message": "Add Cache-Control header to SSE request\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "8ec45b27481b628d8bdcea5409d1261a570b1ff8", "url": "https://github.com/openhab/openhab-addons/commit/8ec45b27481b628d8bdcea5409d1261a570b1ff8", "message": "Restore value 10 (seconds) for OAUTH_EXPIRY_BUFFER\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "896168f81c47ba82b07fe68304000593d2ea4dac", "url": "https://github.com/openhab/openhab-addons/commit/896168f81c47ba82b07fe68304000593d2ea4dac", "message": "SSE failure due to NotAuthorizedException: wait 5 seconds\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "ff91273022d4ed57870710cc497dde5b8eeb8e81", "url": "https://github.com/openhab/openhab-addons/commit/ff91273022d4ed57870710cc497dde5b8eeb8e81", "message": "Log something when the binding requests a refresh of the access token\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "c6f0d1726e979f766dbfa7ec4ea79d83c7ea5f5b", "url": "https://github.com/openhab/openhab-addons/commit/c6f0d1726e979f766dbfa7ec4ea79d83c7ea5f5b", "message": "Log when the access token changed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "37cdd410e8d47fdad0656c169e1c55e581c571e5", "url": "https://github.com/openhab/openhab-addons/commit/37cdd410e8d47fdad0656c169e1c55e581c571e5", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "10225c77938c481e38def9f850bff48cf491e4ac", "url": "https://github.com/openhab/openhab-addons/commit/10225c77938c481e38def9f850bff48cf491e4ac", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "f9bda8c8bed3e47613d38c3a0fd191cb3969722b", "url": "https://github.com/openhab/openhab-addons/commit/f9bda8c8bed3e47613d38c3a0fd191cb3969722b", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "0fb5481ca70f94d6add9a04adad11396f8b68fbd", "url": "https://github.com/openhab/openhab-addons/commit/0fb5481ca70f94d6add9a04adad11396f8b68fbd", "message": "Fixed bucket4j bug\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "551429a3597bcf6ca7036b97e90eacc83172a219", "url": "https://github.com/openhab/openhab-addons/commit/551429a3597bcf6ca7036b97e90eacc83172a219", "message": "[homeconnect] Removed Plotly charts\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "e9a4d58f8319873184904d2d549f613b90fbceb2", "url": "https://github.com/openhab/openhab-addons/commit/e9a4d58f8319873184904d2d549f613b90fbceb2", "message": "[homeconnect] Fixed compile warnings\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "e38efe08f75eac1bdd5ac326257456ffdb11043b", "url": "https://github.com/openhab/openhab-addons/commit/e38efe08f75eac1bdd5ac326257456ffdb11043b", "message": "[homeconnect] Revered gson changes\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "3de2f9d0e6706e9e436d355c781f6e046f3f0576", "url": "https://github.com/openhab/openhab-addons/commit/3de2f9d0e6706e9e436d355c781f6e046f3f0576", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "d451257d6baa89a89d41871deaeda021caf9a018", "url": "https://github.com/openhab/openhab-addons/commit/d451257d6baa89a89d41871deaeda021caf9a018", "message": "[homeconnect] Refactored and optimized general and light related command handling\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "a3a31018244d13b5390d13f13ff3f2cb77f722e3", "url": "https://github.com/openhab/openhab-addons/commit/a3a31018244d13b5390d13f13ff3f2cb77f722e3", "message": "[homeconnect] Moved temperature command handling to abstract class and use channel type 'system.power' instead of custom type\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "1364ae8bcdef364f4b2f6193b87d48f62428eae0", "url": "https://github.com/openhab/openhab-addons/commit/1364ae8bcdef364f4b2f6193b87d48f62428eae0", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:35Z", "type": "commit"}, {"oid": "1364ae8bcdef364f4b2f6193b87d48f62428eae0", "url": "https://github.com/openhab/openhab-addons/commit/1364ae8bcdef364f4b2f6193b87d48f62428eae0", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTY3NDk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r625674960", "bodyText": "You already have the apiClient as parameter.", "author": "lolodomo", "createdAt": "2021-05-04T10:33:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -157,51 +157,55 @@ private void reinitialize() {\n         initialize();\n     }\n \n+    protected void handleCommand(ChannelUID channelUID, Command command, HomeConnectApiClient apiClient)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();", "originalCommit": "3de2f9d0e6706e9e436d355c781f6e046f3f0576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTc0MTQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r625741419", "bodyText": "PR created", "author": "lolodomo", "createdAt": "2021-05-04T12:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTY3NDk2MA=="}], "type": "inlineReview"}, {"oid": "86d863e36a92d405a8081f9fa00d57e900537373", "url": "https://github.com/openhab/openhab-addons/commit/86d863e36a92d405a8081f9fa00d57e900537373", "message": "Fix for handleCommand\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-04T12:27:08Z", "type": "commit"}, {"oid": "55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec", "url": "https://github.com/openhab/openhab-addons/commit/55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec", "message": "Merge pull request #3 from lolodomo/homeconnect\n\nFix for handleCommand", "committedDate": "2021-05-04T14:44:14Z", "type": "commit"}, {"oid": "36c008fc19d232e795b09454da99de14c8ad1421", "url": "https://github.com/openhab/openhab-addons/commit/36c008fc19d232e795b09454da99de14c8ad1421", "message": "[homeconnect] Fixed warnings\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-04T15:03:33Z", "type": "commit"}, {"oid": "97eeb29e929257c5154ff19e0c810a3fff519c4a", "url": "https://github.com/openhab/openhab-addons/commit/97eeb29e929257c5154ff19e0c810a3fff519c4a", "message": "[homeconnect] Workaround event listener bug\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-06T09:55:24Z", "type": "commit"}]}