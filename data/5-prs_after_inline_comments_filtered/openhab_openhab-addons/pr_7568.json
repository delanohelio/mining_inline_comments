{"pr_number": 7568, "pr_title": "[kaleidescape] Kaleidescape Movie Player Binding - initial contribution", "pr_createdAt": "2020-05-07T20:46:29Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7568", "timeline": [{"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-13T19:56:53Z", "type": "commit"}, {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-19T18:41:08Z", "type": "commit"}, {"oid": "0f0e2bade7dc06284758cdcc26ff36899ba02488", "url": "https://github.com/openhab/openhab-addons/commit/0f0e2bade7dc06284758cdcc26ff36899ba02488", "message": "Kaleidescape Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-07T20:40:03Z", "type": "commit"}, {"oid": "36dfe97a267794bb17cc03d73451c44bbe5aa740", "url": "https://github.com/openhab/openhab-addons/commit/36dfe97a267794bb17cc03d73451c44bbe5aa740", "message": "Cleanup before review\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T16:29:21Z", "type": "commit"}, {"oid": "7f6e1ecaf31194fa0f9a606de2259413b00f06fc", "url": "https://github.com/openhab/openhab-addons/commit/7f6e1ecaf31194fa0f9a606de2259413b00f06fc", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-23T04:52:22Z", "type": "commit"}, {"oid": "1184774907b31ec792aec1cacb475591849843df", "url": "https://github.com/openhab/openhab-addons/commit/1184774907b31ec792aec1cacb475591849843df", "message": "Start removing org.apache.commons.lang dependencies\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-26T05:36:03Z", "type": "commit"}, {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-05-27T03:57:29Z", "type": "commit"}, {"oid": "ecf44b9b4239b0cfcb2d8beb429ebaedc4976f21", "url": "https://github.com/openhab/openhab-addons/commit/ecf44b9b4239b0cfcb2d8beb429ebaedc4976f21", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-05-27T05:07:21Z", "type": "commit"}, {"oid": "3df77150d61f52d701d86c1ae0e64121eb28b4b2", "url": "https://github.com/openhab/openhab-addons/commit/3df77150d61f52d701d86c1ae0e64121eb28b4b2", "message": "pmd and spotless cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T05:37:05Z", "type": "commit"}, {"oid": "89fedefae83bb3f1c6eaf8318856ab441d1394b4", "url": "https://github.com/openhab/openhab-addons/commit/89fedefae83bb3f1c6eaf8318856ab441d1394b4", "message": "Http client and Label cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T22:02:04Z", "type": "commit"}, {"oid": "9fbfa46a9ba5526e6593e20c0760c995354c7550", "url": "https://github.com/openhab/openhab-addons/commit/9fbfa46a9ba5526e6593e20c0760c995354c7550", "message": "pre-review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T05:16:01Z", "type": "commit"}, {"oid": "76d5c5b8f14d888e4f4ca7a6146e9d881af2449b", "url": "https://github.com/openhab/openhab-addons/commit/76d5c5b8f14d888e4f4ca7a6146e9d881af2449b", "message": "Add ThingAction\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T16:00:57Z", "type": "commit"}, {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-04T21:19:29Z", "type": "commit"}, {"oid": "7be08b18a617477f50757943e0355ca9c29ad30e", "url": "https://github.com/openhab/openhab-addons/commit/7be08b18a617477f50757943e0355ca9c29ad30e", "message": "implement review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-10T22:19:48Z", "type": "commit"}, {"oid": "781abb069dfa38e0551313800def39717b1a0a28", "url": "https://github.com/openhab/openhab-addons/commit/781abb069dfa38e0551313800def39717b1a0a28", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-15T04:29:20Z", "type": "commit"}, {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-24T13:47:17Z", "type": "commit"}, {"oid": "90b374d59aa8c4ac1207694e0349bb8096008440", "url": "https://github.com/openhab/openhab-addons/commit/90b374d59aa8c4ac1207694e0349bb8096008440", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-06-24T14:39:20Z", "type": "commit"}, {"oid": "5e9bb0c62ecbd339f2673025318166a4d05a8981", "url": "https://github.com/openhab/openhab-addons/commit/5e9bb0c62ecbd339f2673025318166a4d05a8981", "message": "review changes from other pr\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-24T20:26:52Z", "type": "commit"}, {"oid": "8d231205b20fcfeb22ee493bd1f0a5ea205f4ae5", "url": "https://github.com/openhab/openhab-addons/commit/8d231205b20fcfeb22ee493bd1f0a5ea205f4ae5", "message": "improvements and review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-25T21:31:10Z", "type": "commit"}, {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "url": "https://github.com/openhab/openhab-addons/commit/6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "message": "remove InterruptedIOException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-26T21:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMTY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449911694", "bodyText": "It's good practice to append the unit to the field name e.g. DISCOVERY_DEFAULT_TIMEOUT_RATE_MS", "author": "fwolter", "createdAt": "2020-07-05T19:42:43Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/KaleidescapeBindingConstants.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link KaleidescapeBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeBindingConstants {\n+    public static final String BINDING_ID = \"kaleidescape\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_PLAYER_ZONE = new ThingTypeUID(BINDING_ID, \"player\");\n+\n+    public static final int DEFAULT_API_PORT = 10000;\n+    public static final short DISCOVERY_SUBNET_MASK = 24;\n+    public static final int DISCOVERY_THREAD_POOL_SIZE = 15;\n+    public static final boolean DISCOVERY_DEFAULT_AUTO_DISCOVER = false;\n+    public static final int DISCOVERY_DEFAULT_TIMEOUT_RATE = 500;\n+    public static final int DISCOVERY_DEFAULT_IP_TIMEOUT_RATE = 750;", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMjU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449912546", "bodyText": "Are you aware of this bug openhab/openhab-core#1265?\nIf you want, you can add a workaround like this:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "author": "fwolter", "createdAt": "2020-07-05T19:52:11Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/KaleidescapeThingActions.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.kaleidescape.internal.handler.KaleidescapeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Some automation actions to be used with a {@link KaleidescapeThingActions}\n+ *\n+ * @author Michael Lobstein - initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"kaleidescape\")\n+@NonNullByDefault\n+public class KaleidescapeThingActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeThingActions.class);\n+\n+    private @Nullable KaleidescapeHandler handler;\n+\n+    @SuppressWarnings(\"null\")\n+    @RuleAction(label = \"sendKCommand\", description = \"Action that sends raw command to the kaleidescape zone\")\n+    public void sendKCommand(@ActionInput(name = \"sendKCommand\") @Nullable String kCommand) {\n+        if (handler != null && kCommand != null) {\n+            handler.handleRawCommand(kCommand);\n+            logger.debug(\"sendKCommand called with command: {}\", kCommand);\n+        } else {\n+            logger.debug(\"sendKCommand called with null command, ignoring\");\n+        }\n+    }\n+\n+    public static void sendKCommand(@Nullable ThingActions actions, @Nullable String kCommand)", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2MjIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450562229", "bodyText": "I did experience this bug during development. The workaround looks quite involved however.", "author": "mlobstein", "createdAt": "2020-07-07T01:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMjcwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449912703", "bodyText": "Is this necessary?", "author": "fwolter", "createdAt": "2020-07-05T19:54:03Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/KaleidescapeThingActions.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.kaleidescape.internal.handler.KaleidescapeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Some automation actions to be used with a {@link KaleidescapeThingActions}\n+ *\n+ * @author Michael Lobstein - initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"kaleidescape\")\n+@NonNullByDefault\n+public class KaleidescapeThingActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeThingActions.class);\n+\n+    private @Nullable KaleidescapeHandler handler;\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2MjQxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450562416", "bodyText": "Fixed with local variable.", "author": "mlobstein", "createdAt": "2020-07-07T01:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMjcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzAwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449913000", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // I.e. characters with accent, umulat, etc., they need to be restored to the correct character\n          \n          \n            \n                        // I.e. characters with accent, umlaut, etc., they need to be restored to the correct character", "author": "fwolter", "createdAt": "2020-07-05T19:57:12Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeFormatter.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link KaleidescapeFormatter} is a utility class with formatting methods for Kaleidescape strings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeFormatter {\n+    public static String formatString(String input) {\n+        if (!input.equals(\"\")) {\n+            // convert || back to :\n+            input = input.replace(\"||\", \":\");\n+\n+            // fix escaped :\n+            input = input.replace(\"\\\\:\", \":\");\n+\n+            // fix escaped /\n+            input = input.replace(\"\\\\/\", \"/\");\n+\n+            // convert \\r into comma space\n+            input = input.replace(\"\\\\r\", \", \");\n+\n+            // convert \\d146 from review text into apostrophe\n+            input = input.replace(\"\\\\d146\", \"'\");\n+            // convert \\d147 & \\d148 from review text into double quote\n+            input = input.replace(\"\\\\d147\", \"\\\"\");\n+            input = input.replace(\"\\\\d148\", \"\\\"\");\n+\n+            // fix the encoding for k mangled extended ascii characters (chars coming in as \\dnnn)\n+            // I.e. characters with accent, umulat, etc., they need to be restored to the correct character", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449913349", "bodyText": "Can you add Apache Commons as a dependency to the pom.xml?", "author": "fwolter", "createdAt": "2020-07-05T20:01:33Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeFormatter.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link KaleidescapeFormatter} is a utility class with formatting methods for Kaleidescape strings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeFormatter {\n+    public static String formatString(String input) {\n+        if (!input.equals(\"\")) {\n+            // convert || back to :\n+            input = input.replace(\"||\", \":\");\n+\n+            // fix escaped :\n+            input = input.replace(\"\\\\:\", \":\");\n+\n+            // fix escaped /\n+            input = input.replace(\"\\\\/\", \"/\");\n+\n+            // convert \\r into comma space\n+            input = input.replace(\"\\\\r\", \", \");\n+\n+            // convert \\d146 from review text into apostrophe\n+            input = input.replace(\"\\\\d146\", \"'\");\n+            // convert \\d147 & \\d148 from review text into double quote\n+            input = input.replace(\"\\\\d147\", \"\\\"\");\n+            input = input.replace(\"\\\\d148\", \"\\\"\");\n+\n+            // fix the encoding for k mangled extended ascii characters (chars coming in as \\dnnn)\n+            // I.e. characters with accent, umulat, etc., they need to be restored to the correct character\n+            // example: Noel (with umulat 'o') comes in as N\\d246el\n+            input = input.replaceAll(\"(?i)\\\\\\\\d([0-9]{3})\", \"\\\\&#$1;\"); // first convert to html escaped codes\n+            // then convert with unescapeHtml, not sure how to do this without the Apache libraries :(\n+            return StringEscapeUtils.unescapeHtml(input);", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2MzE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450563153", "bodyText": "I saw some PRs for other bindings a few weeks ago that were removing Apache Commons... Can it still be used if specified as a dependency in this manner?", "author": "mlobstein", "createdAt": "2020-07-07T01:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0ODkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450848912", "bodyText": "Yes, it can.", "author": "fwolter", "createdAt": "2020-07-07T13:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI3ODQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487278485", "bodyText": "Technical you still can use it of course. However if everyone still keeps using it that kind of undermines the idea the libraries are removed. The idea is that we probably  will provide alternatives for the methods that can not be replaced by other means. For example with moving to java 11 there will already be some replacements available. For now if there is no alternative in either jre or other provided libraries just leave it in. No need to add the depencies.", "author": "Hilbrand", "createdAt": "2020-09-11T20:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMDExMg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487310112", "bodyText": "Ok, I will leave off the dependencies from the pom.xml and revisit to see what OH3 provides.\n@cpmeister", "author": "mlobstein", "createdAt": "2020-09-11T22:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449914155", "bodyText": "Do you expect something else than a UnknownHostException? Can you specify it explicitly?", "author": "fwolter", "createdAt": "2020-07-05T20:10:44Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryJob.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryJob} class allow manual discovery of\n+ * Kaleidescape components for a single IP address. This is used\n+ * for threading to make discovery faster.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+public class KaleidescapeDiscoveryJob implements Runnable {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryJob.class);\n+\n+    private KaleidescapeDiscoveryService discoveryClass;\n+\n+    private String ipAddress = EMPTY;\n+    private String componentType = EMPTY;\n+    private String friendlyName = EMPTY;\n+    private String serialNumber = EMPTY;\n+\n+    public KaleidescapeDiscoveryJob(KaleidescapeDiscoveryService service, String ip) {\n+        this.discoveryClass = service;\n+        this.ipAddress = ip;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (hasKaleidescapeDevice(this.ipAddress)) {\n+            discoveryClass.submitDiscoveryResults(this.ipAddress, this.componentType, this.friendlyName,\n+                    this.serialNumber);\n+        }\n+    }\n+\n+    /**\n+     * Determines if a Kaleidescape component with a movie player zone is available at a given IP address.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @return True if a component is found, false if not.\n+     */\n+    private boolean hasKaleidescapeDevice(String ip) {\n+        try {\n+            InetAddress address = InetAddress.getByName(ip);\n+\n+            if (isKaleidescapeDevice(address, DEFAULT_API_PORT)) {\n+                return true;\n+            } else {\n+                logger.debug(\"No Kaleidescape component found at IP address ({})\", ip);\n+                return false;\n+            }\n+        } catch (Exception exp) {", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2NDMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450564339", "bodyText": "No it was a bad example. Fixed.", "author": "mlobstein", "createdAt": "2020-07-07T01:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDk4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449914980", "bodyText": "Better do not rely on the validity of the incoming data, but check the length of the array before accessing it.", "author": "fwolter", "createdAt": "2020-07-05T20:20:07Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryJob.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryJob} class allow manual discovery of\n+ * Kaleidescape components for a single IP address. This is used\n+ * for threading to make discovery faster.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+public class KaleidescapeDiscoveryJob implements Runnable {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryJob.class);\n+\n+    private KaleidescapeDiscoveryService discoveryClass;\n+\n+    private String ipAddress = EMPTY;\n+    private String componentType = EMPTY;\n+    private String friendlyName = EMPTY;\n+    private String serialNumber = EMPTY;\n+\n+    public KaleidescapeDiscoveryJob(KaleidescapeDiscoveryService service, String ip) {\n+        this.discoveryClass = service;\n+        this.ipAddress = ip;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (hasKaleidescapeDevice(this.ipAddress)) {\n+            discoveryClass.submitDiscoveryResults(this.ipAddress, this.componentType, this.friendlyName,\n+                    this.serialNumber);\n+        }\n+    }\n+\n+    /**\n+     * Determines if a Kaleidescape component with a movie player zone is available at a given IP address.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @return True if a component is found, false if not.\n+     */\n+    private boolean hasKaleidescapeDevice(String ip) {\n+        try {\n+            InetAddress address = InetAddress.getByName(ip);\n+\n+            if (isKaleidescapeDevice(address, DEFAULT_API_PORT)) {\n+                return true;\n+            } else {\n+                logger.debug(\"No Kaleidescape component found at IP address ({})\", ip);\n+                return false;\n+            }\n+        } catch (Exception exp) {\n+            logger.debug(\"No Kaleidescape component found at IP address ({}) because of error: {}\", ip,\n+                    exp.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to establish a connection to a hostname and port and then interrogate the component\n+     *\n+     * @param host Hostname or IP address to connect to.\n+     * @param port Port to attempt to connect to.\n+     * @return True if the component found is one the binding supports\n+     */\n+    private boolean isKaleidescapeDevice(InetAddress host, int port) {\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(host, port), DISCOVERY_DEFAULT_IP_TIMEOUT_RATE);\n+\n+            OutputStream output = socket.getOutputStream();\n+            PrintWriter writer = new PrintWriter(output, true);\n+\n+            // query the component to see if it has video zones, the device type, friendly name, and serial number\n+            writer.println(\"01/1/GET_NUM_ZONES:\");\n+            writer.println(\"01/1/GET_DEVICE_TYPE_NAME:\");\n+            writer.println(\"01/1/GET_FRIENDLY_NAME:\");\n+            writer.println(\"01/1/GET_DEVICE_INFO:\");\n+\n+            InputStream input = socket.getInputStream();\n+\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n+\n+            String line;\n+            String videoZone = null;\n+            String audioZone = null;\n+            int lineCount = 0;\n+\n+            while ((line = reader.readLine()) != null) {\n+                String[] strArr = line.split(\":\");\n+\n+                switch (strArr[1]) {", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450584792", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-07-07T02:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTE2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449915166", "bodyText": "Actually these are not needed, since the try block closes the socket automatically and closing the socket, will close all I/O streams, which close the reader. See https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#close()", "author": "fwolter", "createdAt": "2020-07-05T20:22:40Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryJob.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryJob} class allow manual discovery of\n+ * Kaleidescape components for a single IP address. This is used\n+ * for threading to make discovery faster.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+public class KaleidescapeDiscoveryJob implements Runnable {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryJob.class);\n+\n+    private KaleidescapeDiscoveryService discoveryClass;\n+\n+    private String ipAddress = EMPTY;\n+    private String componentType = EMPTY;\n+    private String friendlyName = EMPTY;\n+    private String serialNumber = EMPTY;\n+\n+    public KaleidescapeDiscoveryJob(KaleidescapeDiscoveryService service, String ip) {\n+        this.discoveryClass = service;\n+        this.ipAddress = ip;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (hasKaleidescapeDevice(this.ipAddress)) {\n+            discoveryClass.submitDiscoveryResults(this.ipAddress, this.componentType, this.friendlyName,\n+                    this.serialNumber);\n+        }\n+    }\n+\n+    /**\n+     * Determines if a Kaleidescape component with a movie player zone is available at a given IP address.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @return True if a component is found, false if not.\n+     */\n+    private boolean hasKaleidescapeDevice(String ip) {\n+        try {\n+            InetAddress address = InetAddress.getByName(ip);\n+\n+            if (isKaleidescapeDevice(address, DEFAULT_API_PORT)) {\n+                return true;\n+            } else {\n+                logger.debug(\"No Kaleidescape component found at IP address ({})\", ip);\n+                return false;\n+            }\n+        } catch (Exception exp) {\n+            logger.debug(\"No Kaleidescape component found at IP address ({}) because of error: {}\", ip,\n+                    exp.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to establish a connection to a hostname and port and then interrogate the component\n+     *\n+     * @param host Hostname or IP address to connect to.\n+     * @param port Port to attempt to connect to.\n+     * @return True if the component found is one the binding supports\n+     */\n+    private boolean isKaleidescapeDevice(InetAddress host, int port) {\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(host, port), DISCOVERY_DEFAULT_IP_TIMEOUT_RATE);\n+\n+            OutputStream output = socket.getOutputStream();\n+            PrintWriter writer = new PrintWriter(output, true);\n+\n+            // query the component to see if it has video zones, the device type, friendly name, and serial number\n+            writer.println(\"01/1/GET_NUM_ZONES:\");\n+            writer.println(\"01/1/GET_DEVICE_TYPE_NAME:\");\n+            writer.println(\"01/1/GET_FRIENDLY_NAME:\");\n+            writer.println(\"01/1/GET_DEVICE_INFO:\");\n+\n+            InputStream input = socket.getInputStream();\n+\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n+\n+            String line;\n+            String videoZone = null;\n+            String audioZone = null;\n+            int lineCount = 0;\n+\n+            while ((line = reader.readLine()) != null) {\n+                String[] strArr = line.split(\":\");\n+\n+                switch (strArr[1]) {\n+                    case \"NUM_ZONES\":\n+                        videoZone = strArr[2];\n+                        audioZone = strArr[3];\n+                        break;\n+                    case \"DEVICE_TYPE_NAME\":\n+                        componentType = strArr[2];\n+                        break;\n+                    case \"FRIENDLY_NAME\":\n+                        friendlyName = strArr[2];\n+                        break;\n+                    case \"DEVICE_INFO\":\n+                        serialNumber = strArr[3].trim(); // take off leading zeros\n+                        break;\n+                }\n+\n+                lineCount++;\n+\n+                // stop after reading four lines\n+                if (lineCount > 3) {\n+                    break;\n+                }\n+            }\n+\n+            reader.close();\n+            input.close();\n+            output.close();\n+            socket.close();", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2NDY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450564669", "bodyText": "nice!", "author": "mlobstein", "createdAt": "2020-07-07T01:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449915889", "bodyText": "It's a bit hard to scan the whole subnet and spawn 15 threads for DNS resolution, but I don't have any better idea. Did you test this on a computer with low resources like a raspi?", "author": "fwolter", "createdAt": "2020-07-05T20:32:34Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2Nzc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450567789", "bodyText": "Yes it worked fine there. I was concerned after seeing that the Apache libraries were being phased out from other bindings.", "author": "mlobstein", "createdAt": "2020-07-07T01:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTk2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449915968", "bodyText": "Can you add a representation property like \"host\"?", "author": "fwolter", "createdAt": "2020-07-05T20:33:47Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);\n+\n+            for (String ip : ipList) {\n+                discoverySearchPool.execute(new KaleidescapeDiscoveryJob(this, ip));\n+            }\n+\n+            discoverySearchPool.shutdown();\n+        } catch (Exception exp) {\n+            logger.debug(\"Kaleidescape discovery service encountered an error while scanning for components: {}\",\n+                    exp.getMessage());\n+        }\n+\n+        logger.debug(\"Completed discovery of Kaleidescape components.\");\n+    }\n+\n+    /**\n+     * Create a new Thing with an IP address and Component type given. Uses default port.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @param componentType Type of Kaleidescape component as a string.\n+     * @param friendlyName Name of Kaleidescape component as a string.\n+     * @param serialNumber Serial Number of Kaleidescape component as a string.\n+     */\n+    public void submitDiscoveryResults(String ip, String componentType, String friendlyName, String serialNumber) {\n+        ThingUID uid = new ThingUID(THING_TYPE_PLAYER_ZONE, serialNumber);\n+\n+        HashMap<String, Object> properties = new HashMap<>();\n+\n+        properties.put(\"host\", ip);\n+        properties.put(\"port\", DEFAULT_API_PORT);\n+        properties.put(\"componentType\", componentType);\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(uid).withProperties(properties)\n+                .withLabel(componentType + \" (\" + friendlyName + \")\").build());", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916014", "bodyText": "You might want to log that the ipv6 interface is ignored during discovery.", "author": "fwolter", "createdAt": "2020-07-05T20:34:28Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);\n+\n+            for (String ip : ipList) {\n+                discoverySearchPool.execute(new KaleidescapeDiscoveryJob(this, ip));\n+            }\n+\n+            discoverySearchPool.shutdown();\n+        } catch (Exception exp) {\n+            logger.debug(\"Kaleidescape discovery service encountered an error while scanning for components: {}\",\n+                    exp.getMessage());\n+        }\n+\n+        logger.debug(\"Completed discovery of Kaleidescape components.\");\n+    }\n+\n+    /**\n+     * Create a new Thing with an IP address and Component type given. Uses default port.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @param componentType Type of Kaleidescape component as a string.\n+     * @param friendlyName Name of Kaleidescape component as a string.\n+     * @param serialNumber Serial Number of Kaleidescape component as a string.\n+     */\n+    public void submitDiscoveryResults(String ip, String componentType, String friendlyName, String serialNumber) {\n+        ThingUID uid = new ThingUID(THING_TYPE_PLAYER_ZONE, serialNumber);\n+\n+        HashMap<String, Object> properties = new HashMap<>();\n+\n+        properties.put(\"host\", ip);\n+        properties.put(\"port\", DEFAULT_API_PORT);\n+        properties.put(\"componentType\", componentType);\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(uid).withProperties(properties)\n+                .withLabel(componentType + \" (\" + friendlyName + \")\").build());\n+    }\n+\n+    /**\n+     * Provide a string list of all the IP addresses associated with the network interfaces on\n+     * this machine.\n+     *\n+     * @return String list of IP addresses.\n+     * @throws UnknownHostException\n+     * @throws SocketException\n+     */\n+    private List<String> getIpAddressScanList() throws UnknownHostException, SocketException {\n+        List<String> results = new ArrayList<>();\n+\n+        InetAddress localHost = InetAddress.getLocalHost();\n+        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(localHost);\n+\n+        for (InterfaceAddress address : networkInterface.getInterfaceAddresses()) {\n+            InetAddress ipAddress = address.getAddress();\n+\n+            String cidrSubnet = ipAddress.getHostAddress() + \"/\" + DISCOVERY_SUBNET_MASK;\n+\n+            /* Apache Subnet Utils only supports IP v4 for creating string list of IP's */\n+            if (ipAddress instanceof Inet4Address) {\n+                logger.debug(\"Found interface IPv4 address to scan: {}\", cidrSubnet);\n+\n+                SubnetUtils utils = new SubnetUtils(cidrSubnet);\n+\n+                results.addAll(Arrays.asList(utils.getInfo().getAllAddresses())); // not sure how to do this without the\n+                                                                                  // Apache libraries\n+            } else if (ipAddress instanceof Inet6Address) {\n+                logger.debug(\"Found interface IPv6 address to scan: {}\", cidrSubnet);", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2OTQyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450569426", "bodyText": "good idea, these will likely never support IPv6", "author": "mlobstein", "createdAt": "2020-07-07T01:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjAzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916036", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-07-05T20:34:51Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916218", "bodyText": "You could store the config to a local variable (additionally) to eliminate the null supression.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n          \n          \n            \n                    KaleidescapeThingConfiguration localConfig = config = getConfigAs(KaleidescapeThingConfiguration.class);", "author": "fwolter", "createdAt": "2020-07-05T20:36:46Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2OTYzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450569635", "bodyText": "got it.", "author": "mlobstein", "createdAt": "2020-07-07T01:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjMzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916334", "bodyText": "The compiler is more intelligent on local variables, so this could be removed.", "author": "fwolter", "createdAt": "2020-07-05T20:38:28Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n          \n          \n            \n                        this.updateState(VOLUME, new PercentType(this.volume));", "author": "fwolter", "createdAt": "2020-07-05T20:39:39Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjYyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916623", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently).\nThis should be invoked after scheduling the jobs. Otherwise the jobs could be scheduled after dispose() is invoked.", "author": "fwolter", "createdAt": "2020-07-05T20:41:46Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU3MDQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450570457", "bodyText": "moved", "author": "mlobstein", "createdAt": "2020-07-07T02:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzA5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917094", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n          \n          \n            \n                                                    GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n          \n          \n            \n                                            initialCommands.addAll(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n          \n          \n            \n                                                    GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE));", "author": "fwolter", "createdAt": "2020-07-05T20:46:47Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917466", "bodyText": "If I understand correctly, you expect the connection as failed, if one poll failed. Is it reasonable to be a bit more tolerant, like when two consecutive poll requests fail?", "author": "fwolter", "createdAt": "2020-07-05T20:51:04Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU3MTgwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450571807", "bodyText": "The device is very responsive and the polling just asks it to return the current time (as recommended by the control protocol specs). So I think this will be OK.", "author": "mlobstein", "createdAt": "2020-07-07T02:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzUzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917539", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateState(channel, new PercentType(BigDecimal.valueOf(this.volume)));\n          \n          \n            \n                            updateState(channel, new PercentType(this.volume));", "author": "fwolter", "createdAt": "2020-07-05T20:51:48Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL * 1.25 * 1000)) {\n+                        logger.warn(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, POLLING_INTERVAL, POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    private void handleControlCommand(Command command) throws KaleidescapeException {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connector.sendCommand(PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connector.sendCommand(PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connector.sendCommand(NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connector.sendCommand(PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                connector.sendCommand(SCAN_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                connector.sendCommand(SCAN_REVERSE);\n+            }\n+        } else {\n+            logger.warn(\"Unknown control command: {}\", command);\n+        }\n+    }\n+\n+    private void handleRefresh(String channel) throws KaleidescapeException {\n+        switch (channel) {\n+            case POWER:\n+                connector.sendCommand(GET_DEVICE_POWER_STATE);\n+                break;\n+            case VOLUME:\n+                updateState(channel, new PercentType(BigDecimal.valueOf(this.volume)));", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917967", "bodyText": "OpenHAB's scheduler thread could be blocked by this timeout. You could use Jetty's async API or decrease the timeout to e.g. 10sec.", "author": "fwolter", "createdAt": "2020-07-05T20:56:56Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeMessageHandler.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeFormatter;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeStatusCodes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeMessageHandler} class processes all messages received\n+ * by the event listener and then updates the appropriate states\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum KaleidescapeMessageHandler {\n+    UI_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.UI_STATE, new StringType(message));\n+        }\n+    },\n+    HIGHLIGHTED_SELECTION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.HIGHLIGHTED_SELECTION, new StringType(message));\n+        }\n+    },\n+    DEVICE_POWER_STATE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 1:1\n+        // power_state, zone 1 state, zone n state\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(POWER, (ONE).equals(matcher.group(1)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"DEVICE_POWER_STATE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    TITLE_NAME {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.TITLE_NAME,\n+                    new StringType(KaleidescapeFormatter.formatString(message)));\n+        }\n+    },\n+    PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 0:0:00:00000:00000:000:00000:00000\n+        // mode, speed, title_num, title_length, title_loc, chapter_num, chapter_length, chapter_loc\n+        private final Pattern p = Pattern\n+                .compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{2}):(\\\\d{5}):(\\\\d{5}):(\\\\d{3}):(\\\\d{5}):(\\\\d{5})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(TITLE_NUM, new DecimalType(Integer.parseInt(matcher.group(3))));\n+\n+                handler.updateChannel(TITLE_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(TITLE_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(5)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_NUM, new DecimalType(Integer.parseInt(matcher.group(6))));\n+\n+                handler.updateChannel(CHAPTER_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(7)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(8)), handler.apiSecondUnit));\n+            } else {\n+                logger.debug(\"PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MOVIE_MEDIA_TYPE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_MEDIA_TYPE,\n+                    new StringType(KaleidescapeStatusCodes.MEDIA_TYPE.get(message)));\n+        }\n+    },\n+    MOVIE_LOCATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_LOCATION,\n+                    new StringType(KaleidescapeStatusCodes.MOVIE_LOCATION.get(message)));\n+        }\n+    },\n+    VIDEO_MODE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00:00:00\n+        // composite, component, hdmi\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_MODE, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_MODE_COMPOSITE,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(VIDEO_MODE_COMPONENT,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(2))));\n+\n+                handler.updateChannel(VIDEO_MODE_HDMI,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(3))));\n+            } else {\n+                logger.debug(\"VIDEO_MODE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    VIDEO_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"VIDEO_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    CONTENT_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CONTENT_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(CONTENT_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"CONTENT_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    SCALE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCALE_MODE, new StringType(message));\n+        }\n+    },\n+    SCREEN_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK, new StringType(message));\n+\n+            // per API reference rev 3.3.1, ASPECT_RATIO message should not be used\n+            // the first element of SCREEN_MASK now provides this info\n+            if (!message.equals(EMPTY)) {\n+                String[] msgSplit = message.split(\":\", 2);\n+                handler.updateChannel(KaleidescapeBindingConstants.ASPECT_RATIO,\n+                        new StringType(KaleidescapeStatusCodes.ASPECT_RATIO.get(msgSplit[0])));\n+            }\n+        }\n+    },\n+    SCREEN_MASK2 {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK2, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MASK, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MODE, new StringType(message));\n+        }\n+    },\n+    CHILD_MODE_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CHILD_MODE_STATE, new StringType(message));\n+        }\n+    },\n+    MUSIC_TITLE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: You:Radiohead:Pablo Honey:1.9b5f4d786d7e2c49-t301_577:1.R_1493833:2.200c5\n+        // track, artist, album, track handle, album handle, now playing handle\n+        private final Pattern p = Pattern.compile(\"^(.*):(.*):(.*):(.*):(.*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // first replace delimited : in track/artist/album name with ||, fix it later in formatString()\n+            Matcher matcher = p.matcher(message.replace(\"\\\\:\", \"||\"));\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_TRACK,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_ARTIST,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(2))));\n+\n+                handler.updateChannel(MUSIC_ALBUM,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(3))));\n+\n+                handler.updateChannel(MUSIC_TRACK_HANDLE, new StringType(matcher.group(4)));\n+\n+                handler.updateChannel(MUSIC_ALBUM_HANDLE, new StringType(matcher.group(5)));\n+\n+                handler.updateChannel(MUSIC_NOWPLAY_HANDLE, new StringType(matcher.group(6)));\n+            } else {\n+                logger.debug(\"MUSIC_TITLE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 2:0:00207:+00000:000.00\n+        // 2:0:00331:+00183:055.29\n+        // mode, speed, track length, track position, track progress %\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{5}):(.\\\\d{5}):(\\\\d{3}\\\\.\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(MUSIC_TRACK_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(3)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_POSITION,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_PROGRESS,\n+                        new DecimalType(BigDecimal.valueOf(Math.round(Double.parseDouble(matcher.group(5))))));\n+            } else {\n+                logger.debug(\"MUSIC_PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_NOW_PLAYING_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00013:00000:0:0:0000000238:2.200c5\n+        // total # tracks in list, list index, repeat, random, generation, now_playing handle\n+        // only using repeat & random right now\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{5}):(\\\\d{5}):(\\\\d{1}):(\\\\d{1}):(\\\\d{10}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                // update REPEAT switch state\n+                handler.updateChannel(MUSIC_REPEAT, (ONE).equals(matcher.group(3)) ? OnOffType.ON : OnOffType.OFF);\n+\n+                // update RANDOM switch state\n+                handler.updateChannel(MUSIC_RANDOM, (ONE).equals(matcher.group(4)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"MUSIC_NOW_PLAYING_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    PLAYING_MUSIC_INFORMATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: R_1493833:Radiohead - Pablo Honey\n+            // album handle, artist - album\n+            // do nothing; redundant\n+        }\n+    },\n+    CONTENT_DETAILS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // g1=meta id, g2=meta type, g3=data\n+        // example: 6:Year:1995\n+        // or: 10:Genres:Pop\\/Rock\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1,2}):([^:^/]*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                String metaType = matcher.group(2).toLowerCase();\n+                String value = KaleidescapeFormatter.formatString(matcher.group(3));\n+\n+                // the CONTENT_DETAILS message with id=1 tells us what type of meta data is coming\n+                if (ONE.equals(matcher.group(1))) {\n+                    if ((CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(MOVIE));\n+                        handler.metaRuntimeMultiple = 60;\n+\n+                        // null out album specific\n+                        handler.updateDetailChannel(DETAIL_ALBUM_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ARTIST, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_REVIEW, UnDefType.NULL);\n+\n+                    } else if ((ALBUM_CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(ALBUM));\n+                        handler.metaRuntimeMultiple = 1;\n+\n+                        // null out movie specific\n+                        handler.updateDetailChannel(DETAIL_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ACTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_DIRECTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING_REASON, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_SYNOPSIS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COLOR_DESCRIPTION, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COUNTRY, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ASPECT_RATIO, UnDefType.NULL);\n+\n+                    } else {\n+                        handler.updateDetailChannel(DETAIL_TYPE, UnDefType.UNDEF);\n+                    }\n+                    // otherwise update the channel if it is one we care about\n+                } else if (METADATA_CHANNELS.contains(metaType)) {\n+                    // special case for cover art image\n+                    if (DETAIL_COVER_URL.equals(metaType)) {\n+                        handler.updateDetailChannel(metaType, new StringType(value));\n+                        if (!value.isEmpty()) {\n+                            try {\n+                                ContentResponse contentResponse = handler.httpClient.newRequest(value).method(GET)\n+                                        .timeout(20, TimeUnit.SECONDS).send();", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU3Mjc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450572772", "bodyText": "OK, 10 seconds should be more than enough.", "author": "mlobstein", "createdAt": "2020-07-07T02:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxODEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449918134", "bodyText": "You could write the comment in a separate line to prevent the auto formatter from garbling it.", "author": "fwolter", "createdAt": "2020-07-05T20:59:01Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeMessageHandler.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeFormatter;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeStatusCodes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeMessageHandler} class processes all messages received\n+ * by the event listener and then updates the appropriate states\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum KaleidescapeMessageHandler {\n+    UI_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.UI_STATE, new StringType(message));\n+        }\n+    },\n+    HIGHLIGHTED_SELECTION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.HIGHLIGHTED_SELECTION, new StringType(message));\n+        }\n+    },\n+    DEVICE_POWER_STATE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 1:1\n+        // power_state, zone 1 state, zone n state\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(POWER, (ONE).equals(matcher.group(1)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"DEVICE_POWER_STATE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    TITLE_NAME {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.TITLE_NAME,\n+                    new StringType(KaleidescapeFormatter.formatString(message)));\n+        }\n+    },\n+    PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 0:0:00:00000:00000:000:00000:00000\n+        // mode, speed, title_num, title_length, title_loc, chapter_num, chapter_length, chapter_loc\n+        private final Pattern p = Pattern\n+                .compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{2}):(\\\\d{5}):(\\\\d{5}):(\\\\d{3}):(\\\\d{5}):(\\\\d{5})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(TITLE_NUM, new DecimalType(Integer.parseInt(matcher.group(3))));\n+\n+                handler.updateChannel(TITLE_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(TITLE_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(5)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_NUM, new DecimalType(Integer.parseInt(matcher.group(6))));\n+\n+                handler.updateChannel(CHAPTER_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(7)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(8)), handler.apiSecondUnit));\n+            } else {\n+                logger.debug(\"PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MOVIE_MEDIA_TYPE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_MEDIA_TYPE,\n+                    new StringType(KaleidescapeStatusCodes.MEDIA_TYPE.get(message)));\n+        }\n+    },\n+    MOVIE_LOCATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_LOCATION,\n+                    new StringType(KaleidescapeStatusCodes.MOVIE_LOCATION.get(message)));\n+        }\n+    },\n+    VIDEO_MODE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00:00:00\n+        // composite, component, hdmi\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_MODE, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_MODE_COMPOSITE,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(VIDEO_MODE_COMPONENT,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(2))));\n+\n+                handler.updateChannel(VIDEO_MODE_HDMI,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(3))));\n+            } else {\n+                logger.debug(\"VIDEO_MODE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    VIDEO_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"VIDEO_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    CONTENT_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CONTENT_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(CONTENT_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"CONTENT_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    SCALE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCALE_MODE, new StringType(message));\n+        }\n+    },\n+    SCREEN_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK, new StringType(message));\n+\n+            // per API reference rev 3.3.1, ASPECT_RATIO message should not be used\n+            // the first element of SCREEN_MASK now provides this info\n+            if (!message.equals(EMPTY)) {\n+                String[] msgSplit = message.split(\":\", 2);\n+                handler.updateChannel(KaleidescapeBindingConstants.ASPECT_RATIO,\n+                        new StringType(KaleidescapeStatusCodes.ASPECT_RATIO.get(msgSplit[0])));\n+            }\n+        }\n+    },\n+    SCREEN_MASK2 {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK2, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MASK, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MODE, new StringType(message));\n+        }\n+    },\n+    CHILD_MODE_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CHILD_MODE_STATE, new StringType(message));\n+        }\n+    },\n+    MUSIC_TITLE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: You:Radiohead:Pablo Honey:1.9b5f4d786d7e2c49-t301_577:1.R_1493833:2.200c5\n+        // track, artist, album, track handle, album handle, now playing handle\n+        private final Pattern p = Pattern.compile(\"^(.*):(.*):(.*):(.*):(.*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // first replace delimited : in track/artist/album name with ||, fix it later in formatString()\n+            Matcher matcher = p.matcher(message.replace(\"\\\\:\", \"||\"));\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_TRACK,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_ARTIST,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(2))));\n+\n+                handler.updateChannel(MUSIC_ALBUM,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(3))));\n+\n+                handler.updateChannel(MUSIC_TRACK_HANDLE, new StringType(matcher.group(4)));\n+\n+                handler.updateChannel(MUSIC_ALBUM_HANDLE, new StringType(matcher.group(5)));\n+\n+                handler.updateChannel(MUSIC_NOWPLAY_HANDLE, new StringType(matcher.group(6)));\n+            } else {\n+                logger.debug(\"MUSIC_TITLE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 2:0:00207:+00000:000.00\n+        // 2:0:00331:+00183:055.29\n+        // mode, speed, track length, track position, track progress %\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{5}):(.\\\\d{5}):(\\\\d{3}\\\\.\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(MUSIC_TRACK_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(3)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_POSITION,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_PROGRESS,\n+                        new DecimalType(BigDecimal.valueOf(Math.round(Double.parseDouble(matcher.group(5))))));\n+            } else {\n+                logger.debug(\"MUSIC_PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_NOW_PLAYING_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00013:00000:0:0:0000000238:2.200c5\n+        // total # tracks in list, list index, repeat, random, generation, now_playing handle\n+        // only using repeat & random right now\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{5}):(\\\\d{5}):(\\\\d{1}):(\\\\d{1}):(\\\\d{10}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                // update REPEAT switch state\n+                handler.updateChannel(MUSIC_REPEAT, (ONE).equals(matcher.group(3)) ? OnOffType.ON : OnOffType.OFF);\n+\n+                // update RANDOM switch state\n+                handler.updateChannel(MUSIC_RANDOM, (ONE).equals(matcher.group(4)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"MUSIC_NOW_PLAYING_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    PLAYING_MUSIC_INFORMATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: R_1493833:Radiohead - Pablo Honey\n+            // album handle, artist - album\n+            // do nothing; redundant\n+        }\n+    },\n+    CONTENT_DETAILS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // g1=meta id, g2=meta type, g3=data\n+        // example: 6:Year:1995\n+        // or: 10:Genres:Pop\\/Rock\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1,2}):([^:^/]*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                String metaType = matcher.group(2).toLowerCase();\n+                String value = KaleidescapeFormatter.formatString(matcher.group(3));\n+\n+                // the CONTENT_DETAILS message with id=1 tells us what type of meta data is coming\n+                if (ONE.equals(matcher.group(1))) {\n+                    if ((CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(MOVIE));\n+                        handler.metaRuntimeMultiple = 60;\n+\n+                        // null out album specific\n+                        handler.updateDetailChannel(DETAIL_ALBUM_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ARTIST, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_REVIEW, UnDefType.NULL);\n+\n+                    } else if ((ALBUM_CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(ALBUM));\n+                        handler.metaRuntimeMultiple = 1;\n+\n+                        // null out movie specific\n+                        handler.updateDetailChannel(DETAIL_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ACTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_DIRECTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING_REASON, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_SYNOPSIS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COLOR_DESCRIPTION, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COUNTRY, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ASPECT_RATIO, UnDefType.NULL);\n+\n+                    } else {\n+                        handler.updateDetailChannel(DETAIL_TYPE, UnDefType.UNDEF);\n+                    }\n+                    // otherwise update the channel if it is one we care about\n+                } else if (METADATA_CHANNELS.contains(metaType)) {\n+                    // special case for cover art image\n+                    if (DETAIL_COVER_URL.equals(metaType)) {\n+                        handler.updateDetailChannel(metaType, new StringType(value));\n+                        if (!value.isEmpty()) {\n+                            try {\n+                                ContentResponse contentResponse = handler.httpClient.newRequest(value).method(GET)\n+                                        .timeout(20, TimeUnit.SECONDS).send();\n+                                int httpStatus = contentResponse.getStatus();\n+                                if (httpStatus == OK_200) {\n+                                    handler.updateDetailChannel(DETAIL_COVER_ART,\n+                                            new RawType(contentResponse.getContent()));\n+                                } else {\n+                                    handler.updateDetailChannel(DETAIL_COVER_ART, UnDefType.NULL);\n+                                }\n+                            } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+                                logger.debug(\"Error updating Cover Art Image channel for url: {}\", value);\n+                                handler.updateDetailChannel(DETAIL_COVER_ART, UnDefType.NULL);\n+                            }\n+                        } else {\n+                            handler.updateDetailChannel(DETAIL_COVER_ART, UnDefType.NULL);\n+                        }\n+                        // special case for running time to create a QuantityType<Time>\n+                    } else if (DETAIL_RUNNING_TIME.equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_RUNNING_TIME, new QuantityType<Time>(\n+                                Integer.parseInt(value) * handler.metaRuntimeMultiple, handler.apiSecondUnit));\n+                        // everything else just send it as a string\n+                    } else {\n+                        handler.updateDetailChannel(metaType, new StringType(value));\n+                    }\n+                }\n+            } else {\n+                logger.debug(\"CONTENT_DETAILS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    TIME {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // do nothing\n+        }\n+    },\n+    STATUS_CUE_PERIOD {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // do nothing\n+        }\n+    },\n+    ASPECT_RATIO {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // per API reference rev 3.3.1, ASPECT_RATIO message should not be used\n+            // the first element of SCREEN_MASK now provides this info\n+        }\n+    },\n+    USER_DEFINED_EVENT {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: SELECT_KALEIDESCAPE_INPUT\n+            try {\n+                switch (message) {\n+                    // when the ipad or phone app is started up, it sends a VOLUME_QUERY,\n+                    // so we respond to enable volume controls and set the initial volume and mute\n+                    case \"VOLUME_QUERY\":\n+                        if (handler.volumeEnabled) {\n+                            synchronized (handler.sequenceLock) {\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_CAPABILITIES_15);\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + handler.volume);\n+                                handler.connector.sendCommand(SEND_EVENT_MUTE + (handler.isMuted ? MUTE_ON : MUTE_OFF));\n+                            }\n+                        }\n+                        break;\n+                    case \"VOLUME_UP\":\n+                        if (handler.volumeEnabled) {\n+                            synchronized (handler.sequenceLock) {\n+                                handler.volume++;\n+                                handler.updateChannel(VOLUME, new PercentType(BigDecimal.valueOf(handler.volume)));\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + handler.volume);\n+                            }\n+                        }\n+                        break;\n+                    case \"VOLUME_DOWN\":\n+                        if (handler.volumeEnabled) {\n+                            synchronized (handler.sequenceLock) {\n+                                handler.volume--;\n+                                handler.updateChannel(VOLUME, new PercentType(BigDecimal.valueOf(handler.volume)));\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + handler.volume);\n+                            }\n+                        }\n+                        break;\n+                    case \"TOGGLE_MUTE\":\n+                        State state = UnDefType.UNDEF;\n+                        synchronized (handler.sequenceLock) {\n+                            if (handler.isMuted) {\n+                                state = OnOffType.OFF;\n+                                handler.isMuted = false;\n+                            } else {\n+                                state = OnOffType.ON;\n+                                handler.isMuted = true;\n+                            }\n+                            handler.connector.sendCommand(SEND_EVENT_MUTE + (handler.isMuted ? MUTE_ON : MUTE_OFF));\n+                            handler.updateChannel(MUTE, state);\n+                        }\n+                        break;\n+                    // the default is to just publish all other USER_DEFINED_EVENTs\n+                    default:\n+                        handler.updateChannel(KaleidescapeBindingConstants.USER_DEFINED_EVENT, new StringType(message));\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.debug(\"USER_DEFINED_EVENT - exception on message: {}\", message);\n+            }\n+        }\n+    },\n+    USER_INPUT {\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: 01:Search for title:ABC\n+            handler.updateChannel(KaleidescapeBindingConstants.USER_INPUT, new StringType(message));\n+        }\n+    },\n+    USER_INPUT_PROMPT {\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: 00:00::00:0:1\n+            handler.updateChannel(KaleidescapeBindingConstants.USER_INPUT, new StringType(message));\n+        }\n+    },\n+    SYSTEM_READINESS_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example 1, 2 or 3\n+            handler.updateChannel(KaleidescapeBindingConstants.SYSTEM_READINESS_STATE,\n+                    new StringType(KaleidescapeStatusCodes.READINESS_STATE.get(message)));\n+        }\n+    },\n+    SYSTEM_VERSION {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 16:8.6.0-21023\n+        // protocol version, kOS version\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(.*)$\");\n+\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateThingProperty(PROPERTY_PROTOCOL_VERSION, matcher.group(1));\n+                handler.updateThingProperty(PROPERTY_SYSTEM_VERSION, matcher.group(2));\n+            } else {\n+                logger.debug(\"SYSTEM_VERSION - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    DEVICE_INFO {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 07:000000000000558F:00:192.168.001.100\n+        // device type (deprecated), serial number, cpdid, ip address\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(.*):(\\\\d{2}):(.*)$\");\n+\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateThingProperty(PROPERTY_SERIAL_NUMBER, matcher.group(2).replaceFirst(\"^0+(?!$)\", EMPTY)); // take\n+                                                                                                                       // off\n+                                                                                                                       // leading\n+                                                                                                                       // zeros", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "45bf4f68b9d7cad93cf1cb63669a3a692244b5c6", "url": "https://github.com/openhab/openhab-addons/commit/45bf4f68b9d7cad93cf1cb63669a3a692244b5c6", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-07T02:52:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450584068", "bodyText": "@fwolter It is possible that these are not needed since I have implemented the \"REFRESH\" actions for the channels? If the channels all refresh on reboot, they would cause all these same commands to be sent.", "author": "mlobstein", "createdAt": "2020-07-07T02:56:26Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {", "originalCommit": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MDc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450850759", "bodyText": "They can be removed, then.", "author": "fwolter", "createdAt": "2020-07-07T13:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MDQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r451240450", "bodyText": "@fwolter\nI am not sure. Is there a way to change the REFRESH behavior for the channels? I had seen refresh fire while developing the Nuvo binding. For a few channels, I was not handling the refresh type separately. Mistakenly I was doing command.toString() without checking the command type which ended up printing \"REFRESH\" on all my wall keypads :)\nWhen I comment out the initial commands here, the channels do not seem to refresh on startup. I didn't want the same commands being sent by both reconnect and refresh. But I feel like it is better for reconnect to query the controller to get the current state of everything if the refresh behavior is inconsistent.", "author": "mlobstein", "createdAt": "2020-07-08T02:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2ODg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r451768881", "bodyText": "I think it's ok to issue the queries twice on (re)connect for the sake of simple code. One on REFRESH and the other as initial commands on reconnect.", "author": "fwolter", "createdAt": "2020-07-08T19:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NjQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487876440", "bodyText": "I have used ExpiringCache with a small timout, like 3 seconds. When the cache expires it will call the method passed. You could use this channels have the same command, such that when multiple of these channels are updated they are not all sending the command. And when using a cache you can probably iterate over the channels here, check if the channel is linked (i.e. if it actually make sense to update the channel) and then call handleRefresh with the channel instead of directly sending the command here. There is also an ExpiringCacheMap to handle multiple caches.", "author": "Hilbrand", "createdAt": "2020-09-14T12:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA=="}], "type": "inlineReview"}, {"oid": "5b2bbdade4823ebb6974be26038d220e0f5c764a", "url": "https://github.com/openhab/openhab-addons/commit/5b2bbdade4823ebb6974be26038d220e0f5c764a", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-07T03:01:43Z", "type": "commit"}, {"oid": "c08523aa8e0587306243d261e1d280702aaad1c1", "url": "https://github.com/openhab/openhab-addons/commit/c08523aa8e0587306243d261e1d280702aaad1c1", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-08T22:16:16Z", "type": "commit"}, {"oid": "9c3a1755977c02184ce94ac1ade28123a80f37fc", "url": "https://github.com/openhab/openhab-addons/commit/9c3a1755977c02184ce94ac1ade28123a80f37fc", "message": "Add ThingActions bug workaround\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-16T21:33:59Z", "type": "commit"}, {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-16T21:38:23Z", "type": "commit"}, {"oid": "bb5329643407a367391a2224328311997f14a3f8", "url": "https://github.com/openhab/openhab-addons/commit/bb5329643407a367391a2224328311997f14a3f8", "message": "[kaleidescape] Workaround for thing actions bug\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-17T21:49:05Z", "type": "commit"}, {"oid": "9b579193ad576302dc462c6574b4890746be2025", "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-25T03:38:33Z", "type": "commit"}, {"oid": "78f69778930aba426a203feec98c17aee188a536", "url": "https://github.com/openhab/openhab-addons/commit/78f69778930aba426a203feec98c17aee188a536", "message": "Merge pull request #8 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-28T15:24:48Z", "type": "commit"}, {"oid": "fe2e96a8b02c7692f02c2f5e19f7f45f6cd56f16", "url": "https://github.com/openhab/openhab-addons/commit/fe2e96a8b02c7692f02c2f5e19f7f45f6cd56f16", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-07-29T14:01:30Z", "type": "commit"}, {"oid": "538098533700b32473c6a712c0b94ecd1ef30179", "url": "https://github.com/openhab/openhab-addons/commit/538098533700b32473c6a712c0b94ecd1ef30179", "message": "update version and review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-29T14:26:35Z", "type": "commit"}, {"oid": "ede36af231a0a9697e9f0cf373a46a37fe13f143", "url": "https://github.com/openhab/openhab-addons/commit/ede36af231a0a9697e9f0cf373a46a37fe13f143", "message": "removed unused dependencies\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-14T02:45:34Z", "type": "commit"}, {"oid": "4606089923324ea3ee66e434f8221e3259d2910c", "url": "https://github.com/openhab/openhab-addons/commit/4606089923324ea3ee66e434f8221e3259d2910c", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-14T18:35:52Z", "type": "commit"}, {"oid": "f49106bbf897956459a88243323fc5d64a4b3223", "url": "https://github.com/openhab/openhab-addons/commit/f49106bbf897956459a88243323fc5d64a4b3223", "message": "Merge pull request #9 from openhab/2.5.x\n\nUpdate fork", "committedDate": "2020-08-22T01:32:17Z", "type": "commit"}, {"oid": "5fd1b3d52e605d6f59d9eb7d5dad7a82ebad7c3c", "url": "https://github.com/openhab/openhab-addons/commit/5fd1b3d52e605d6f59d9eb7d5dad7a82ebad7c3c", "message": "Roll forward a few review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-25T02:08:34Z", "type": "commit"}, {"oid": "94e4815acfab18936bf860d9780cce0af0f7b9f7", "url": "https://github.com/openhab/openhab-addons/commit/94e4815acfab18936bf860d9780cce0af0f7b9f7", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T13:30:01Z", "type": "commit"}, {"oid": "ce6b1b83511266993e7e74b54122b54654265a79", "url": "https://github.com/openhab/openhab-addons/commit/ce6b1b83511266993e7e74b54122b54654265a79", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T15:39:12Z", "type": "commit"}, {"oid": "bf93c068b57bdd21e214921b2b8a833db876de24", "url": "https://github.com/openhab/openhab-addons/commit/bf93c068b57bdd21e214921b2b8a833db876de24", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-08-26T17:38:13Z", "type": "commit"}, {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2", "url": "https://github.com/openhab/openhab-addons/commit/ad93130f407d635fcbe3fd1198a869baa1856cb2", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T19:05:12Z", "type": "commit"}, {"oid": "31227c502d4697366429850b34557b7cebf44831", "url": "https://github.com/openhab/openhab-addons/commit/31227c502d4697366429850b34557b7cebf44831", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T20:01:12Z", "type": "commit"}, {"oid": "91b502d6be82aa91b659c9a6bfcfa0c57cb11fd3", "url": "https://github.com/openhab/openhab-addons/commit/91b502d6be82aa91b659c9a6bfcfa0c57cb11fd3", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-08-26T20:03:09Z", "type": "commit"}, {"oid": "86a5327cb44c5f0ed3f4640a439df62954d8ab33", "url": "https://github.com/openhab/openhab-addons/commit/86a5327cb44c5f0ed3f4640a439df62954d8ab33", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x", "committedDate": "2020-09-03T00:24:02Z", "type": "commit"}, {"oid": "a6496680c4bc78b0baec704969179b033b21197f", "url": "https://github.com/openhab/openhab-addons/commit/a6496680c4bc78b0baec704969179b033b21197f", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x", "committedDate": "2020-09-03T13:33:02Z", "type": "commit"}, {"oid": "61abc1f55cfa645afd9c6f3e2119e9f7ed6fb09d", "url": "https://github.com/openhab/openhab-addons/commit/61abc1f55cfa645afd9c6f3e2119e9f7ed6fb09d", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-09-03T13:33:30Z", "type": "commit"}, {"oid": "05fbbaf25a713e8147387b05c02fe2b2005d61da", "url": "https://github.com/openhab/openhab-addons/commit/05fbbaf25a713e8147387b05c02fe2b2005d61da", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x", "committedDate": "2020-09-09T13:34:56Z", "type": "commit"}, {"oid": "a45901a01798dfd1342d4c8c7b85e8964321b48c", "url": "https://github.com/openhab/openhab-addons/commit/a45901a01798dfd1342d4c8c7b85e8964321b48c", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x", "committedDate": "2020-09-09T14:20:56Z", "type": "commit"}, {"oid": "803c0bb644614b715606cce56997f5061aadd685", "url": "https://github.com/openhab/openhab-addons/commit/803c0bb644614b715606cce56997f5061aadd685", "message": "Merge branch '2.5.x' into Kaleidescape", "committedDate": "2020-09-09T15:14:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI0MTA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487241044", "bodyText": "You should still log something here at the very least.", "author": "cpmeister", "createdAt": "2020-09-11T19:17:08Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeSerialConnector.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the Kaleidescape component through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ */\n+@NonNullByDefault\n+public class KaleidescapeSerialConnector extends KaleidescapeConnector {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeSerialConnector.class);\n+\n+    private final String serialPortName;\n+    private final SerialPortManager serialPortManager;\n+    private final String uid;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     * @param uid the thing uid string\n+     */\n+    public KaleidescapeSerialConnector(SerialPortManager serialPortManager, String serialPortName, String uid) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+        this.uid = uid;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws KaleidescapeException {\n+        logger.debug(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                throw new KaleidescapeException(\"Opening serial connection failed: No Such Port\");\n+            }\n+\n+            SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000);\n+\n+            commPort.setSerialPortParams(19200, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(100);\n+            commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\n+\n+            InputStream dataIn = commPort.getInputStream();\n+            OutputStream dataOut = commPort.getOutputStream();\n+\n+            if (dataOut != null) {\n+                dataOut.flush();\n+            }\n+            if (dataIn != null && dataIn.markSupported()) {\n+                try {\n+                    dataIn.reset();\n+                } catch (IOException e) {\n+                }", "originalCommit": "ad93130f407d635fcbe3fd1198a869baa1856cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNTI0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487315249", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-09-11T22:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI0MTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1NTAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487255013", "bodyText": "Should probably check whether any of the channels have been removed before you edit the thing.", "author": "cpmeister", "createdAt": "2020-09-11T19:45:33Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,610 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());", "originalCommit": "ad93130f407d635fcbe3fd1198a869baa1856cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNTEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487315136", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-09-11T22:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1NTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1ODA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487258085", "bodyText": "Don't use the default thread factory here. You should name the threads in some way so that the can be identified as part of this binding, also make sure that the threads you create are daemon.\nYou can use a NamedThreadFactory instance as an additional parameter to newFixedThreadPool.", "author": "cpmeister", "createdAt": "2020-09-11T19:51:38Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE_MS, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);", "originalCommit": "ad93130f407d635fcbe3fd1198a869baa1856cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487314933", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-09-11T22:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1ODA4NQ=="}], "type": "inlineReview"}, {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "url": "https://github.com/openhab/openhab-addons/commit/da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-09-11T22:13:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1OTEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487859128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.kaleidescape\")", "author": "Hilbrand", "createdAt": "2020-09-14T12:04:59Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Mjg0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487862840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(KaleidescapeMessageEvent event);\n          \n          \n            \n                void onNewMessageEvent(KaleidescapeMessageEvent event);", "author": "Hilbrand", "createdAt": "2020-09-14T12:11:43Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeMessageEventListener.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import java.util.EventListener;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Kaleidescape Event Listener interface. Handles incoming Kaleidescape message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface KaleidescapeMessageEventListener extends EventListener {\n+    /**\n+     * Event handler method for incoming Kaleidescape message events\n+     *\n+     * @param event the KaleidescapeMessageEvent object\n+     */\n+    public void onNewMessageEvent(KaleidescapeMessageEvent event);", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487864324", "bodyText": "I wonder if you would create a thing with volum disabled and than edit the thing to enable the volume if the channels will come back? Not sure if that works? You might need to recreate them.", "author": "Hilbrand", "createdAt": "2020-09-14T12:14:28Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5Mzg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r488293896", "bodyText": "I did not realize remove was permanent. I changed it to not remove the channels.", "author": "mlobstein", "createdAt": "2020-09-14T23:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NjI4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487866282", "bodyText": "It would be cleaner to use separate thing definitions for these different models. The UI initially just reads the xml and then would show all channels even if not available if one would create the thing manually in the ui. You would not need to specify the component type as parameter. The xml will become a bit larger. Although you can use a config reference to point to a single configuration.", "author": "Hilbrand", "createdAt": "2020-09-14T12:18:01Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5NDExNA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r488294114", "bodyText": "Agreed, 4 things are now implemented.", "author": "mlobstein", "createdAt": "2020-09-14T23:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Njg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487866881", "bodyText": "If you also set the status this can be debug. You could set the command and message in the status to give the user this information directly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n          \n          \n            \n                            logger.debug(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");", "author": "Hilbrand", "createdAt": "2020-09-14T12:19:09Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        if (channelsRemoved) {\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort, uid);\n+        } else if (port != null) {\n+            connector = new KaleidescapeIpConnector(host, port, uid);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MjgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487872816", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateState(channel, new StringType(EMPTY));\n          \n          \n            \n                            updateState(channel, StringType.EMPTY);", "author": "Hilbrand", "createdAt": "2020-09-14T12:29:13Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        if (channelsRemoved) {\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort, uid);\n+        } else if (port != null) {\n+            connector = new KaleidescapeIpConnector(host, port, uid);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL_S * 1.25 * 1000)) {\n+                        logger.warn(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, POLLING_INTERVAL_S, POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    private void handleControlCommand(Command command) throws KaleidescapeException {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connector.sendCommand(PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connector.sendCommand(PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connector.sendCommand(NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connector.sendCommand(PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                connector.sendCommand(SCAN_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                connector.sendCommand(SCAN_REVERSE);\n+            }\n+        } else {\n+            logger.warn(\"Unknown control command: {}\", command);\n+        }\n+    }\n+\n+    private void handleRefresh(String channel) throws KaleidescapeException {\n+        switch (channel) {\n+            case POWER:\n+                connector.sendCommand(GET_DEVICE_POWER_STATE);\n+                break;\n+            case VOLUME:\n+                updateState(channel, new PercentType(this.volume));\n+                break;\n+            case MUTE:\n+                updateState(channel, this.isMuted ? OnOffType.ON : OnOffType.OFF);\n+                break;\n+            case TITLE_NAME:\n+                connector.sendCommand(GET_PLAYING_TITLE_NAME);\n+                break;\n+            case PLAY_MODE:\n+            case PLAY_SPEED:\n+            case TITLE_NUM:\n+            case TITLE_LENGTH:\n+            case TITLE_LOC:\n+            case CHAPTER_NUM:\n+            case CHAPTER_LENGTH:\n+            case CHAPTER_LOC:\n+                connector.sendCommand(GET_PLAY_STATUS);\n+                break;\n+            case MOVIE_MEDIA_TYPE:\n+                connector.sendCommand(GET_MOVIE_MEDIA_TYPE);\n+                break;\n+            case MOVIE_LOCATION:\n+                connector.sendCommand(GET_MOVIE_LOCATION);\n+                break;\n+            case VIDEO_MODE:\n+            case VIDEO_MODE_COMPOSITE:\n+            case VIDEO_MODE_COMPONENT:\n+            case VIDEO_MODE_HDMI:\n+                connector.sendCommand(GET_VIDEO_MODE);\n+                break;\n+            case VIDEO_COLOR:\n+            case VIDEO_COLOR_EOTF:\n+                connector.sendCommand(GET_VIDEO_COLOR);\n+                break;\n+            case CONTENT_COLOR:\n+            case CONTENT_COLOR_EOTF:\n+                connector.sendCommand(GET_CONTENT_COLOR);\n+                break;\n+            case SCALE_MODE:\n+                connector.sendCommand(GET_SCALE_MODE);\n+                break;\n+            case ASPECT_RATIO:\n+            case SCREEN_MASK:\n+                connector.sendCommand(GET_SCREEN_MASK);\n+                break;\n+            case SCREEN_MASK2:\n+                connector.sendCommand(GET_SCREEN_MASK2);\n+                break;\n+            case CINEMASCAPE_MASK:\n+                connector.sendCommand(GET_CINEMASCAPE_MASK);\n+                break;\n+            case CINEMASCAPE_MODE:\n+                connector.sendCommand(GET_CINEMASCAPE_MODE);\n+                break;\n+            case UI_STATE:\n+                connector.sendCommand(GET_UI_STATE);\n+                break;\n+            case CHILD_MODE_STATE:\n+                connector.sendCommand(GET_CHILD_MODE_STATE);\n+                break;\n+            case SYSTEM_READINESS_STATE:\n+                connector.sendCommand(GET_SYSTEM_READINESS_STATE);\n+                break;\n+            case HIGHLIGHTED_SELECTION:\n+                connector.sendCommand(GET_HIGHLIGHTED_SELECTION);\n+                break;\n+            case USER_DEFINED_EVENT:\n+            case USER_INPUT:\n+            case USER_INPUT_PROMPT:\n+                updateState(channel, new StringType(EMPTY));", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3Mjk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487872960", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateState(channel, new StringType(EMPTY));\n          \n          \n            \n                            updateState(channel, StringType.EMPTY);", "author": "Hilbrand", "createdAt": "2020-09-14T12:29:27Z", "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        if (channelsRemoved) {\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort, uid);\n+        } else if (port != null) {\n+            connector = new KaleidescapeIpConnector(host, port, uid);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL_S * 1.25 * 1000)) {\n+                        logger.warn(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, POLLING_INTERVAL_S, POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    private void handleControlCommand(Command command) throws KaleidescapeException {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connector.sendCommand(PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connector.sendCommand(PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connector.sendCommand(NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connector.sendCommand(PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                connector.sendCommand(SCAN_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                connector.sendCommand(SCAN_REVERSE);\n+            }\n+        } else {\n+            logger.warn(\"Unknown control command: {}\", command);\n+        }\n+    }\n+\n+    private void handleRefresh(String channel) throws KaleidescapeException {\n+        switch (channel) {\n+            case POWER:\n+                connector.sendCommand(GET_DEVICE_POWER_STATE);\n+                break;\n+            case VOLUME:\n+                updateState(channel, new PercentType(this.volume));\n+                break;\n+            case MUTE:\n+                updateState(channel, this.isMuted ? OnOffType.ON : OnOffType.OFF);\n+                break;\n+            case TITLE_NAME:\n+                connector.sendCommand(GET_PLAYING_TITLE_NAME);\n+                break;\n+            case PLAY_MODE:\n+            case PLAY_SPEED:\n+            case TITLE_NUM:\n+            case TITLE_LENGTH:\n+            case TITLE_LOC:\n+            case CHAPTER_NUM:\n+            case CHAPTER_LENGTH:\n+            case CHAPTER_LOC:\n+                connector.sendCommand(GET_PLAY_STATUS);\n+                break;\n+            case MOVIE_MEDIA_TYPE:\n+                connector.sendCommand(GET_MOVIE_MEDIA_TYPE);\n+                break;\n+            case MOVIE_LOCATION:\n+                connector.sendCommand(GET_MOVIE_LOCATION);\n+                break;\n+            case VIDEO_MODE:\n+            case VIDEO_MODE_COMPOSITE:\n+            case VIDEO_MODE_COMPONENT:\n+            case VIDEO_MODE_HDMI:\n+                connector.sendCommand(GET_VIDEO_MODE);\n+                break;\n+            case VIDEO_COLOR:\n+            case VIDEO_COLOR_EOTF:\n+                connector.sendCommand(GET_VIDEO_COLOR);\n+                break;\n+            case CONTENT_COLOR:\n+            case CONTENT_COLOR_EOTF:\n+                connector.sendCommand(GET_CONTENT_COLOR);\n+                break;\n+            case SCALE_MODE:\n+                connector.sendCommand(GET_SCALE_MODE);\n+                break;\n+            case ASPECT_RATIO:\n+            case SCREEN_MASK:\n+                connector.sendCommand(GET_SCREEN_MASK);\n+                break;\n+            case SCREEN_MASK2:\n+                connector.sendCommand(GET_SCREEN_MASK2);\n+                break;\n+            case CINEMASCAPE_MASK:\n+                connector.sendCommand(GET_CINEMASCAPE_MASK);\n+                break;\n+            case CINEMASCAPE_MODE:\n+                connector.sendCommand(GET_CINEMASCAPE_MODE);\n+                break;\n+            case UI_STATE:\n+                connector.sendCommand(GET_UI_STATE);\n+                break;\n+            case CHILD_MODE_STATE:\n+                connector.sendCommand(GET_CHILD_MODE_STATE);\n+                break;\n+            case SYSTEM_READINESS_STATE:\n+                connector.sendCommand(GET_SYSTEM_READINESS_STATE);\n+                break;\n+            case HIGHLIGHTED_SELECTION:\n+                connector.sendCommand(GET_HIGHLIGHTED_SELECTION);\n+                break;\n+            case USER_DEFINED_EVENT:\n+            case USER_INPUT:\n+            case USER_INPUT_PROMPT:\n+                updateState(channel, new StringType(EMPTY));\n+                break;\n+            case MUSIC_REPEAT:\n+            case MUSIC_RANDOM:\n+                connector.sendCommand(GET_MUSIC_NOW_PLAYING_STATUS);\n+                break;\n+            case MUSIC_TRACK:\n+            case MUSIC_ARTIST:\n+            case MUSIC_ALBUM:\n+            case MUSIC_TRACK_HANDLE:\n+            case MUSIC_ALBUM_HANDLE:\n+            case MUSIC_NOWPLAY_HANDLE:\n+                connector.sendCommand(GET_MUSIC_TITLE);\n+                break;\n+            case MUSIC_PLAY_MODE:\n+            case MUSIC_PLAY_SPEED:\n+            case MUSIC_TRACK_LENGTH:\n+            case MUSIC_TRACK_POSITION:\n+            case MUSIC_TRACK_PROGRESS:\n+                connector.sendCommand(GET_MUSIC_PLAY_STATUS);\n+                break;\n+            case DETAIL_TYPE:\n+            case DETAIL_TITLE:\n+            case DETAIL_ALBUM_TITLE:\n+            case DETAIL_COVER_ART:\n+            case DETAIL_COVER_URL:\n+            case DETAIL_HIRES_COVER_URL:\n+            case DETAIL_RATING:\n+            case DETAIL_YEAR:\n+            case DETAIL_RUNNING_TIME:\n+            case DETAIL_ACTORS:\n+            case DETAIL_ARTIST:\n+            case DETAIL_DIRECTORS:\n+            case DETAIL_GENRES:\n+            case DETAIL_RATING_REASON:\n+            case DETAIL_SYNOPSIS:\n+            case DETAIL_REVIEW:\n+            case DETAIL_COLOR_DESCRIPTION:\n+            case DETAIL_COUNTRY:\n+            case DETAIL_ASPECT_RATIO:\n+            case DETAIL_DISC_LOCATION:\n+                updateState(channel, new StringType(EMPTY));", "originalCommit": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1d99857260e30163bd2a6460bfd1f2c71361378", "url": "https://github.com/openhab/openhab-addons/commit/e1d99857260e30163bd2a6460bfd1f2c71361378", "message": "implement thing per model and caching\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-09-14T23:28:19Z", "type": "commit"}]}