{"pr_number": 7718, "pr_title": "[stiebeleltron] Initial commit", "pr_createdAt": "2020-05-21T18:43:41Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7718", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMzg5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440413894", "bodyText": "This comment has no benefit. You could remove it. Same for similar. Private fields don't need to be commented.", "author": "fwolter", "createdAt": "2020-06-15T20:00:07Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/StiebelEltronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal;\n+\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.THING_TYPE_SAMPLE;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.modbus.stiebeleltron.internal.handler.StiebelEltronHandler;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.stiebeleltron\", service = ThingHandlerFactory.class)\n+public class StiebelEltronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    /**\n+     * Reference to the modbus manager\n+     */", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NTc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r441775777", "bodyText": "Comment removed", "author": "pail23", "createdAt": "2020-06-17T19:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMzg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNDM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440414349", "bodyText": "Sample?", "author": "fwolter", "createdAt": "2020-06-15T20:01:01Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/StiebelEltronBindingConstants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.openhab.binding.modbus.ModbusBindingConstants;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronBindingConstants} class defines common\n+ * constants, which are used across the whole binding.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronBindingConstants {\n+\n+    private static final String BINDING_ID = ModbusBindingConstants.BINDING_ID;\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_SAMPLE = new ThingTypeUID(BINDING_ID, \"heatpump\");", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNzI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r441817269", "bodyText": "The field is named THING_TYPE_SAMPLE.", "author": "fwolter", "createdAt": "2020-06-17T20:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNDM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5NzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r442997466", "bodyText": "changed to THING_TYPE_HEATPUMP", "author": "pail23", "createdAt": "2020-06-19T18:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNTAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440415009", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-06-15T20:02:24Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5NzQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r442997478", "bodyText": "Comment removed", "author": "pail23", "createdAt": "2020-06-19T18:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440415314", "bodyText": "Does this have any function?", "author": "fwolter", "createdAt": "2020-06-15T20:02:57Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5NzY2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r442997660", "bodyText": "Removed", "author": "pail23", "createdAt": "2020-06-19T18:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNzUyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440417529", "bodyText": "Local variables don't need to be annotated. You could remove it. Same for below.", "author": "fwolter", "createdAt": "2020-06-15T20:07:40Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMjU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443012561", "bodyText": "removed", "author": "pail23", "createdAt": "2020-06-19T19:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxODg1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440418852", "bodyText": "Is it logged twice by intention?", "author": "fwolter", "createdAt": "2020-06-15T20:10:15Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMjYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443012608", "bodyText": "removed", "author": "pail23", "createdAt": "2020-06-19T19:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxODg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMDA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440420090", "bodyText": "If this is fatal or unexpected, it should be logged to warn.", "author": "fwolter", "createdAt": "2020-06-15T20:12:45Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMjY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443012655", "bodyText": "changed to warn", "author": "pail23", "createdAt": "2020-06-19T19:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMDA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMTc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440421770", "bodyText": "What excpetion type do you want to catch here? Better specify the concrete type and add throws declaration to the method which throws the exception.", "author": "fwolter", "createdAt": "2020-06-15T20:15:51Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMjgwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443012809", "bodyText": "removed the try/catch as there should be no exception", "author": "pail23", "createdAt": "2020-06-19T19:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNjM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440426356", "bodyText": "You might want to throw an exception here to be able to log that the user used an unsupported command. Same for below.", "author": "fwolter", "createdAt": "2020-06-15T20:25:20Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzExMA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443013110", "bodyText": "add the \"throw IllegalArgumentException\"", "author": "pail23", "createdAt": "2020-06-19T19:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNjM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1ODMwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443158307", "bodyText": "It's bad practice to throw unchecked exceptions (as IllegalArgumentException is) on expected errors, since the compiler doesn't enforce you to catch those. Better create your own exception, which extends from Exception and throw that.", "author": "fwolter", "createdAt": "2020-06-20T20:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNjM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc2MDY5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443760690", "bodyText": "Changed exception type to StiebelEltronException", "author": "pail23", "createdAt": "2020-06-22T18:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNjM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyODMwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440428305", "bodyText": "What is the state of the TODO?", "author": "fwolter", "createdAt": "2020-06-15T20:29:07Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzM5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443013396", "bodyText": "remove the REFRESH command handling: There is no refresh need because of the polling mechanism", "author": "pail23", "createdAt": "2020-06-19T19:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyODMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1ODM2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443158365", "bodyText": "Can you schedule an immediate polling if the refresh command arrives?", "author": "fwolter", "createdAt": "2020-06-20T20:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyODMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc2MDc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443760787", "bodyText": "Yes, done", "author": "pail23", "createdAt": "2020-06-22T18:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyODMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyOTQ4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440429480", "bodyText": "Did you test what happen if the user uses Fahrenheit? Do you need an additional c.toUnit()?", "author": "fwolter", "createdAt": "2020-06-15T20:31:25Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzQ2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443013467", "bodyText": "Added the .toUnit", "author": "pail23", "createdAt": "2020-06-19T19:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyOTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMDc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440430757", "bodyText": "sunspec?", "author": "fwolter", "createdAt": "2020-06-15T20:34:02Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443013602", "bodyText": "copy paste mistake: fixed", "author": "pail23", "createdAt": "2020-06-19T19:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNDQ2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440434469", "bodyText": "Better move this to the end of the initialization, since the framework starts to work with this thing and can invoke handleCommand() and dispose() when the state is set to UNKNOWN.", "author": "fwolter", "createdAt": "2020-06-15T20:41:30Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443013705", "bodyText": "moved to the end", "author": "pail23", "createdAt": "2020-06-19T19:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNDQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MTc4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440441782", "bodyText": "The compiler complains here, since systemInformationPoller could be set to null between the null check and the invocation of unregisterPollTask(). You can store the reference of systemInformationPoller to a local variable and do the null check on that. Same for below.", "author": "fwolter", "createdAt": "2020-06-15T20:56:01Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        logger.trace(\"unregisterPollTasks\");\n+        if (systemInformationPoller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            systemInformationPoller.unregisterPollTask();", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxMzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443013773", "bodyText": "added local variables", "author": "pail23", "createdAt": "2020-06-19T19:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0Mjc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440442778", "bodyText": "You could put the log message as an argument into the exception's constructor and remove the log message.", "author": "fwolter", "createdAt": "2020-06-15T20:57:55Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        logger.trace(\"unregisterPollTasks\");\n+        if (systemInformationPoller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            systemInformationPoller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+        if (energyPoller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            energyPoller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+        if (systemStatePoller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            systemStatePoller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+        if (systemParameterPoller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            systemParameterPoller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            throw new IllegalStateException();", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNTI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443015255", "bodyText": "done", "author": "pail23", "createdAt": "2020-06-19T19:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0Mjc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NTQ1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440445459", "bodyText": "This is much overhead to work around two null checks. Beside that, there is still a compiler warning left. IMHO you don't need to log the bridge's label, since bridge and things are already correlated in the UI.", "author": "fwolter", "createdAt": "2020-06-15T21:02:58Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        logger.trace(\"unregisterPollTasks\");\n+        if (systemInformationPoller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            systemInformationPoller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+        if (energyPoller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            energyPoller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+        if (systemStatePoller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            systemStatePoller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+        if (systemParameterPoller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            systemParameterPoller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, String.format(\"Bridge '%s' is offline\",\n+                    Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\")));", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNTM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443015394", "bodyText": "removed the bridge name", "author": "pail23", "createdAt": "2020-06-19T19:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NjgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440446808", "bodyText": "Why not removing the catch clause, throw the exception and catch it in startUp()? This would simplify code.", "author": "fwolter", "createdAt": "2020-06-15T21:05:46Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        logger.trace(\"unregisterPollTasks\");\n+        if (systemInformationPoller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            systemInformationPoller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+        if (energyPoller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            energyPoller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+        if (systemStatePoller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            systemStatePoller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+        if (systemParameterPoller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            systemParameterPoller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, String.format(\"Bridge '%s' is offline\",\n+                    Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\")));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNTUwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443015505", "bodyText": "moved the whole code to startUp", "author": "pail23", "createdAt": "2020-06-19T19:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0OTY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440449686", "bodyText": "Can you use camel case here?", "author": "fwolter", "createdAt": "2020-06-15T21:11:44Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,736 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+        /**\n+         * Logger instance\n+         */\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public AbstractBasePoller() {\n+        }\n+\n+        public synchronized void unregisterPollTask() {\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            @Nullable\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            @Nullable\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.info(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    try {\n+                        handlePolledData(registers);\n+\n+                        if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (Exception error) {\n+                        StiebelEltronHandler.this.handleError(error);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+            @Nullable\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }        \n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in the stiebel eltron modbus\n+     *         documentation)\n+     */\n+    private short getScaledInt16Value(Command command) {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = (QuantityType<?>) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            // TODO: Implement refresh\n+        } else {\n+            if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_OPERATION_MODE:\n+                        writeInt16(1500, getInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                        writeInt16(1501, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                        writeInt16(1502, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                        writeInt16(1509, getScaledInt16Value(command));\n+                        break;\n+                    case CHANNEL_ECO_TEMPERATURE_WATER:\n+                        writeInt16(1510, getScaledInt16Value(command));\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (endpoint == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for sunspec handler\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller  = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        logger.trace(\"unregisterPollTasks\");\n+        if (systemInformationPoller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            systemInformationPoller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+        if (energyPoller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            energyPoller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+        if (systemStatePoller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            systemStatePoller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+        if (systemParameterPoller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            systemParameterPoller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, String.format(\"Bridge '%s' is offline\",\n+                    Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\")));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private synchronized void unregisterEndpoint() {\n+        endpoint = null;\n+    }\n+\n+    /**\n+     * Returns value divided by the 10\n+     *\n+     * @param value the value to alter\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getScaled(Number value, Unit<?> unit) {\n+        return new QuantityType<>(BigDecimal.valueOf(value.longValue(), 1), unit);\n+    }\n+\n+    /**\n+     * Returns high value * 1000 + low value\n+     *\n+     * @param high the high value\n+     * @param low the low valze\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getEnergyQuantity(int high, int low) {\n+        double value = high * 1000 + low;\n+        return new QuantityType<>(value, KILOWATT_HOUR);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemInformationData(ModbusRegisterArray registers) {\n+        logger.trace(\"System Information block received, size: {}\", registers.size());\n+\n+        SystemInformationBlock block = systemInformationBlockParser.parse(registers);\n+\n+        // System information group\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE), getScaled(block.temperature_fek, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_fek_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_HUMIDITY), getScaled(block.humidity_ffk, PERCENT));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_DEWPOINT), getScaled(block.dewpoint_ffk, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_OUTDOOR_TEMPERATURE),\n+                getScaled(block.temperature_outdoor, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE), getScaled(block.temperature_hk1, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_hk1_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SUPPLY_TEMPERATURE),\n+                getScaled(block.temperature_supply, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_RETURN_TEMPERATURE),\n+                getScaled(block.temperature_return, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SOURCE_TEMPERATURE),\n+                getScaled(block.temperature_source, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE),\n+                getScaled(block.temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_water_setpoint, CELSIUS));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledEnergyData(ModbusRegisterArray registers) {\n+        logger.trace(\"Energy block received, size: {}\", registers.size());\n+\n+        EnergyBlock block = energyBlockParser.parse(registers);\n+\n+        // Energy information group\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TODAY),\n+                new QuantityType<>(block.production_heat_today, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.production_heat_total_high, block.production_heat_total_low));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TODAY),\n+                new QuantityType<>(block.production_water_today, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TOTAL),\n+                getEnergyQuantity(block.production_water_total_high, block.production_water_total_low));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TODAY),\n+                new QuantityType<>(block.consumption_heat_today, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.consumption_heat_total_high, block.consumption_heat_total_low));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TODAY),\n+                new QuantityType<>(block.consumption_water_today, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TOTAL),\n+                getEnergyQuantity(block.consumption_water_total_high, block.consumption_water_total_low));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemStateData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemStateBlock block = systemstateBlockParser.parse(registers);\n+        boolean is_heating = (block.state & 16) != 0;", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNTU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443015572", "bodyText": "done", "author": "pail23", "createdAt": "2020-06-19T19:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0OTY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1NTEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440455128", "bodyText": "Can you use camel case here?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public int production_heat_today;\n          \n          \n            \n                public int productionHeatToday;", "author": "fwolter", "createdAt": "2020-06-15T21:23:15Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/dto/EnergyBlock.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.dto;\n+\n+/**\n+ * Dto class for the Energy Block\n+ *\n+ * @author Paul Frank - Initial contribution\n+ *\n+ */\n+public class EnergyBlock {\n+\n+    public int production_heat_today;", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNTY1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443015659", "bodyText": "done", "author": "pail23", "createdAt": "2020-06-19T19:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1NTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1NTc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r440455784", "bodyText": "Since this method returns Double, you might want to use double instead of float.", "author": "fwolter", "createdAt": "2020-06-15T21:24:50Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/parser/AbstractBaseParser.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.parser;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+\n+/**\n+ * Base class for parsers with some helper methods\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ * @author Paul Frank - Added more methods\n+ */\n+@NonNullByDefault\n+public class AbstractBaseParser {\n+\n+    /**\n+     * Extract an optional double value\n+     *\n+     * @param raw the register array to extract from\n+     * @param index the address of the field\n+     * @return the parsed value or empty if the field is not implemented\n+     */\n+    protected Optional<Double> extractOptionalDouble(ModbusRegisterArray raw, int index) {\n+        return ModbusBitUtilities.extractStateFromRegisters(raw, index, ValueType.INT16)\n+                .map(value -> ((float) value.intValue()) / 10.0).filter(value -> value != (short) 0x8000);\n+    }", "originalCommit": "326bb6cd4ea16809963d8c61ea7a842fdaaa00bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNTc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r443015768", "bodyText": "changed to double", "author": "pail23", "createdAt": "2020-06-19T19:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1NTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444444668", "bodyText": "Can you use camel case?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public short temperature_fek;\n          \n          \n            \n                public short temperatureFek;", "author": "fwolter", "createdAt": "2020-06-23T19:05:31Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/dto/SystemInformationBlock.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.dto;\n+\n+/**\n+ * Dto class for the System Information Block\n+ *\n+ * @author Paul Frank - Initial contribution\n+ *\n+ */\n+public class SystemInformationBlock {\n+\n+    public short temperature_fek;", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NTAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444445037", "bodyText": "See above (camel case)", "author": "fwolter", "createdAt": "2020-06-23T19:05:54Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/dto/SystemParameterBlock.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.dto;\n+\n+/**\n+ * Dto class for the System Parameter Block\n+ *\n+ * @author Paul Frank - Initial contribution\n+ *\n+ */\n+public class SystemParameterBlock {\n+\n+    public Integer operation_mode;", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDA5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124091", "bodyText": "changed to camel case", "author": "pail23", "createdAt": "2020-06-24T19:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NjA5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444446097", "bodyText": "Is there a reason why you use complex type? Can this be int? Same for below.", "author": "fwolter", "createdAt": "2020-06-23T19:07:47Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/dto/SystemParameterBlock.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.dto;\n+\n+/**\n+ * Dto class for the System Parameter Block\n+ *\n+ * @author Paul Frank - Initial contribution\n+ *\n+ */\n+public class SystemParameterBlock {\n+\n+    public Integer operation_mode;", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124162", "bodyText": "changed to int", "author": "pail23", "createdAt": "2020-06-24T19:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NjA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NjQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444446433", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-06-23T19:08:25Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/dto/SystemStateBlock.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.dto;\n+\n+/**\n+ * Dto class for the System State Block\n+ *\n+ * @author Paul Frank - Initial contribution\n+ *\n+ */\n+public class SystemStateBlock {\n+\n+    public Integer state;", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDI0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124249", "bodyText": "changed to int", "author": "pail23", "createdAt": "2020-06-24T19:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NjQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0Njc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444446762", "bodyText": "Can you add the NonNullByDefault annotation?", "author": "fwolter", "createdAt": "2020-06-23T19:09:02Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronException.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+/**\n+ * Thrown when the stiebel eltron handler sees an error.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+public class StiebelEltronException extends Exception {", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124454", "bodyText": "added the NonNullByDefault annotation", "author": "pail23", "createdAt": "2020-06-24T19:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0Njc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NDg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444454881", "bodyText": "Local variables need no Nullable annotation.", "author": "fwolter", "createdAt": "2020-06-23T19:24:35Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124629", "bodyText": "removed the annotation", "author": "pail23", "createdAt": "2020-06-24T19:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NDg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NTk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444455954", "bodyText": "Is this expected to be called very often? Otherwise, it's ok to set an online thing to online.", "author": "fwolter", "createdAt": "2020-06-23T19:26:36Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwMjgwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445102809", "bodyText": "It depends on the polling frequency. About every 5 sec. Would you consider this as often?", "author": "pail23", "createdAt": "2020-06-24T18:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzM5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445137390", "bodyText": "I think it's better to leave it as is, then.", "author": "fwolter", "createdAt": "2020-06-24T19:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1OTY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444459672", "bodyText": "You can do this to eliminate the compiler warning:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        AbstractBasePoller poller = null;\n          \n          \n            \n                        String groupId = channelUID.getGroupId();\n          \n          \n            \n                        if (groupId != null) {\n          \n          \n            \n                            switch (groupId) {\n          \n          \n            \n                                case GROUP_SYSTEM_STATE:\n          \n          \n            \n                                    poller = systemStatePoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case GROUP_SYSTEM_PARAMETER:\n          \n          \n            \n                                    poller = systemParameterPoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case GROUP_SYSTEM_INFO:\n          \n          \n            \n                                    poller = systemInformationPoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case GROUP_ENERGY_INFO:\n          \n          \n            \n                                    poller = energyPoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (poller != null) {\n          \n          \n            \n                            poller.poll();\n          \n          \n            \n                        }\n          \n          \n            \n                        AbstractBasePoller poller;\n          \n          \n            \n                        String groupId = channelUID.getGroupId();\n          \n          \n            \n                        if (groupId != null) {\n          \n          \n            \n                            switch (groupId) {\n          \n          \n            \n                                case GROUP_SYSTEM_STATE:\n          \n          \n            \n                                    poller = systemStatePoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case GROUP_SYSTEM_PARAMETER:\n          \n          \n            \n                                    poller = systemParameterPoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case GROUP_SYSTEM_INFO:\n          \n          \n            \n                                    poller = systemInformationPoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case GROUP_ENERGY_INFO:\n          \n          \n            \n                                    poller = energyPoller;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                default:\n          \n          \n            \n                                    poller = null;\n          \n          \n            \n                                    break;\n          \n          \n            \n                            }\n          \n          \n            \n                            if (poller != null) {\n          \n          \n            \n                                poller.poll();\n          \n          \n            \n                            }\n          \n          \n            \n                        }", "author": "fwolter", "createdAt": "2020-06-23T19:33:43Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124860", "bodyText": "I have taken over your proposal", "author": "pail23", "createdAt": "2020-06-24T19:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1OTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MTY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444461668", "bodyText": "The error message is already logged by the framework. You could remove your log message.", "author": "fwolter", "createdAt": "2020-06-23T19:37:47Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException e) {\n+                handleError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler Connect to the slave bridge\n+     * Start the periodic polling1\n+     */\n+    private void startUp() {\n+\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Bridge is offline\");\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124928", "bodyText": "removed", "author": "pail23", "createdAt": "2020-06-24T19:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MTg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444461870", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-06-23T19:38:12Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException e) {\n+                handleError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler Connect to the slave bridge\n+     * Start the periodic polling1\n+     */\n+    private void startUp() {\n+\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Bridge is offline\");\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNDk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445124983", "bodyText": "removed", "author": "pail23", "createdAt": "2020-06-24T19:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MzkzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444463934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new QuantityType<>(BigDecimal.valueOf(value.longValue(), 1), unit);\n          \n          \n            \n                    return QuantityType.valueOf(value.doubleValue(), unit);", "author": "fwolter", "createdAt": "2020-06-23T19:42:26Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException e) {\n+                handleError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler Connect to the slave bridge\n+     * Start the periodic polling1\n+     */\n+    private void startUp() {\n+\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Bridge is offline\");\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        if (config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for stiebel eltron handler\");\n+            return;\n+        }\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        AbstractBasePoller poller = systemInformationPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+\n+        poller = energyPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+\n+        poller = systemStatePoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+\n+        poller = systemParameterPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        endpoint = null;\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            throw new IllegalStateException(\"Unexpected bridge handler: \" + handler.toString());\n+        }\n+    }\n+\n+    /**\n+     * Returns value divided by the 10\n+     *\n+     * @param value the value to alter\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getScaled(Number value, Unit<?> unit) {\n+        return new QuantityType<>(BigDecimal.valueOf(value.longValue(), 1), unit);", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NDQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444464479", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-06-23T19:43:22Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException e) {\n+                handleError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler Connect to the slave bridge\n+     * Start the periodic polling1\n+     */\n+    private void startUp() {\n+\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Bridge is offline\");\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        if (config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for stiebel eltron handler\");\n+            return;\n+        }\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        AbstractBasePoller poller = systemInformationPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+\n+        poller = energyPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+\n+        poller = systemStatePoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+\n+        poller = systemParameterPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        endpoint = null;\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            throw new IllegalStateException(\"Unexpected bridge handler: \" + handler.toString());\n+        }\n+    }\n+\n+    /**\n+     * Returns value divided by the 10\n+     *\n+     * @param value the value to alter\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getScaled(Number value, Unit<?> unit) {\n+        return new QuantityType<>(BigDecimal.valueOf(value.longValue(), 1), unit);\n+    }\n+\n+    /**\n+     * Returns high value * 1000 + low value\n+     *\n+     * @param high the high value\n+     * @param low  the low valze\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getEnergyQuantity(int high, int low) {\n+        double value = high * 1000 + low;\n+        return new QuantityType<>(value, KILOWATT_HOUR);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemInformationData(ModbusRegisterArray registers) {\n+        logger.trace(\"System Information block received, size: {}\", registers.size());\n+\n+        SystemInformationBlock block = systemInformationBlockParser.parse(registers);\n+\n+        // System information group\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE), getScaled(block.temperature_fek, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_fek_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_HUMIDITY), getScaled(block.humidity_ffk, PERCENT));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_DEWPOINT), getScaled(block.dewpoint_ffk, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_OUTDOOR_TEMPERATURE),\n+                getScaled(block.temperature_outdoor, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE), getScaled(block.temperature_hk1, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_hk1_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SUPPLY_TEMPERATURE),\n+                getScaled(block.temperature_supply, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_RETURN_TEMPERATURE),\n+                getScaled(block.temperature_return, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SOURCE_TEMPERATURE),\n+                getScaled(block.temperature_source, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE),\n+                getScaled(block.temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_water_setpoint, CELSIUS));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledEnergyData(ModbusRegisterArray registers) {\n+        logger.trace(\"Energy block received, size: {}\", registers.size());\n+\n+        EnergyBlock block = energyBlockParser.parse(registers);\n+\n+        // Energy information group\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TODAY),\n+                new QuantityType<>(block.productionHeatToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.productionHeatTotalHigh, block.productionHeatTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TODAY),\n+                new QuantityType<>(block.productionWaterToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TOTAL),\n+                getEnergyQuantity(block.productionWaterTotalHigh, block.productionWaterTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TODAY),\n+                new QuantityType<>(block.consumptionHeatToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.consumptionHeatTotalHigh, block.consumptionHeatTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TODAY),\n+                new QuantityType<>(block.consumptionWaterToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TOTAL),\n+                getEnergyQuantity(block.consumptionWaterTotalHigh, block.consumptionWaterTotalLow));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemStateData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemStateBlock block = systemstateBlockParser.parse(registers);\n+        boolean isHeating = (block.state & 16) != 0;\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_HEATING),\n+                isHeating ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_HEATING_WATER),\n+                (block.state & 32) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_COOLING),\n+                (block.state & 256) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_SUMMER),\n+                (block.state & 128) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_PUMPING),\n+                (block.state & 1) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemParameterData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemParameterBlock block = systemParameterBlockParser.parse(registers);\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_OPERATION_MODE), new DecimalType(block.operation_mode));\n+\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_COMFORT_TEMPERATURE_HEATING),\n+                getScaled(block.comfort_temperature_heating, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_ECO_TEMPERATURE_HEATING),\n+                getScaled(block.eco_temperature_heating, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_COMFORT_TEMPERATURE_WATER),\n+                getScaled(block.comfort_temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_ECO_TEMPERATURE_WATER),\n+                getScaled(block.eco_temperature_water, CELSIUS));\n+    }\n+\n+    /**\n+     * @param bridgeStatusInfo\n+     */\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+\n+        logger.debug(\"Thing status changed to {}\", this.getThing().getStatus().name());", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445125053", "bodyText": "removed", "author": "pail23", "createdAt": "2020-06-24T19:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NDQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NjUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444466504", "bodyText": "You are checking for the Thing status here. Do you want to check the bridge status?", "author": "fwolter", "createdAt": "2020-06-23T19:47:19Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException e) {\n+                handleError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler Connect to the slave bridge\n+     * Start the periodic polling1\n+     */\n+    private void startUp() {\n+\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Bridge is offline\");\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        if (config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for stiebel eltron handler\");\n+            return;\n+        }\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        AbstractBasePoller poller = systemInformationPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+\n+        poller = energyPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+\n+        poller = systemStatePoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+\n+        poller = systemParameterPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        endpoint = null;\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            throw new IllegalStateException(\"Unexpected bridge handler: \" + handler.toString());\n+        }\n+    }\n+\n+    /**\n+     * Returns value divided by the 10\n+     *\n+     * @param value the value to alter\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getScaled(Number value, Unit<?> unit) {\n+        return new QuantityType<>(BigDecimal.valueOf(value.longValue(), 1), unit);\n+    }\n+\n+    /**\n+     * Returns high value * 1000 + low value\n+     *\n+     * @param high the high value\n+     * @param low  the low valze\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getEnergyQuantity(int high, int low) {\n+        double value = high * 1000 + low;\n+        return new QuantityType<>(value, KILOWATT_HOUR);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemInformationData(ModbusRegisterArray registers) {\n+        logger.trace(\"System Information block received, size: {}\", registers.size());\n+\n+        SystemInformationBlock block = systemInformationBlockParser.parse(registers);\n+\n+        // System information group\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE), getScaled(block.temperature_fek, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_fek_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_HUMIDITY), getScaled(block.humidity_ffk, PERCENT));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_DEWPOINT), getScaled(block.dewpoint_ffk, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_OUTDOOR_TEMPERATURE),\n+                getScaled(block.temperature_outdoor, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE), getScaled(block.temperature_hk1, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_hk1_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SUPPLY_TEMPERATURE),\n+                getScaled(block.temperature_supply, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_RETURN_TEMPERATURE),\n+                getScaled(block.temperature_return, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SOURCE_TEMPERATURE),\n+                getScaled(block.temperature_source, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE),\n+                getScaled(block.temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_water_setpoint, CELSIUS));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledEnergyData(ModbusRegisterArray registers) {\n+        logger.trace(\"Energy block received, size: {}\", registers.size());\n+\n+        EnergyBlock block = energyBlockParser.parse(registers);\n+\n+        // Energy information group\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TODAY),\n+                new QuantityType<>(block.productionHeatToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.productionHeatTotalHigh, block.productionHeatTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TODAY),\n+                new QuantityType<>(block.productionWaterToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TOTAL),\n+                getEnergyQuantity(block.productionWaterTotalHigh, block.productionWaterTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TODAY),\n+                new QuantityType<>(block.consumptionHeatToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.consumptionHeatTotalHigh, block.consumptionHeatTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TODAY),\n+                new QuantityType<>(block.consumptionWaterToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TOTAL),\n+                getEnergyQuantity(block.consumptionWaterTotalHigh, block.consumptionWaterTotalLow));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemStateData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemStateBlock block = systemstateBlockParser.parse(registers);\n+        boolean isHeating = (block.state & 16) != 0;\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_HEATING),\n+                isHeating ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_HEATING_WATER),\n+                (block.state & 32) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_COOLING),\n+                (block.state & 256) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_SUMMER),\n+                (block.state & 128) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_PUMPING),\n+                (block.state & 1) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemParameterData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemParameterBlock block = systemParameterBlockParser.parse(registers);\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_OPERATION_MODE), new DecimalType(block.operation_mode));\n+\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_COMFORT_TEMPERATURE_HEATING),\n+                getScaled(block.comfort_temperature_heating, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_ECO_TEMPERATURE_HEATING),\n+                getScaled(block.eco_temperature_heating, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_COMFORT_TEMPERATURE_WATER),\n+                getScaled(block.comfort_temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_ECO_TEMPERATURE_WATER),\n+                getScaled(block.eco_temperature_water, CELSIUS));\n+    }\n+\n+    /**\n+     * @param bridgeStatusInfo\n+     */\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+\n+        logger.debug(\"Thing status changed to {}\", this.getThing().getStatus().name());\n+        if (getThing().getStatus() == ThingStatus.ONLINE) {\n+            startUp();\n+        } else if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+            tearDown();\n+        }", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNTI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445125257", "bodyText": "good point. I have changed it to the bridge status", "author": "pail23", "createdAt": "2020-06-24T19:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NjUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3Mzg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r444473870", "bodyText": "Is this method used anywhere?", "author": "fwolter", "createdAt": "2020-06-23T20:01:13Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicModbusRegister;\n+import org.openhab.io.transport.modbus.BasicModbusRegisterArray;\n+import org.openhab.io.transport.modbus.BasicModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BasicWriteTask;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusManager;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusResponse;\n+import org.openhab.io.transport.modbus.ModbusWriteCallback;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+            logger.debug(\"Unregistering polling from ModbusManager\");\n+            StiebelEltronHandler.this.modbusManager.unregisterRegularPoll(task);\n+\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusSlaveEndpoint myendpoint = StiebelEltronHandler.this.endpoint;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || myendpoint == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+            pollTask = new BasicPollTaskImpl(myendpoint, request, new ModbusReadCallback() {\n+\n+                @Override\n+                public void onRegisters(@Nullable ModbusReadRequestBlueprint request,\n+                        @Nullable ModbusRegisterArray registers) {\n+                    if (registers == null) {\n+                        logger.warn(\"Received empty register array on poll\");\n+                        return;\n+                    }\n+                    handlePolledData(registers);\n+\n+                    if (StiebelEltronHandler.this.getThing().getStatus() != ThingStatus.ONLINE) {\n+                        updateStatus(ThingStatus.ONLINE);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(@Nullable ModbusReadRequestBlueprint request, @Nullable Exception error) {\n+                    StiebelEltronHandler.this.handleError(error);\n+                }\n+\n+                @Override\n+                public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                    // don't care, we don't expect this result\n+                }\n+            });\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.registerRegularPoll(task, refreshMillis, 1000);\n+            }\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            if (task != null) {\n+                StiebelEltronHandler.this.modbusManager.submitOneTimePoll(task);\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * This is the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusSlaveEndpoint endpoint = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Reference to the modbus manager\n+     */\n+    protected ModbusManager modbusManager;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing         the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing, ModbusManager modbusManager) {\n+        super(thing);\n+        this.modbusManager = modbusManager;\n+    }\n+\n+    /**\n+     * @param address    address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        @Nullable\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        if (myconfig == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new BasicModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new BasicModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        BasicModbusWriteRegisterRequestBlueprint request = new BasicModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        ModbusSlaveEndpoint slaveEndpoint = this.endpoint;\n+        if (slaveEndpoint == null) {\n+            return;\n+        }\n+\n+        BasicWriteTask writeTask = new BasicWriteTask(slaveEndpoint, request, new ModbusWriteCallback() {\n+            @Override\n+            public void onWriteResponse(ModbusWriteRequestBlueprint request, ModbusResponse response) {\n+                if (hasConfigurationError()) {\n+                    return;\n+                }\n+                logger.debug(\"Successful write, matching request {}\", request);\n+                StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+            }\n+\n+            @Override\n+            public void onError(ModbusWriteRequestBlueprint request, Exception error) {\n+                StiebelEltronHandler.this.handleError(error);\n+            }\n+        });\n+        logger.trace(\"Submitting write task: {}\", writeTask);\n+        modbusManager.submitOneTimeWrite(writeTask);\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            AbstractBasePoller poller = null;\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                }\n+            }\n+            if (poller != null) {\n+                poller.poll();\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException e) {\n+                handleError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Initialization: Load the config object of the block Connect to the slave\n+     * bridge Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StiebelEltronConfiguration.class);\n+        logger.debug(\"Initializing thing with properties: {}\", thing.getProperties());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler Connect to the slave bridge\n+     * Start the periodic polling1\n+     */\n+    private void startUp() {\n+\n+        if (endpoint != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Bridge is offline\");\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        try {\n+            slaveId = slaveEndpointThingHandler.getSlaveId();\n+\n+            endpoint = slaveEndpointThingHandler.asSlaveEndpoint();\n+        } catch (EndpointNotInitializedException e) {\n+            // this will be handled below as endpoint remains null\n+        }\n+\n+        if (endpoint == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+\n+        if (config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for stiebel eltron handler\");\n+            return;\n+        }\n+\n+        if (systemInformationPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemInformationData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(500, 36, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemInformationPoller = poller;\n+        }\n+        if (energyPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledEnergyData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(3500, 16, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            energyPoller = poller;\n+        }\n+        if (systemStatePoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemStateData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(2500, 2, ModbusReadFunctionCode.READ_INPUT_REGISTERS);\n+            systemStatePoller = poller;\n+        }\n+        if (systemParameterPoller == null) {\n+            AbstractBasePoller poller = new AbstractBasePoller() {\n+                @Override\n+                protected void handlePolledData(ModbusRegisterArray registers) {\n+                    handlePolledSystemParameterData(registers);\n+                }\n+\n+            };\n+            poller.registerPollTask(1500, 11, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS);\n+            systemParameterPoller = poller;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        AbstractBasePoller poller = systemInformationPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemInformationPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemInformationPoller = null;\n+        }\n+\n+        poller = energyPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering energyPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            energyPoller = null;\n+        }\n+\n+        poller = systemStatePoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemStatePoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemStatePoller = null;\n+        }\n+\n+        poller = systemParameterPoller;\n+        if (poller != null) {\n+            logger.debug(\"Unregistering systemParameterPoller from ModbusManager\");\n+            poller.unregisterPollTask();\n+\n+            systemParameterPoller = null;\n+        }\n+\n+        endpoint = null;\n+    }\n+\n+    /**\n+     * Returns the current slave id from the bridge\n+     */\n+    public int getSlaveId() {\n+        return slaveId;\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to Checks\n+     * that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            throw new IllegalStateException(\"Unexpected bridge handler: \" + handler.toString());\n+        }\n+    }\n+\n+    /**\n+     * Returns value divided by the 10\n+     *\n+     * @param value the value to alter\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getScaled(Number value, Unit<?> unit) {\n+        return new QuantityType<>(BigDecimal.valueOf(value.longValue(), 1), unit);\n+    }\n+\n+    /**\n+     * Returns high value * 1000 + low value\n+     *\n+     * @param high the high value\n+     * @param low  the low valze\n+     * @return the scaled value as a DecimalType\n+     */\n+    protected State getEnergyQuantity(int high, int low) {\n+        double value = high * 1000 + low;\n+        return new QuantityType<>(value, KILOWATT_HOUR);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemInformationData(ModbusRegisterArray registers) {\n+        logger.trace(\"System Information block received, size: {}\", registers.size());\n+\n+        SystemInformationBlock block = systemInformationBlockParser.parse(registers);\n+\n+        // System information group\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE), getScaled(block.temperature_fek, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_fek_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_HUMIDITY), getScaled(block.humidity_ffk, PERCENT));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_FEK_DEWPOINT), getScaled(block.dewpoint_ffk, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_OUTDOOR_TEMPERATURE),\n+                getScaled(block.temperature_outdoor, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE), getScaled(block.temperature_hk1, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_HK1_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_hk1_setpoint, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SUPPLY_TEMPERATURE),\n+                getScaled(block.temperature_supply, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_RETURN_TEMPERATURE),\n+                getScaled(block.temperature_return, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_SOURCE_TEMPERATURE),\n+                getScaled(block.temperature_source, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE),\n+                getScaled(block.temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_INFO, CHANNEL_WATER_TEMPERATURE_SETPOINT),\n+                getScaled(block.temperature_water_setpoint, CELSIUS));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledEnergyData(ModbusRegisterArray registers) {\n+        logger.trace(\"Energy block received, size: {}\", registers.size());\n+\n+        EnergyBlock block = energyBlockParser.parse(registers);\n+\n+        // Energy information group\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TODAY),\n+                new QuantityType<>(block.productionHeatToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.productionHeatTotalHigh, block.productionHeatTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TODAY),\n+                new QuantityType<>(block.productionWaterToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_PRODUCTION_WATER_TOTAL),\n+                getEnergyQuantity(block.productionWaterTotalHigh, block.productionWaterTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TODAY),\n+                new QuantityType<>(block.consumptionHeatToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_HEAT_TOTAL),\n+                getEnergyQuantity(block.consumptionHeatTotalHigh, block.consumptionHeatTotalLow));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TODAY),\n+                new QuantityType<>(block.consumptionWaterToday, KILOWATT_HOUR));\n+        updateState(channelUID(GROUP_ENERGY_INFO, CHANNEL_CONSUMPTION_WATER_TOTAL),\n+                getEnergyQuantity(block.consumptionWaterTotalHigh, block.consumptionWaterTotalLow));\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemStateData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemStateBlock block = systemstateBlockParser.parse(registers);\n+        boolean isHeating = (block.state & 16) != 0;\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_HEATING),\n+                isHeating ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_HEATING_WATER),\n+                (block.state & 32) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_COOLING),\n+                (block.state & 256) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_SUMMER),\n+                (block.state & 128) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+        updateState(channelUID(GROUP_SYSTEM_STATE, CHANNEL_IS_PUMPING),\n+                (block.state & 1) != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus\n+     * slave The register array is first parsed, then each of the channels are\n+     * updated to the new values\n+     *\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledSystemParameterData(ModbusRegisterArray registers) {\n+        logger.trace(\"System state block received, size: {}\", registers.size());\n+\n+        SystemParameterBlock block = systemParameterBlockParser.parse(registers);\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_OPERATION_MODE), new DecimalType(block.operation_mode));\n+\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_COMFORT_TEMPERATURE_HEATING),\n+                getScaled(block.comfort_temperature_heating, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_ECO_TEMPERATURE_HEATING),\n+                getScaled(block.eco_temperature_heating, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_COMFORT_TEMPERATURE_WATER),\n+                getScaled(block.comfort_temperature_water, CELSIUS));\n+        updateState(channelUID(GROUP_SYSTEM_PARAMETER, CHANNEL_ECO_TEMPERATURE_WATER),\n+                getScaled(block.eco_temperature_water, CELSIUS));\n+    }\n+\n+    /**\n+     * @param bridgeStatusInfo\n+     */\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+\n+        logger.debug(\"Thing status changed to {}\", this.getThing().getStatus().name());\n+        if (getThing().getStatus() == ThingStatus.ONLINE) {\n+            startUp();\n+        } else if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+            tearDown();\n+        }\n+    }\n+\n+    /**\n+     * Handle errors received during communication\n+     */\n+    protected void handleError(@Nullable Exception error) {\n+        // Ignore all incoming data and errors if configuration is not correct\n+        if (hasConfigurationError() || getThing().getStatus() == ThingStatus.OFFLINE) {\n+            return;\n+        }\n+        String msg = \"\";\n+        String cls = \"\";\n+        if (error != null) {\n+            cls = error.getClass().getName();\n+            msg = error.getMessage();\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                String.format(\"Error with read: %s: %s\", cls, msg));\n+    }\n+\n+    /**\n+     * Returns true, if we're in a CONFIGURATION_ERROR state\n+     *\n+     * @return\n+     */\n+    protected boolean hasConfigurationError() {\n+        ThingStatusInfo statusInfo = getThing().getStatusInfo();\n+        return statusInfo.getStatus() == ThingStatus.OFFLINE\n+                && statusInfo.getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR;\n+    }\n+\n+    /**\n+     * Reset communication status to ONLINE if we're in an OFFLINE state\n+     */\n+    protected void resetCommunicationError() {", "originalCommit": "a167f86258fd73651ec72f42f2b99c01b046d5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyNTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r445125485", "bodyText": "I have inserted the method call in the polling data handlers", "author": "pail23", "createdAt": "2020-06-24T19:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3Mzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2NTk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r453865954", "bodyText": "Syntactical sugar. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }, failure -> {StiebelEltronHandler.this.handleReadError(failure);});\n          \n          \n            \n                        }, StiebelEltronHandler.this::handleReadError);", "author": "fwolter", "createdAt": "2020-07-13T19:01:05Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+\n+            ModbusCommunicationInterface mycomms = StiebelEltronHandler.this.comms;\n+            if (mycomms != null) {\n+                mycomms.unregisterRegularPoll(task);\n+            }\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusCommunicationInterface mycomms = StiebelEltronHandler.this.comms;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || mycomms == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+                result.getRegisters().ifPresent(this::handlePolledData);\n+                if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            }, failure -> {StiebelEltronHandler.this.handleReadError(failure);});", "originalCommit": "1fe4a967869bb7203ec731025560cdf00805ff35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg4NDU3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r453884574", "bodyText": "Changed to your proposal", "author": "pail23", "createdAt": "2020-07-13T19:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2NTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3MDk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r453870952", "bodyText": "Initialization with empty strings has no effect, since they are overwritten below. You can initialize them with the intended values at once.", "author": "fwolter", "createdAt": "2020-07-13T19:10:04Z", "path": "bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.stiebeleltron.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.KILOWATT_HOUR;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronBindingConstants.*;\n+\n+import java.util.Optional;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.stiebeleltron.internal.StiebelEltronConfiguration;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.EnergyBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemInformationBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemParameterBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.dto.SystemStateBlock;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.EnergyBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemInfromationBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemParameterBlockParser;\n+import org.openhab.binding.modbus.stiebeleltron.internal.parser.SystemStateBlockParser;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusWriteRequestBlueprint;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Modbus.StiebelEltronHandler} is responsible for handling commands,\n+ * which are sent to one of the channels and for polling the modbus.\n+ *\n+ * @author Paul Frank - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StiebelEltronHandler extends BaseThingHandler {\n+\n+    public abstract class AbstractBasePoller {\n+\n+        private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+        private volatile @Nullable PollTask pollTask;\n+\n+        public synchronized void unregisterPollTask() {\n+            PollTask task = pollTask;\n+            if (task == null) {\n+                return;\n+            }\n+\n+            ModbusCommunicationInterface mycomms = StiebelEltronHandler.this.comms;\n+            if (mycomms != null) {\n+                mycomms.unregisterRegularPoll(task);\n+            }\n+            pollTask = null;\n+        }\n+\n+        /**\n+         * Register poll task This is where we set up our regular poller\n+         */\n+        public synchronized void registerPollTask(int address, int length, ModbusReadFunctionCode readFunctionCode) {\n+\n+            logger.debug(\"Setting up regular polling\");\n+\n+            ModbusCommunicationInterface mycomms = StiebelEltronHandler.this.comms;\n+            StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+            if (myconfig == null || mycomms == null) {\n+                throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+            }\n+\n+            ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(getSlaveId(),\n+                    readFunctionCode, address, length, myconfig.getMaxTries());\n+\n+\n+            long refreshMillis = myconfig.getRefreshMillis();\n+\n+            pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+                result.getRegisters().ifPresent(this::handlePolledData);\n+                if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            }, failure -> {StiebelEltronHandler.this.handleReadError(failure);});\n+        }\n+\n+        public synchronized void poll() {\n+            PollTask task = pollTask;\n+            ModbusCommunicationInterface mycomms = StiebelEltronHandler.this.comms;\n+            if (task != null && mycomms != null) {\n+                mycomms.submitOneTimePoll(task.getRequest(), task.getResultCallback(), task.getFailureCallback());\n+            }\n+        }\n+\n+        protected abstract void handlePolledData(ModbusRegisterArray registers);\n+    }\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StiebelEltronHandler.class);\n+\n+    /**\n+     * Configuration instance\n+     */\n+    protected @Nullable StiebelEltronConfiguration config = null;\n+    /**\n+     * Parser used to convert incoming raw messages into system blocks\n+     */\n+    private final SystemInfromationBlockParser systemInformationBlockParser = new SystemInfromationBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system state blocks\n+     */\n+    private final SystemStateBlockParser systemstateBlockParser = new SystemStateBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into system parameter blocks\n+     */\n+    private final SystemParameterBlockParser systemParameterBlockParser = new SystemParameterBlockParser();\n+    /**\n+     * Parser used to convert incoming raw messages into model blocks\n+     */\n+    private final EnergyBlockParser energyBlockParser = new EnergyBlockParser();\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemInformationPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller energyPoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemStatePoller = null;\n+    /**\n+     * This is the task used to poll the device\n+     */\n+    private volatile @Nullable AbstractBasePoller systemParameterPoller = null;\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * This is the slave id, we store this once initialization is complete\n+     */\n+    private volatile int slaveId;\n+\n+    /**\n+     * Instances of this handler should get a reference to the modbus manager\n+     *\n+     * @param thing the thing to handle\n+     * @param modbusManager the modbus manager\n+     */\n+    public StiebelEltronHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * @param address address of the value to be written on the modbus\n+     * @param shortValue value to be written on the modbus\n+     */\n+    protected void writeInt16(int address, short shortValue) {\n+        StiebelEltronConfiguration myconfig = StiebelEltronHandler.this.config;\n+        ModbusCommunicationInterface mycomms = StiebelEltronHandler.this.comms;\n+\n+        if (myconfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+        // big endian byte ordering\n+        byte b1 = (byte) (shortValue >> 8);\n+        byte b2 = (byte) shortValue;\n+\n+        ModbusRegister register = new ModbusRegister(b1, b2);\n+        ModbusRegisterArray data = new ModbusRegisterArray(new ModbusRegister[] { register });\n+\n+        ModbusWriteRegisterRequestBlueprint request = new ModbusWriteRegisterRequestBlueprint(slaveId,\n+                address, data, false, myconfig.getMaxTries());\n+\n+        mycomms.submitOneTimeWrite(request, result -> {\n+            if (hasConfigurationError()) {\n+                return;\n+            }\n+            logger.debug(\"Successful write, matching request {}\", request);\n+            StiebelEltronHandler.this.updateStatus(ThingStatus.ONLINE);\n+        }, failure -> {StiebelEltronHandler.this.handleWriteError(failure);});\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command multiplied by 10 (see datatype 2 in\n+     *         the stiebel eltron modbus documentation)\n+     */\n+    private short getScaledInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> c = ((QuantityType<?>) command).toUnit(CELSIUS);\n+            if (c != null) {\n+                return (short) (c.doubleValue() * 10);\n+            } else {\n+                throw new StiebelEltronException(\"Unsupported unit\");\n+            }\n+        }\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return (short) (c.doubleValue() * 10);\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * @param command get the value of this command.\n+     * @return short the value of the command as short\n+     */\n+    private short getInt16Value(Command command) throws StiebelEltronException {\n+        if (command instanceof DecimalType) {\n+            DecimalType c = (DecimalType) command;\n+            return c.shortValue();\n+        }\n+        throw new StiebelEltronException(\"Unsupported command type\");\n+    }\n+\n+    /**\n+     * Handle incoming commands.\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH == command) {\n+            String groupId = channelUID.getGroupId();\n+            if (groupId != null) {\n+                AbstractBasePoller poller;\n+                switch (groupId) {\n+                    case GROUP_SYSTEM_STATE:\n+                        poller = systemStatePoller;\n+                        break;\n+                    case GROUP_SYSTEM_PARAMETER:\n+                        poller = systemParameterPoller;\n+                        break;\n+                    case GROUP_SYSTEM_INFO:\n+                        poller = systemInformationPoller;\n+                        break;\n+                    case GROUP_ENERGY_INFO:\n+                        poller = energyPoller;\n+                        break;\n+                    default:\n+                        poller = null;\n+                        break;\n+                }\n+                if (poller != null) {\n+                    poller.poll();\n+                }\n+            }\n+        } else {\n+            try {\n+                if (GROUP_SYSTEM_PARAMETER.equals(channelUID.getGroupId())) {\n+                    switch (channelUID.getIdWithoutGroup()) {\n+                        case CHANNEL_OPERATION_MODE:\n+                            writeInt16(1500, getInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_HEATING:\n+                            writeInt16(1501, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_HEATING:\n+                            writeInt16(1502, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_COMFORT_TEMPERATURE_WATER:\n+                            writeInt16(1509, getScaledInt16Value(command));\n+                            break;\n+                        case CHANNEL_ECO_TEMPERATURE_WATER:\n+                            writeInt16(1510, getScaledInt16Value(command));\n+                            break;\n+                    }\n+                }\n+            } catch (StiebelEltronException error) {\n+                if (hasConfigurationError() || getThing().getStatus() == ThingStatus.OFFLINE) {\n+                    return;\n+                }\n+                String msg = \"\";\n+                String cls = \"\";\n+                cls = error.getClass().getName();\n+                msg = error.getMessage();", "originalCommit": "1fe4a967869bb7203ec731025560cdf00805ff35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg4NDcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7718#discussion_r453884724", "bodyText": "Removed the initialization with the empty strings", "author": "pail23", "createdAt": "2020-07-13T19:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3MDk1Mg=="}], "type": "inlineReview"}, {"oid": "5b0281b11d675941b381d0b71d56e70820167424", "url": "https://github.com/openhab/openhab-addons/commit/5b0281b11d675941b381d0b71d56e70820167424", "message": "Initial Commit\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:55:47Z", "type": "commit"}, {"oid": "aa4d2c8f64db20fb2deb122d13d29e4fe1a689d6", "url": "https://github.com/openhab/openhab-addons/commit/aa4d2c8f64db20fb2deb122d13d29e4fe1a689d6", "message": "Update bundles/org.openhab.binding.modbus.stiebeleltron/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:55:58Z", "type": "commit"}, {"oid": "88c021a384f8c7d3f80aa2449b2007992ca3b2cc", "url": "https://github.com/openhab/openhab-addons/commit/88c021a384f8c7d3f80aa2449b2007992ca3b2cc", "message": "Update bundles/org.openhab.binding.modbus.stiebeleltron/src/main/resources/ESH-INF/config/config-descriptions.xml\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:55:58Z", "type": "commit"}, {"oid": "9f1804676841e278e7d38e48e11670bf92c64449", "url": "https://github.com/openhab/openhab-addons/commit/9f1804676841e278e7d38e48e11670bf92c64449", "message": "Update bundles/org.openhab.binding.modbus.stiebeleltron/src/main/resources/ESH-INF/config/config-descriptions.xml\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:55:58Z", "type": "commit"}, {"oid": "6493eea4dc4035953f83f5fd424d0b3843e22e2f", "url": "https://github.com/openhab/openhab-addons/commit/6493eea4dc4035953f83f5fd424d0b3843e22e2f", "message": "fix review finding\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:21Z", "type": "commit"}, {"oid": "b2f08c4c93f79953b38b18e69f21a66aec37dbcc", "url": "https://github.com/openhab/openhab-addons/commit/b2f08c4c93f79953b38b18e69f21a66aec37dbcc", "message": "renamed THING_TYPE_SAMPLE\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:28Z", "type": "commit"}, {"oid": "9ad3c45c6d59bef7e196352c38d77c28af2776a8", "url": "https://github.com/openhab/openhab-addons/commit/9ad3c45c6d59bef7e196352c38d77c28af2776a8", "message": "fix remaining review comment\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:28Z", "type": "commit"}, {"oid": "696c6ba0ed9b45b3911504b7d201323a0a164289", "url": "https://github.com/openhab/openhab-addons/commit/696c6ba0ed9b45b3911504b7d201323a0a164289", "message": "removed warnings\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:28Z", "type": "commit"}, {"oid": "b69c402a54834c2d1e91753bdb5d9a91d25f78bb", "url": "https://github.com/openhab/openhab-addons/commit/b69c402a54834c2d1e91753bdb5d9a91d25f78bb", "message": "Added handling for REFRESH and changed exception\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:28Z", "type": "commit"}, {"oid": "9255cf2dd9962c104295fb47c95fa16f13bd42c6", "url": "https://github.com/openhab/openhab-addons/commit/9255cf2dd9962c104295fb47c95fa16f13bd42c6", "message": "Update bundles/org.openhab.binding.modbus.stiebeleltron/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:28Z", "type": "commit"}, {"oid": "95fbb82bab8907a568cd8c0583d97614a77b42f1", "url": "https://github.com/openhab/openhab-addons/commit/95fbb82bab8907a568cd8c0583d97614a77b42f1", "message": "Update bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/dto/SystemInformationBlock.java\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:29Z", "type": "commit"}, {"oid": "b7befb6f57e751f51d52f0bdd514614e51375159", "url": "https://github.com/openhab/openhab-addons/commit/b7befb6f57e751f51d52f0bdd514614e51375159", "message": "Update bundles/org.openhab.binding.modbus.stiebeleltron/src/main/java/org/openhab/binding/modbus/stiebeleltron/internal/handler/StiebelEltronHandler.java\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:29Z", "type": "commit"}, {"oid": "b8d80b481a47d36c034b26cac5d7f7bec6d0c4ce", "url": "https://github.com/openhab/openhab-addons/commit/b8d80b481a47d36c034b26cac5d7f7bec6d0c4ce", "message": "fixed review findings\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:29Z", "type": "commit"}, {"oid": "979016502f2acc1fc9bd619b99881297b71c52fa", "url": "https://github.com/openhab/openhab-addons/commit/979016502f2acc1fc9bd619b99881297b71c52fa", "message": "mvn spotless:apply\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:29Z", "type": "commit"}, {"oid": "f9528e38a573dc8357afdcca1809a64ff90558e1", "url": "https://github.com/openhab/openhab-addons/commit/f9528e38a573dc8357afdcca1809a64ff90558e1", "message": "rebased from upstream 2.5.x and upgraded 2.5.7\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:29Z", "type": "commit"}, {"oid": "9c7602088cadcf08023ec069400a75305939dfe5", "url": "https://github.com/openhab/openhab-addons/commit/9c7602088cadcf08023ec069400a75305939dfe5", "message": "Adapted to simplified modbus api\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:30Z", "type": "commit"}, {"oid": "1f48432c733a623cc420ddfbd15577a754611014", "url": "https://github.com/openhab/openhab-addons/commit/1f48432c733a623cc420ddfbd15577a754611014", "message": "fixes\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:30Z", "type": "commit"}, {"oid": "73f0e28287bb28833127abf82c9e84227e058fde", "url": "https://github.com/openhab/openhab-addons/commit/73f0e28287bb28833127abf82c9e84227e058fde", "message": "review findings\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T05:58:30Z", "type": "commit"}, {"oid": "875e04c66318b1bf052ea14a48ff7955f5519df9", "url": "https://github.com/openhab/openhab-addons/commit/875e04c66318b1bf052ea14a48ff7955f5519df9", "message": "update version\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T06:18:29Z", "type": "commit"}, {"oid": "c078020df7aa2085c432ffdfe007747c32389c66", "url": "https://github.com/openhab/openhab-addons/commit/c078020df7aa2085c432ffdfe007747c32389c66", "message": "updated documentation\n\nSigned-off-by: Paul Frank <pail@gmx.net>", "committedDate": "2020-08-27T06:30:00Z", "type": "commit"}]}