{"pr_number": 9347, "pr_title": "[MyQ] Initial commit of the MyQ binding for OH3", "pr_createdAt": "2020-12-12T17:20:17Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9347", "timeline": [{"oid": "60c6511faa1e1fcbd41f73e9e8958a14616a024b", "url": "https://github.com/openhab/openhab-addons/commit/60c6511faa1e1fcbd41f73e9e8958a14616a024b", "message": "remove whitespace\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2020-12-24T05:55:18Z", "type": "forcePushed"}, {"oid": "a07ac454f04e8480ca72705a8bcb520ff4db1d48", "url": "https://github.com/openhab/openhab-addons/commit/a07ac454f04e8480ca72705a8bcb520ff4db1d48", "message": "Signed-off-by: Dan Cunningham dan@digitaldan.com\n\nThis introduces a new MyQ binding for openHAB 3.x to replace the 1.x version mentioned in #6179. Feedback welcome.", "committedDate": "2020-12-26T05:09:25Z", "type": "forcePushed"}, {"oid": "b8d83d9fc9302866aeee3db0b32d99012d9a3a3d", "url": "https://github.com/openhab/openhab-addons/commit/b8d83d9fc9302866aeee3db0b32d99012d9a3a3d", "message": "This introduces a new MyQ binding for openHAB 3.x to replace the 1.x version mentioned in #6179. Feedback welcome.\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2020-12-26T06:17:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552942585", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "author": "fwolter", "createdAt": "2021-01-06T20:20:13Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.binding.myq.internal.handler.MyQGarageDoorHandler;\n+import org.openhab.binding.myq.internal.handler.MyQLampHandler;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MyQHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.myq\", service = ThingHandlerFactory.class)\n+public class MyQHandlerFactory extends BaseThingHandlerFactory {\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new ConcurrentHashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public MyQHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_ACCOUNT.equals(thingTypeUID)) {\n+            MyQDiscoveryService discoveryService = new MyQDiscoveryService();\n+            MyQAccountHandler accountHandler = new MyQAccountHandler((Bridge) thing, httpClient, discoveryService);\n+            discoveryServiceRegs.put(accountHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "originalCommit": "b5c229bfaec596e8fe209df3946faf55db8b6b9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwMjI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r553602248", "bodyText": "Thanks, but my discovery service does not need a reference to the bridge, rather the reverse.", "author": "digitaldan", "createdAt": "2021-01-07T21:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc2NzEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r556767132", "bodyText": "Why not make it vice versa via a callback? Then, you could use the ThingHandlerService, which would make the code more maintainable.", "author": "fwolter", "createdAt": "2021-01-13T19:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUxNzgyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557517821", "bodyText": "I looked at that, but it seemed to complicate things without any clear benefit. Right now the handlerFactory knows about the thingHandler and discoveryService and  the thingHandler also knows about the discoveryService, if i use a callback, then now the discoveryService has to know about the thingHandler as well, we now have all 3 of the classes knowing about each other which seems to be a circular dependency without a clear benefit.", "author": "digitaldan", "createdAt": "2021-01-14T16:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MzAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552943025", "bodyText": "Primitive types should be used where possible.\nIt's good practice to append the unit to the field name e.g. TIMEOUT_SEC.\nCan these be static final?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer normalRefreshInterval = 60;\n          \n          \n            \n                private Integer rapidRefreshInterval = 5;\n          \n          \n            \n                private int normalRefreshInterval = 60;\n          \n          \n            \n                private int rapidRefreshInterval = 5;", "author": "fwolter", "createdAt": "2021-01-06T20:21:17Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;", "originalCommit": "b5c229bfaec596e8fe209df3946faf55db8b6b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NTg1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552945855", "bodyText": "When using the ThingHandlerService, you could set a reference to the discovery service in ThingHandlerService.setThingHandler() to make it acccessible here.", "author": "fwolter", "createdAt": "2021-01-06T20:28:07Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshInterval = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, rapidRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        String id = device.serialNumber.toLowerCase();\n+                        for (Thing thing : getThing().getThings()) {\n+                            // support both upper and lower case serialIds\n+                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                                ThingHandler handler = thing.getHandler();\n+                                if (handler != null) {\n+                                    ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                                }\n+                                return;\n+                            }\n+                        }\n+                        // did not find a thing, add it to the inbox\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, getThing().getUID(), id);\n+                        discoveryService.deviceDiscovered(thingUID, getThing().getUID(), device.name);", "originalCommit": "b5c229bfaec596e8fe209df3946faf55db8b6b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NjQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552946448", "bodyText": "Are you logging the stack trace by intention?", "author": "fwolter", "createdAt": "2021-01-06T20:29:30Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshInterval = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, rapidRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        String id = device.serialNumber.toLowerCase();\n+                        for (Thing thing : getThing().getThings()) {\n+                            // support both upper and lower case serialIds\n+                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                                ThingHandler handler = thing.getHandler();\n+                                if (handler != null) {\n+                                    ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                                }\n+                                return;\n+                            }\n+                        }\n+                        // did not find a thing, add it to the inbox\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, getThing().getUID(), id);\n+                        discoveryService.deviceDiscovered(thingUID, getThing().getUID(), device.name);\n+                    }\n+                });\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private synchronized HttpResult sendRequest(String url, HttpMethod method, @Nullable String token,\n+            @Nullable ContentProvider content, @Nullable String contentType) throws InterruptedException {\n+        try {\n+            Request request = httpClient.newRequest(url).method(method)\n+                    .header(\"MyQApplicationId\", \"JVM/G9Nwih5BwKgNCjLxiFUQxQijAebyyg8QUHr7JOrP+tuPb8iHfRHKwTmDzHOu\")\n+                    .header(\"ApiVersion\", \"5.1\").header(\"BrandId\", \"2\").header(\"Culture\", \"en\").agent(userAgent)\n+                    .timeout(10, TimeUnit.SECONDS);\n+            if (token != null) {\n+                request = request.header(\"SecurityToken\", token);\n+            }\n+            if (content != null & contentType != null) {\n+                request = request.content(content, contentType);\n+            }\n+            // use asyc jetty as the API service will response with a 401 error when credentials are wrong,\n+            // but not a WWW-Authenticate header which causes Jetty to throw a generic execution exception which\n+            // prevents us from knowing the response code\n+            logger.trace(\"Sending {} to {}\", request.getMethod(), request.getURI());\n+            final CompletableFuture<HttpResult> futureResult = new CompletableFuture<>();\n+            request.send(new BufferingResponseListener() {\n+                @NonNullByDefault({})\n+                @Override\n+                public void onComplete(Result result) {\n+                    futureResult.complete(new HttpResult(result.getResponse().getStatus(), getContentAsString()));\n+                }\n+            });\n+            HttpResult result = futureResult.get();\n+            logger.trace(\"Account Response - status: {} content: {}\", result.responseCode, result.content);\n+            return result;\n+        } catch (ExecutionException e) {\n+            logger.debug(\"request failed\", e);", "originalCommit": "b5c229bfaec596e8fe209df3946faf55db8b6b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560072687", "bodyText": "If I see correctly this method does the (background) discovery of devices. So, it's better to move this into the discovery service. Then, you won't have a problem with the depdendencies of handler and discovery service either.", "author": "fwolter", "createdAt": "2021-01-19T10:29:03Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "originalCommit": "bddbad680c579f681166de9de5a4aa2f6f76bee9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM2NTg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560365863", "bodyText": "when i poll the API i get all devices, so every poll cycle (60 seconds default ) i have the opportunity to discover new devices. I assumed this would be more efficient than having to schedule a separate call to the bridge to do an additional poll just to discover devices, that seemed less efficient with more complexity.", "author": "digitaldan", "createdAt": "2021-01-19T17:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM4NDgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560384810", "bodyText": "Maybe the API has the ability to query only the state of one devices at a time? If not, I would do a discovery only if the user triggered a scan. That would reduce overall code complexity.", "author": "fwolter", "createdAt": "2021-01-19T18:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM5OTQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560399409", "bodyText": "Its' a single api call that i'm using, the API is not documented and heavily rate limited, its not clear even if there is a single device endpoint (which i have not seen), if you had more then one, how that would blow through the rate limiting polling for each.  FYI i have a 2 bay garage, so i have 2 units under the same account.\n\nThat would reduce overall code complexity.\n\nI'm all for reducing complexity, but i'm not sure i see that happening, we would have the same discovery code that exists, PLUS i would need to add additional methods to call the same poll code, but this time not to update devices, just for discovery,  its going to be more code, additional coordination of outgoing requests and much more complex IMHO.", "author": "digitaldan", "createdAt": "2021-01-19T18:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzMzI2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r561133263", "bodyText": "It's reasonable to make one request for all devices due to the rate limit. Nevertheless, the discovery service could make its own request as it is not triggered permanently. This way you could cut off the counter intuitive reverse dependency of bridge handler and discovery service and you can implement the ThingHandlerService. Of course you could make getDevices() stateless and reuseable to use it in the bridge handler and the discovery service.", "author": "fwolter", "createdAt": "2021-01-20T17:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQxMjUyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562412527", "bodyText": "Hi @fwolter  i have refactored the discover class to use the ThingHandlerService .  I did not realize this removed the need for all the boiler plate code in the handler factory to create, track and destroy the discovery service, so i agree this was worth the refactoring.", "author": "digitaldan", "createdAt": "2021-01-22T06:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE2MTU3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563161577", "bodyText": "Great!", "author": "fwolter", "createdAt": "2021-01-23T14:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MDA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562580054", "bodyText": "You're using the id as a unique identifier.  However the convention is that the user can give it any name allowed. So it should not be used as identifier. You should check here on the property serialNumber.", "author": "Hilbrand", "createdAt": "2021-01-22T11:50:50Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -107,6 +109,24 @@ public void dispose() {\n         stopPolls();\n     }\n \n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> childHandler.getThing().getUID().getId().equalsIgnoreCase(d.serialNumber)).findFirst()", "originalCommit": "552b0f45cf19218af421fcabb93f4d8e4e012e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2ODEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562768102", "bodyText": "Good catch !", "author": "digitaldan", "createdAt": "2021-01-22T16:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MDA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562776484", "bodyText": "In general it's not recommend to get the configuration everytime. I would suggest to make a method getSerialNumber() on the handler and also use equalsIgnoreCase. Something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n          \n          \n            \n                                                .equals(deviceSerial)) {\n          \n          \n            \n                                        if (((MyQDeviceHandler) thing.getHandler()).getSerialNumber().equalsIgnoreCase(deviceSerial)) {", "author": "Hilbrand", "createdAt": "2021-01-22T17:08:59Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -267,10 +269,11 @@ private void getDevices() throws InterruptedException {\n                 devices.items.forEach(device -> {\n                     ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n                     if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n-                        String id = device.serialNumber.toLowerCase();\n+                        String deviceSerial = device.serialNumber.toLowerCase();\n                         for (Thing thing : getThing().getThings()) {\n                             // support both upper and lower case serialIds\n-                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                            if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n+                                    .equals(deviceSerial)) {", "originalCommit": "c497131432b338000225deb426ef06c0ee54bd6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5MzA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562793070", "bodyText": "In general it's not recommend to get the configuration everytime.\n\nYep agreed\n\non the handler and also use equalsIgnoreCase\n\nyeah, i'm not sure what i was thinking there", "author": "digitaldan", "createdAt": "2021-01-22T17:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxNTY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562815683", "bodyText": "done!", "author": "digitaldan", "createdAt": "2021-01-22T18:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA=="}], "type": "inlineReview"}, {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "url": "https://github.com/openhab/openhab-addons/commit/7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "message": "Rebase with main, update license headers\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-01-23T16:27:17Z", "type": "commit"}, {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "url": "https://github.com/openhab/openhab-addons/commit/7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "message": "Rebase with main, update license headers\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-01-23T16:27:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyNzg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563927879", "bodyText": "Unchecked exceptions don't need to be declared in throws.", "author": "fwolter", "createdAt": "2021-01-25T17:57:15Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {", "originalCommit": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563928086", "bodyText": "Please move fields to the top of the class.", "author": "fwolter", "createdAt": "2021-01-25T17:57:26Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_DISCOVERY_THING_TYPES_UIDS, 1, true);\n+    }\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_DISCOVERY_THING_TYPES_UIDS = Set\n+            .of(MyQBindingConstants.THING_TYPE_GARAGEDOOR, MyQBindingConstants.THING_TYPE_LAMP);\n+\n+    private @Nullable MyQAccountHandler accountHandler;", "originalCommit": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563928860", "bodyText": "There's a predefined constant for the serial number.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            .withProperty(\"serialNumber\", thingUID.getId())\n          \n          \n            \n                                            .withProperty(Thing.PROPERTY_SERIAL_NUMBER, thingUID.getId())", "author": "fwolter", "createdAt": "2021-01-25T17:58:14Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_DISCOVERY_THING_TYPES_UIDS, 1, true);\n+    }\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_DISCOVERY_THING_TYPES_UIDS = Set\n+            .of(MyQBindingConstants.THING_TYPE_GARAGEDOOR, MyQBindingConstants.THING_TYPE_LAMP);\n+\n+    private @Nullable MyQAccountHandler accountHandler;\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_DISCOVERY_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        MyQAccountHandler accountHandler = this.accountHandler;\n+        if (accountHandler != null) {\n+            DevicesDTO devices = accountHandler.devicesCache();\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, accountHandler.getThing().getUID(),\n+                                device.serialNumber.toLowerCase());\n+                        DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(\"MyQ \" + device.name)\n+                                .withProperty(\"serialNumber\", thingUID.getId())", "originalCommit": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563932011", "bodyText": "The child handler can be of different type if the user made a mistake in the textual configuration. And syntactical sugar:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localDeviceCaches != null) {\n          \n          \n            \n                        DeviceDTO device = localDeviceCaches.items.stream()\n          \n          \n            \n                                .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n          \n          \n            \n                                .findFirst().orElse(null);\n          \n          \n            \n                        if (device != null) {\n          \n          \n            \n                            ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n          \n          \n            \n                        }\n          \n          \n            \n                    if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n          \n          \n            \n                        MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n          \n          \n            \n                        localDeviceCaches.items.stream()\n          \n          \n            \n                                .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n          \n          \n            \n                                .findFirst().ifPresent(handler::handleDeviceUpdate);", "author": "fwolter", "createdAt": "2021-01-25T18:03:17Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }", "originalCommit": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDM3NzkwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r564377903", "bodyText": "Did you see the syntactical sugar in my suggestion?", "author": "fwolter", "createdAt": "2021-01-26T09:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzI5Njg3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r567296876", "bodyText": "I did not, thanks for the hint", "author": "digitaldan", "createdAt": "2021-01-30T18:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMzY1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563933657", "bodyText": "This seems the same code as in line 126. Can you make it re-useable?", "author": "fwolter", "createdAt": "2021-01-25T18:06:03Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }", "originalCommit": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxMzU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r564013568", "bodyText": "it looks similar, but different enough that i prefer to keep it the way it is", "author": "digitaldan", "createdAt": "2021-01-25T20:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMzY1Nw=="}], "type": "inlineReview"}, {"oid": "91b6ef130c28d176cb9d33653a01b9c053142d36", "url": "https://github.com/openhab/openhab-addons/commit/91b6ef130c28d176cb9d33653a01b9c053142d36", "message": "Small PR cleanups\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-01-25T20:09:47Z", "type": "commit"}, {"oid": "44ab5f44c3abb7d3c2ec57944b39fef091f31f56", "url": "https://github.com/openhab/openhab-addons/commit/44ab5f44c3abb7d3c2ec57944b39fef091f31f56", "message": "One last small PR cleanup\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-01-25T20:11:38Z", "type": "commit"}, {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d", "url": "https://github.com/openhab/openhab-addons/commit/37eb721dd5eaa1316fcdf433de624cb1c060450d", "message": "Syntactical sugar\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-01-30T18:38:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4Nzk0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r569987943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer sb = new StringBuffer(length);\n          \n          \n            \n                    StringBuilder sb = new StringBuilder(length);", "author": "cpmeister", "createdAt": "2021-02-04T07:01:23Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private synchronized HttpResult sendRequest(String url, HttpMethod method, @Nullable String token,\n+            @Nullable ContentProvider content, @Nullable String contentType) throws InterruptedException {\n+        try {\n+            Request request = httpClient.newRequest(url).method(method)\n+                    .header(\"MyQApplicationId\", \"JVM/G9Nwih5BwKgNCjLxiFUQxQijAebyyg8QUHr7JOrP+tuPb8iHfRHKwTmDzHOu\")\n+                    .header(\"ApiVersion\", \"5.1\").header(\"BrandId\", \"2\").header(\"Culture\", \"en\").agent(userAgent)\n+                    .timeout(10, TimeUnit.SECONDS);\n+            if (token != null) {\n+                request = request.header(\"SecurityToken\", token);\n+            }\n+            if (content != null & contentType != null) {\n+                request = request.content(content, contentType);\n+            }\n+            // use asyc jetty as the API service will response with a 401 error when credentials are wrong,\n+            // but not a WWW-Authenticate header which causes Jetty to throw a generic execution exception which\n+            // prevents us from knowing the response code\n+            logger.trace(\"Sending {} to {}\", request.getMethod(), request.getURI());\n+            final CompletableFuture<HttpResult> futureResult = new CompletableFuture<>();\n+            request.send(new BufferingResponseListener() {\n+                @NonNullByDefault({})\n+                @Override\n+                public void onComplete(Result result) {\n+                    futureResult.complete(new HttpResult(result.getResponse().getStatus(), getContentAsString()));\n+                }\n+            });\n+            HttpResult result = futureResult.get();\n+            logger.trace(\"Account Response - status: {} content: {}\", result.responseCode, result.content);\n+            return result;\n+        } catch (ExecutionException e) {\n+            return new HttpResult(0, e.getMessage());\n+        }\n+    }\n+\n+    private void handleErrorResponse(HttpResult result) {\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            return;\n+        }\n+        if (result.responseCode == HttpStatus.UNAUTHORIZED_401) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Unauthorized - Check Credentials\");\n+            securityToken = null;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Invalid Response \" + result.content);\n+        }\n+    }\n+\n+    public static class HttpResult {\n+        public final int responseCode;\n+        public @Nullable String content;\n+\n+        public HttpResult(int responseCode, @Nullable String content) {\n+            this.responseCode = responseCode;\n+            this.content = content;\n+        }\n+    }\n+\n+    private static String randomString(int length) {\n+        int low = 97; // a-z\n+        int high = 122; // A-Z\n+        StringBuffer sb = new StringBuffer(length);", "originalCommit": "37eb721dd5eaa1316fcdf433de624cb1c060450d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4ODM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r569988369", "bodyText": "You should catch the JsonSyntaxException that is thrown here.", "author": "cpmeister", "createdAt": "2021-02-04T07:02:39Z", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);", "originalCommit": "37eb721dd5eaa1316fcdf433de624cb1c060450d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyNjI3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r576426271", "bodyText": "Done.", "author": "digitaldan", "createdAt": "2021-02-15T21:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4ODM2OQ=="}], "type": "inlineReview"}, {"oid": "91d947fe61764299806e2217d9cb16b180e8d124", "url": "https://github.com/openhab/openhab-addons/commit/91d947fe61764299806e2217d9cb16b180e8d124", "message": "Updated error handling\n\nSigned-off-by: Dan <dan@MacBook-Pro.digitaldan.com>", "committedDate": "2021-02-15T21:15:29Z", "type": "commit"}, {"oid": "483f62de83c7e0b6a59ff7aa113f011a034c716b", "url": "https://github.com/openhab/openhab-addons/commit/483f62de83c7e0b6a59ff7aa113f011a034c716b", "message": "Spelling mistake\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-02-20T18:57:30Z", "type": "commit"}, {"oid": "483f62de83c7e0b6a59ff7aa113f011a034c716b", "url": "https://github.com/openhab/openhab-addons/commit/483f62de83c7e0b6a59ff7aa113f011a034c716b", "message": "Spelling mistake\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>", "committedDate": "2021-02-20T18:57:30Z", "type": "forcePushed"}]}