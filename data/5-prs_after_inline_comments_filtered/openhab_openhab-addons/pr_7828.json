{"pr_number": 7828, "pr_title": "[deconz] Add support for ZHAThermostat", "pr_createdAt": "2020-05-31T21:46:51Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7828", "timeline": [{"oid": "64c83c0da49807b3847503fbc4b0cf7cd87155b6", "url": "https://github.com/openhab/openhab-addons/commit/64c83c0da49807b3847503fbc4b0cf7cd87155b6", "message": "[deconz] Add support for ZHAThermostat\n\nAdds support for Zigbee Thermostat based on Eurotronics Spirit\nCloses #6251\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-05-31T21:29:00Z", "type": "commit"}, {"oid": "32b52ed57a442ef707ce1d659ac123692c2cdc7f", "url": "https://github.com/openhab/openhab-addons/commit/32b52ed57a442ef707ce1d659ac123692c2cdc7f", "message": "[deconz] Add support for ZHAThermostat\n\nAdds support for Zigbee Thermostat based on Eurotronics Spirit\nCloses #6251\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-05-31T21:41:31Z", "type": "commit"}, {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "url": "https://github.com/openhab/openhab-addons/commit/163360f1d1bccc8e1eb942c5d477151a5adfeffb", "message": "Merge branch 'deconz' of https://github.com/LukasA83/openhab-addons.git into HEAD", "committedDate": "2020-05-31T21:43:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMjc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433302787", "bodyText": "Wouldn't it make sense to check if the command string is allowed? You could define a Set<String> with the allowed values as a constant and check if the command string is contained in that set. I know that the deconz software is a bit strange with sending wrong commands (at least for lights).", "author": "J-N-K", "createdAt": "2020-06-01T15:27:00Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        SensorConfig newConfig = new SensorConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                BigDecimal newTemperature;\n+                if (command instanceof DecimalType) {\n+                    newTemperature = ((DecimalType) command).toBigDecimal();\n+                } else if (command instanceof QuantityType) {\n+                    newTemperature = ((QuantityType) command).toUnit(CELSIUS).toBigDecimal();\n+                } else {\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newTemperature.scaleByPowerOfTen(2).intValue();\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    newConfig.mode = ((StringType) command).toString();", "originalCommit": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMjczMw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433912733", "bodyText": "Makes sense. Added enum accordingly.", "author": "LukasA83", "createdAt": "2020-06-02T14:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMjc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzMTQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433331432", "bodyText": "Are there Xiaomi Theromstats which have an optional temperature channel?", "author": "J-N-K", "createdAt": "2020-06-01T15:58:44Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        SensorConfig newConfig = new SensorConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                BigDecimal newTemperature;\n+                if (command instanceof DecimalType) {\n+                    newTemperature = ((DecimalType) command).toBigDecimal();\n+                } else if (command instanceof QuantityType) {\n+                    newTemperature = ((QuantityType) command).toUnit(CELSIUS).toBigDecimal();\n+                } else {\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newTemperature.scaleByPowerOfTen(2).intValue();\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    newConfig.mode = ((StringType) command).toString();\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"sensors\", config.id,\n+                \"config\");\n+\n+        String json = gson.toJson(newConfig);\n+        logger.trace(\"Sending {} to sensor {} via {}\", json, config.id, url);\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        super.valueUpdated(channelUID, newConfig);\n+        String mode = newConfig.mode;\n+        String channelID = channelUID.getId();\n+        switch (channelID) {\n+            case CHANNEL_HEATSETPOINT:\n+                updateQuantityTypeChannel(channelID, newConfig.heatsetpoint, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                updateDecimalTypeChannel(channelID, newConfig.offset);\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (mode != null) {\n+                    updateState(channelUID, new StringType(mode));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        super.valueUpdated(channelID, newState, initializing);\n+        switch (channelID) {\n+            case CHANNEL_TEMPERATURE:\n+                updateQuantityTypeChannel(channelID, newState.temperature, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_VALVE_POSITION:\n+                updateQuantityTypeChannel(channelID, newState.valve, PERCENT, 100.0 / 255);\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {\n+        // some Xiaomi sensors\n+        if (sensorConfig.temperature != null || sensorState.temperature != null) {", "originalCommit": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMzk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433913941", "bodyText": "Removed.", "author": "LukasA83", "createdAt": "2020-06-02T14:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzMTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzMTY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433331693", "bodyText": "Isn't that a mandatory channel on a theromstat? Also below", "author": "J-N-K", "createdAt": "2020-06-01T15:59:12Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        SensorConfig newConfig = new SensorConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                BigDecimal newTemperature;\n+                if (command instanceof DecimalType) {\n+                    newTemperature = ((DecimalType) command).toBigDecimal();\n+                } else if (command instanceof QuantityType) {\n+                    newTemperature = ((QuantityType) command).toUnit(CELSIUS).toBigDecimal();\n+                } else {\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newTemperature.scaleByPowerOfTen(2).intValue();\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    newConfig.mode = ((StringType) command).toString();\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"sensors\", config.id,\n+                \"config\");\n+\n+        String json = gson.toJson(newConfig);\n+        logger.trace(\"Sending {} to sensor {} via {}\", json, config.id, url);\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        super.valueUpdated(channelUID, newConfig);\n+        String mode = newConfig.mode;\n+        String channelID = channelUID.getId();\n+        switch (channelID) {\n+            case CHANNEL_HEATSETPOINT:\n+                updateQuantityTypeChannel(channelID, newConfig.heatsetpoint, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                updateDecimalTypeChannel(channelID, newConfig.offset);\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (mode != null) {\n+                    updateState(channelUID, new StringType(mode));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        super.valueUpdated(channelID, newState, initializing);\n+        switch (channelID) {\n+            case CHANNEL_TEMPERATURE:\n+                updateQuantityTypeChannel(channelID, newState.temperature, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_VALVE_POSITION:\n+                updateQuantityTypeChannel(channelID, newState.valve, PERCENT, 100.0 / 255);\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {\n+        // some Xiaomi sensors\n+        if (sensorConfig.temperature != null || sensorState.temperature != null) {\n+            createChannel(CHANNEL_TEMPERATURE, ChannelKind.STATE);\n+        }\n+\n+        // (Eurotronics) Thermostat\n+        if (sensorState.valve != null) {\n+            createChannel(CHANNEL_VALVE_POSITION, ChannelKind.STATE);\n+        }\n+\n+        if (sensorConfig.heatsetpoint != null) {\n+            createChannel(CHANNEL_HEATSETPOINT, ChannelKind.STATE);", "originalCommit": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMzk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433913996", "bodyText": "Removed.", "author": "LukasA83", "createdAt": "2020-06-02T14:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzMTY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNDAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433334035", "bodyText": "Is this really meant to be called from outside? I don't think so.protected would be better. Also JavaDoc is missing", "author": "J-N-K", "createdAt": "2020-06-01T16:03:14Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorBaseThingHandler.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Every sensor and switch is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author David Graeff - Initial contribution\n+ * @author Lukas Agethen - Refactored to provide better extensibility\n+ */\n+@NonNullByDefault\n+public abstract class SensorBaseThingHandler extends DeconzBaseThingHandler<SensorMessage> {\n+    private final Logger logger = LoggerFactory.getLogger(SensorBaseThingHandler.class);\n+    /**\n+     * The sensor state. Contains all possible fields for all supported sensors and switches\n+     */\n+    protected SensorConfig sensorConfig = new SensorConfig();\n+    protected SensorState sensorState = new SensorState();\n+    /**\n+     * Prevent a dispose/init cycle while this flag is set. Use for property updates\n+     */\n+    private boolean ignoreConfigurationUpdate;\n+\n+    public SensorBaseThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"sensors\");\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerSensorListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterSensorListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    public abstract void handleCommand(ChannelUID channelUID, Command command);\n+\n+    protected abstract void createTypeSpecificChannels(SensorConfig sensorState, SensorState sensorConfig);\n+\n+    protected abstract List<String> getConfigChannels();\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!ignoreConfigurationUpdate) {\n+            super.handleConfigurationUpdate(configurationParameters);\n+        }\n+    }\n+\n+    @Override\n+    protected @Nullable SensorMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), SensorMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable SensorMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        SensorConfig newSensorConfig = stateResponse.config;\n+        sensorConfig = newSensorConfig != null ? newSensorConfig : new SensorConfig();\n+        SensorState newSensorState = stateResponse.state;\n+        sensorState = newSensorState != null ? newSensorState : new SensorState();\n+\n+        // Add some information about the sensor\n+        if (!sensorConfig.reachable) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE, \"Not reachable\");\n+            return;\n+        }\n+\n+        if (!sensorConfig.on) {\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        Map<String, String> editProperties = editProperties();\n+        editProperties.put(Thing.PROPERTY_FIRMWARE_VERSION, stateResponse.swversion);\n+        editProperties.put(Thing.PROPERTY_MODEL_ID, stateResponse.modelid);\n+        editProperties.put(UNIQUE_ID, stateResponse.uniqueid);\n+        ignoreConfigurationUpdate = true;\n+        updateProperties(editProperties);\n+\n+        // Some sensors support optional channels\n+        // (see https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices#sensors)\n+        // any battery-powered sensor\n+        if (sensorConfig.battery != null) {\n+            createChannel(CHANNEL_BATTERY_LEVEL, ChannelKind.STATE);\n+            createChannel(CHANNEL_BATTERY_LOW, ChannelKind.STATE);\n+        }\n+\n+        createTypeSpecificChannels(sensorConfig, sensorState);\n+\n+        ignoreConfigurationUpdate = false;\n+\n+        // Initial data\n+        updateChannels(sensorConfig);\n+        updateChannels(sensorState, true);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    protected void createChannel(String channelId, ChannelKind kind) {\n+        ThingHandlerCallback callback = getCallback();\n+        if (callback != null) {\n+            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            ChannelTypeUID channelTypeUID;\n+            switch (channelId) {\n+                case CHANNEL_BATTERY_LEVEL:\n+                    channelTypeUID = new ChannelTypeUID(\"system:battery-level\");\n+                    break;\n+                case CHANNEL_BATTERY_LOW:\n+                    channelTypeUID = new ChannelTypeUID(\"system:low-battery\");\n+                    break;\n+                default:\n+                    channelTypeUID = new ChannelTypeUID(BINDING_ID, channelId);\n+                    break;\n+            }\n+            Channel channel = callback.createChannelBuilder(channelUID, channelTypeUID).withKind(kind).build();\n+            updateThing(editThing().withoutChannel(channelUID).withChannel(channel).build());\n+        }\n+    }\n+\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {", "originalCommit": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433918669", "bodyText": "Changed and added JavaDoc...", "author": "LukasA83", "createdAt": "2020-06-02T14:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNTUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433335512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                        default:\n          \n          \n            \n                            // other cases covered by sub-class\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nFor code readability", "author": "J-N-K", "createdAt": "2020-06-01T16:06:00Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorBaseThingHandler.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Every sensor and switch is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author David Graeff - Initial contribution\n+ * @author Lukas Agethen - Refactored to provide better extensibility\n+ */\n+@NonNullByDefault\n+public abstract class SensorBaseThingHandler extends DeconzBaseThingHandler<SensorMessage> {\n+    private final Logger logger = LoggerFactory.getLogger(SensorBaseThingHandler.class);\n+    /**\n+     * The sensor state. Contains all possible fields for all supported sensors and switches\n+     */\n+    protected SensorConfig sensorConfig = new SensorConfig();\n+    protected SensorState sensorState = new SensorState();\n+    /**\n+     * Prevent a dispose/init cycle while this flag is set. Use for property updates\n+     */\n+    private boolean ignoreConfigurationUpdate;\n+\n+    public SensorBaseThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"sensors\");\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerSensorListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterSensorListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    public abstract void handleCommand(ChannelUID channelUID, Command command);\n+\n+    protected abstract void createTypeSpecificChannels(SensorConfig sensorState, SensorState sensorConfig);\n+\n+    protected abstract List<String> getConfigChannels();\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!ignoreConfigurationUpdate) {\n+            super.handleConfigurationUpdate(configurationParameters);\n+        }\n+    }\n+\n+    @Override\n+    protected @Nullable SensorMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), SensorMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable SensorMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        SensorConfig newSensorConfig = stateResponse.config;\n+        sensorConfig = newSensorConfig != null ? newSensorConfig : new SensorConfig();\n+        SensorState newSensorState = stateResponse.state;\n+        sensorState = newSensorState != null ? newSensorState : new SensorState();\n+\n+        // Add some information about the sensor\n+        if (!sensorConfig.reachable) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE, \"Not reachable\");\n+            return;\n+        }\n+\n+        if (!sensorConfig.on) {\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        Map<String, String> editProperties = editProperties();\n+        editProperties.put(Thing.PROPERTY_FIRMWARE_VERSION, stateResponse.swversion);\n+        editProperties.put(Thing.PROPERTY_MODEL_ID, stateResponse.modelid);\n+        editProperties.put(UNIQUE_ID, stateResponse.uniqueid);\n+        ignoreConfigurationUpdate = true;\n+        updateProperties(editProperties);\n+\n+        // Some sensors support optional channels\n+        // (see https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices#sensors)\n+        // any battery-powered sensor\n+        if (sensorConfig.battery != null) {\n+            createChannel(CHANNEL_BATTERY_LEVEL, ChannelKind.STATE);\n+            createChannel(CHANNEL_BATTERY_LOW, ChannelKind.STATE);\n+        }\n+\n+        createTypeSpecificChannels(sensorConfig, sensorState);\n+\n+        ignoreConfigurationUpdate = false;\n+\n+        // Initial data\n+        updateChannels(sensorConfig);\n+        updateChannels(sensorState, true);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    protected void createChannel(String channelId, ChannelKind kind) {\n+        ThingHandlerCallback callback = getCallback();\n+        if (callback != null) {\n+            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            ChannelTypeUID channelTypeUID;\n+            switch (channelId) {\n+                case CHANNEL_BATTERY_LEVEL:\n+                    channelTypeUID = new ChannelTypeUID(\"system:battery-level\");\n+                    break;\n+                case CHANNEL_BATTERY_LOW:\n+                    channelTypeUID = new ChannelTypeUID(\"system:low-battery\");\n+                    break;\n+                default:\n+                    channelTypeUID = new ChannelTypeUID(BINDING_ID, channelId);\n+                    break;\n+            }\n+            Channel channel = callback.createChannelBuilder(channelUID, channelTypeUID).withKind(kind).build();\n+            updateThing(editThing().withoutChannel(channelUID).withChannel(channel).build());\n+        }\n+    }\n+\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        Integer batteryLevel = newConfig.battery;\n+        switch (channelUID.getId()) {\n+            case CHANNEL_BATTERY_LEVEL:\n+                if (batteryLevel != null) {\n+                    updateState(channelUID, new DecimalType(batteryLevel.longValue()));\n+                }\n+                break;\n+            case CHANNEL_BATTERY_LOW:\n+                if (batteryLevel != null) {\n+                    updateState(channelUID, OnOffType.from(batteryLevel <= 10));\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        switch (channelID) {\n+            case CHANNEL_LAST_UPDATED:\n+                String lastUpdated = newState.lastupdated;\n+                if (lastUpdated != null && !\"none\".equals(lastUpdated)) {\n+                    updateState(channelID,\n+                            new DateTimeType(ZonedDateTime.ofInstant(\n+                                    LocalDateTime.parse(lastUpdated, DateTimeFormatter.ISO_LOCAL_DATE_TIME),\n+                                    ZoneOffset.UTC, ZoneId.systemDefault())));\n+                }\n+                break;\n+        }", "originalCommit": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433918823", "bodyText": "Added", "author": "LukasA83", "createdAt": "2020-06-02T14:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNTUxMg=="}], "type": "inlineReview"}, {"oid": "0ca41cbe246a332af7a2061c33576b9b38039793", "url": "https://github.com/openhab/openhab-addons/commit/0ca41cbe246a332af7a2061c33576b9b38039793", "message": "Refactored based on suggestions\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-06-02T14:33:32Z", "type": "commit"}, {"oid": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50", "url": "https://github.com/openhab/openhab-addons/commit/44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50", "message": "Fixed logging if update is not confirmed by \"success\" object\n\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-06-02T14:59:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4OTM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433989386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_THERMOSTAT);", "author": "J-N-K", "createdAt": "2020-06-02T15:56:47Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.dto.ThermostatConfig;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.types.ThermostatMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));", "originalCommit": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2NzIxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r434067212", "bodyText": "Done", "author": "LukasA83", "createdAt": "2020-06-02T17:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4OTM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MTExOA==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433991118", "bodyText": "remove if not needed", "author": "J-N-K", "createdAt": "2020-06-02T15:58:30Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.dto.ThermostatConfig;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.types.ThermostatMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        ThermostatConfig newConfig = new ThermostatConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                Integer newHeatsetpoint = getTemperatureFromCommand(command);\n+                if (newHeatsetpoint == null) {\n+                    logger.warn(\"Heatsetpoint must not be null.\");\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newHeatsetpoint;\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                Integer newOffset = getTemperatureFromCommand(command);\n+                if (newOffset == null) {\n+                    logger.warn(\"Offset must not be null.\");\n+                    return;\n+                }\n+                newConfig.offset = newOffset;\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    String thermostatMode = ((StringType) command).toString();\n+                    try {\n+                        newConfig.mode = ThermostatMode.valueOf(thermostatMode);\n+                    } catch (IllegalArgumentException ex) {\n+                        logger.warn(\"Invalid thermostat mode: {}. Valid values: {}\", thermostatMode,\n+                                ThermostatMode.values());\n+                        return;\n+                    }\n+                    if (newConfig.mode == ThermostatMode.UNKNOWN) {\n+                        logger.warn(\"Invalid thermostat mode: {}. Valid values: {}\", thermostatMode,\n+                                ThermostatMode.values());\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"sensors\", config.id,\n+                \"config\");\n+\n+        String json = gson.toJson(newConfig);\n+        logger.trace(\"Sending {} to sensor {} via {}\", json, config.id, url);\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            String bodyContent = v.getBody();\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), bodyContent);\n+            if (!bodyContent.contains(\"success\")) {\n+                logger.debug(\"Sending command {} to channel {} failed: {}\", command, channelUID, bodyContent);\n+            }\n+\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        super.valueUpdated(channelUID, newConfig);\n+        String mode = newConfig.mode != null ? newConfig.mode.name() : ThermostatMode.UNKNOWN.name();\n+        String channelID = channelUID.getId();\n+        switch (channelID) {\n+            case CHANNEL_HEATSETPOINT:\n+                updateQuantityTypeChannel(channelID, newConfig.heatsetpoint, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                updateQuantityTypeChannel(channelID, newConfig.offset, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (mode != null) {\n+                    updateState(channelUID, new StringType(mode));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        super.valueUpdated(channelID, newState, initializing);\n+        switch (channelID) {\n+            case CHANNEL_TEMPERATURE:\n+                updateQuantityTypeChannel(channelID, newState.temperature, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_VALVE_POSITION:\n+                updateQuantityTypeChannel(channelID, newState.valve, PERCENT, 100.0 / 255);\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {\n+        /*", "originalCommit": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2NzExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r434067116", "bodyText": "Done", "author": "LukasA83", "createdAt": "2020-06-02T17:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MTExOA=="}], "type": "inlineReview"}, {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81", "url": "https://github.com/openhab/openhab-addons/commit/c852d95311e3ddb133070e5b8c37b378975d7a81", "message": "Clean-up\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-06-02T17:58:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5NDkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r434094906", "bodyText": "Do you need to override this method at all?", "author": "J-N-K", "createdAt": "2020-06-02T18:32:53Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -181,29 +178,6 @@ protected void valueUpdated(String channelID, SensorState newState, boolean init\n \n     @Override\n     protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {", "originalCommit": "c852d95311e3ddb133070e5b8c37b378975d7a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5NTQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r434095417", "bodyText": "Yes, it is abstract in base class, needs to be implemented.", "author": "LukasA83", "createdAt": "2020-06-02T18:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5NDkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435696386", "bodyText": "Maybe add @NonNullByDefault?", "author": "cpmeister", "createdAt": "2020-06-05T05:24:26Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/types/ThermostatModeGsonTypeAdapter.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.types;\n+\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ * Custom (de)serializer for {@link ThermostatMode}\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+public class ThermostatModeGsonTypeAdapter implements JsonDeserializer<ThermostatMode>, JsonSerializer<ThermostatMode> {", "originalCommit": "c852d95311e3ddb133070e5b8c37b378975d7a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMjc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435832784", "bodyText": "Doesn't make sense here from my perspective, but maybe I'm wrong.", "author": "LukasA83", "createdAt": "2020-06-05T10:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435766496", "bodyText": "Why SensorConfig extends ThermostatConfig. Shouldn't this be the other way around because ThermostatConfig is the more specific class?", "author": "DerOetzi", "createdAt": "2020-06-05T08:24:42Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/dto/SensorConfig.java", "diffHunk": "@@ -23,9 +23,10 @@\n  * https://dresden-elektronik.github.io/deconz-rest-doc/sensors/.\n  *\n  * @author David Graeff - Initial contribution\n+ * @author Lukas Agethen - Add Thermostat parameters\n  */\n @NonNullByDefault\n-public class SensorConfig {\n+public class SensorConfig extends ThermostatConfig {", "originalCommit": "c852d95311e3ddb133070e5b8c37b378975d7a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzNDU4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435834587", "bodyText": "I believe it is a matter of perspective. ThermostatConfig is used to send updates to deconz API and therefore it is just providing the specific parameters (otherwise the update fails).\nReceiving information from the websocket service is providing all parameters, therefore I believe this is a practical solution.", "author": "LukasA83", "createdAt": "2020-06-05T10:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435844385", "bodyText": "I believe this is not a matter of perspective, but it is confusing for developers who will look on this in a few weeks or month. And it will be getting even more worse if there is coming up another specific sensors later on so you will maybe get problems with multiple inheritance from specific class. For example maybe there will be a zigbee watervalve for the garden, having several config attributes and one will be valve you will get into trouble with your inheritance pattern. In my personal opinion inhertiance from specific to general class is an anti-pattern for this reason.", "author": "DerOetzi", "createdAt": "2020-06-05T10:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyMTAwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r436021007", "bodyText": "Removed inheritance. No need to make it to scientific.", "author": "LukasA83", "createdAt": "2020-06-05T16:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjQ5Ng=="}], "type": "inlineReview"}, {"oid": "88dd1579896aadd58c64ef9f5557116b4361a2b6", "url": "https://github.com/openhab/openhab-addons/commit/88dd1579896aadd58c64ef9f5557116b4361a2b6", "message": "Minor refactoring\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-06-05T16:08:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1ODg3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r436158877", "bodyText": "Are you sure that passing null to JsonPrimitive is valid? Looking at https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonPrimitive.java#L60 it checks null and throws an NPE if the value is null.", "author": "J-N-K", "createdAt": "2020-06-05T20:52:25Z", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/types/ThermostatModeGsonTypeAdapter.java", "diffHunk": "@@ -27,17 +30,22 @@\n  *\n  * @author Lukas Agethen - Initial contribution\n  */\n+@NonNullByDefault\n public class ThermostatModeGsonTypeAdapter implements JsonDeserializer<ThermostatMode>, JsonSerializer<ThermostatMode> {\n     @Override\n-    public ThermostatMode deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-            throws JsonParseException {\n-        String s = json.getAsString();\n-        return s == null ? ThermostatMode.UNKNOWN : ThermostatMode.fromString(s);\n+    public ThermostatMode deserialize(@Nullable JsonElement json, @Nullable Type typeOfT,\n+            @Nullable JsonDeserializationContext context) throws JsonParseException {\n+        JsonElement jsonLocal = json;\n+        if (jsonLocal != null) {\n+            String s = jsonLocal.getAsString();\n+            return s == null ? ThermostatMode.UNKNOWN : ThermostatMode.fromString(s);\n+        }\n+        return ThermostatMode.UNKNOWN;\n     }\n \n     @Override\n-    public JsonElement serialize(ThermostatMode src, Type typeOfSrc, JsonSerializationContext context)\n-            throws JsonParseException {\n+    public JsonElement serialize(ThermostatMode src, @Nullable Type typeOfSrc,\n+            @Nullable JsonSerializationContext context) throws JsonParseException {\n         return new JsonPrimitive(src != ThermostatMode.UNKNOWN ? src.getDeconzValue() : null);", "originalCommit": "88dd1579896aadd58c64ef9f5557116b4361a2b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI2MTE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r436261155", "bodyText": "You're right, thanks. I changed it to JsonNull.", "author": "LukasA83", "createdAt": "2020-06-06T11:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1ODg3Nw=="}], "type": "inlineReview"}, {"oid": "3082f0a09fd639a63b051306eecc787f4bc2cc88", "url": "https://github.com/openhab/openhab-addons/commit/3082f0a09fd639a63b051306eecc787f4bc2cc88", "message": "Fix Thermostat mode JSON serialization\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>", "committedDate": "2020-06-06T11:30:24Z", "type": "commit"}]}