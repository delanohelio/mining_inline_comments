{"pr_number": 8669, "pr_title": "[WLed]  Initial contribution - Binding for LED strings with a large range of built in FX.", "pr_createdAt": "2020-10-05T10:19:05Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8669", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NjcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504096720", "bodyText": "Action labes shall be lower case, that you can use them in a sentence. See #8732 (comment)", "author": "fwolter", "createdAt": "2020-10-13T16:34:09Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedActions.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedActions} is responsible for Actions.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@ThingActionsScope(name = \"wled\")\n+@NonNullByDefault\n+public class WLedActions implements ThingActions {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private @Nullable WLedHandler handler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        this.handler = (WLedHandler) handler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"Save Preset\", description = \"Save a WLED state to a preset location\")", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgxNTIzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506815230", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-17T05:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NjcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5OTEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504099102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = MDNSDiscoveryParticipant.class, immediate = true)\n          \n          \n            \n            @Component(service = MDNSDiscoveryParticipant.class)", "author": "fwolter", "createdAt": "2020-10-13T16:36:53Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, immediate = true)", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5OTY4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504099685", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2020-10-13T16:37:28Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, immediate = true)\n+public class WLedDiscoveryService implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(WLedDiscoveryService.class);\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String name = service.getName().toLowerCase();\n+        if (!name.equals(\"wled\")) {\n+            return null;\n+        }\n+        String address[] = service.getURLs();\n+        if ((address == null) || address.length < 1) {\n+            logger.debug(\"WLED discovered with empty IP address-{}\", service);\n+            return null;\n+        }\n+        logger.info(\"WLED discovered at {}\", address[0]);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwMTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504101485", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2020-10-13T16:39:06Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, immediate = true)\n+public class WLedDiscoveryService implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(WLedDiscoveryService.class);\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String name = service.getName().toLowerCase();\n+        if (!name.equals(\"wled\")) {\n+            return null;\n+        }\n+        String address[] = service.getURLs();\n+        if ((address == null) || address.length < 1) {\n+            logger.debug(\"WLED discovered with empty IP address-{}\", service);\n+            return null;\n+        }\n+        logger.info(\"WLED discovered at {}\", address[0]);\n+        ThingTypeUID thingtypeuid = new ThingTypeUID(\"wled\", \"wled\");\n+        ThingUID thingUID = new ThingUID(thingtypeuid,\n+                address[0].substring(7, address[0].length() - 3).replace(\".\", \"-\"));\n+        return DiscoveryResultBuilder.create(thingUID).withProperty(CONFIG_ADDRESS, address[0])\n+                .withLabel(\"WLED @\" + address[0]).build();", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAwMjU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507002570", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-18T01:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwMTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNDc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504104761", "bodyText": "Are you sure 3 sec. is sufficient? Many bindings use 10 sec. as timeout.", "author": "fwolter", "createdAt": "2020-10-13T16:42:14Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMxODQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505318420", "bodyText": "I am happy to use either 10 or 3. I just like 3 seconds as it is more than enough for a device on a local network and you have a faster response to the device going OFFLINE if the power switch is turned off. Otherwise it could be 20 seconds after you turn the light off at the wall that openHAB knows it is offline due to the default 10 second poll and then another 10 for the timeout. If it was talking to remote servers on the web, then I would want 10 seconds.", "author": "Skinah", "createdAt": "2020-10-15T08:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNDc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNzQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505717491", "bodyText": "I'm fine with 3 sec. Your arguments are valid.", "author": "fwolter", "createdAt": "2020-10-15T17:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNzkzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504107938", "bodyText": "The interrupted flags gets reset when an interrupted exception is cought. You need to set the flag again by Thread.currentThread().interrupt();, or don't catch the exception here.", "author": "fwolter", "createdAt": "2020-10-13T16:46:26Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA4ODA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507088077", "bodyText": "DONE: I added Thread.currentThread().interrupt(); as it feels wrong to throw and not catch.", "author": "Skinah", "createdAt": "2020-10-18T10:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNzkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMjAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504112017", "bodyText": "If you need to implement a parser like this again, you could take a deeper look into regular expressions. That would make such code much simpler.", "author": "fwolter", "createdAt": "2020-10-13T16:53:01Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNzk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505407979", "bodyText": "Thanks for the suggestion it is apricated. Will look into that when I get a spare half hour.", "author": "Skinah", "createdAt": "2020-10-15T09:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMjAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMjg1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504112855", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n          \n          \n            \n                    for (String value : getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {", "author": "fwolter", "createdAt": "2020-10-13T16:54:25Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMzM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504113391", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        fxOptions.add(new StateOption(\"\" + counter++, value));\n          \n          \n            \n                        fxOptions.add(new StateOption(Integer.toString(counter++), value));", "author": "fwolter", "createdAt": "2020-10-13T16:55:14Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504116101", "bodyText": "What's the purpose of the binary AND mask?", "author": "fwolter", "createdAt": "2020-10-13T16:59:36Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzEzNDA4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507134081", "bodyText": "REMOVED and used your suggestion.", "author": "Skinah", "createdAt": "2020-10-18T12:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNzE5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504117197", "bodyText": "When building strings in loops, StringBuilder should be used. In this case, you could replace the block by something like this return String.format(\"h%06X\", hsb.getRGB());.", "author": "fwolter", "createdAt": "2020-10-13T17:01:24Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzEzMzY4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507133685", "bodyText": "Added your suggestion and it works, thanks much nicer.", "author": "Skinah", "createdAt": "2020-10-18T12:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODU1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504118551", "bodyText": "See above. Logging to info. And below.", "author": "fwolter", "createdAt": "2020-10-13T17:03:46Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }\n+        return \"h\" + hex;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=2000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=2000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=2000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=2000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgxOTIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506819232", "bodyText": "DONE: removed them all.", "author": "Skinah", "createdAt": "2020-10-17T06:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExOTQ2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504119464", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                bigTemp = new BigDecimal(0);\n          \n          \n            \n                                bigTemp = BigDecimal.ZERO;", "author": "fwolter", "createdAt": "2020-10-13T17:05:17Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }\n+        return \"h\" + hex;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=2000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=2000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=2000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=2000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                BigDecimal bigTemp = new BigDecimal(command.toString());\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMDUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504120521", "bodyText": "The ThingHandler provides an ExecutorService you can use.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pollingFuture = threadPool.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);\n          \n          \n            \n                    pollingFuture = scheduler.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);", "author": "fwolter", "createdAt": "2020-10-13T17:07:14Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }\n+        return \"h\" + hex;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=2000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=2000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=2000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=2000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                BigDecimal bigTemp = new BigDecimal(command.toString());\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                }\n+                sendGetRequest(\"/win&SX=\" + bigTemp);\n+                break;\n+            case CHANNEL_INTENSITY:\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                }\n+                sendGetRequest(\"/win&IX=\" + bigTemp);\n+                break;\n+            case CHANNEL_SLEEP:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&ND\");\n+                } else {\n+                    sendGetRequest(\"/win&NL=0\");\n+                }\n+                break;\n+            case CHANNEL_PRESETS:\n+                sendGetRequest(\"/win&PL=\" + command);\n+                break;\n+            case CHANNEL_PRESET_DURATION:\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(600)).add(new BigDecimal(500));\n+                }\n+                sendGetRequest(\"/win&PT=\" + bigTemp);\n+                break;\n+            case CHANNEL_TRANS_TIME:\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(600)).add(new BigDecimal(500));\n+                }\n+                sendGetRequest(\"/win&TT=\" + bigTemp);\n+                break;\n+            case CHANNEL_PRESET_CYCLE:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&CY=1\");\n+                } else {\n+                    sendGetRequest(\"/win&CY=0\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void savePreset(int presetIndex) {\n+        if (presetIndex > 16) {\n+            logger.warn(\"Presets above 16 do not exist, and the action sent {}\", presetIndex);\n+            return;\n+        }\n+        sendGetRequest(\"/win&PS=\" + presetIndex);\n+    }\n+\n+    private void pollLED() {\n+        sendGetRequest(\"/win\");\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WLedConfiguration.class);\n+        if (!config.address.contains(\"://\")) {\n+            logger.debug(\"Address was not entered in correct format, it may be the raw IP so adding http:// to start\");\n+            config.address = \"http://\" + config.address;\n+        }\n+        pollingFuture = threadPool.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0MzQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r512543490", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @ActionInput(name = \"presetNumber\", label = \"Save State to Preset Slot\", description = \"Enter the number for the preset slot you wish to use\") int presetNumber) {\n          \n          \n            \n                        @ActionInput(name = \"presetNumber\", label = \"Preset Slot\", description = \"Number for the preset slot you wish to use\") int presetNumber) {", "author": "fwolter", "createdAt": "2020-10-27T09:42:10Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedActions.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedActions} is responsible for Actions.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@ThingActionsScope(name = \"wled\")\n+@NonNullByDefault\n+public class WLedActions implements ThingActions {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private @Nullable WLedHandler handler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        this.handler = (WLedHandler) handler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"save state to preset\", description = \"Save a WLED state to a preset slot\")\n+    public void savePreset(\n+            @ActionInput(name = \"presetNumber\", label = \"Save State to Preset Slot\", description = \"Enter the number for the preset slot you wish to use\") int presetNumber) {", "originalCommit": "d1bae43971cdc9518c6f1e73b7494cf54b1aa88d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyMDAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507020013", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n          \n          \n            \n                        Arrays.asList(THING_TYPE_WLED));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_WLED);", "author": "cpmeister", "createdAt": "2020-10-18T05:39:09Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedBindingConstants.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link WLedBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WLedBindingConstants {\n+\n+    public static final String BINDING_ID = \"wled\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_WLED = new ThingTypeUID(BINDING_ID, \"wled\");\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_WLED));", "originalCommit": "9822855aaeed4801b4dfda92fff4c3d29d1a236e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU0OTIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511549239", "bodyText": "You should log these", "author": "cpmeister", "createdAt": "2020-10-25T05:21:31Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class)\n+public class WLedDiscoveryService implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(WLedDiscoveryService.class);\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public WLedDiscoveryService(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    private String sendGetRequest(String address, String url) {\n+        Request request = httpClient.newRequest(address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                return contentResponse.getContentAsString();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        } catch (TimeoutException | ExecutionException e) {\n+        }", "originalCommit": "d1bae43971cdc9518c6f1e73b7494cf54b1aa88d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0Mzg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514943869", "bodyText": "DONE: I made it only a debug level since this is only during a discovery and not normal use that it would occur.", "author": "Skinah", "createdAt": "2020-10-30T08:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU0OTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513703179", "bodyText": "Should probably make new BigDecimal(2.55) a constant since you use it in quite a few places.", "author": "cpmeister", "createdAt": "2020-10-28T19:22:56Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMDQ1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514110455", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-29T09:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNDk4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513704988", "bodyText": "Why are you creating a new HSBType when you can cast the command?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                primaryColor = new HSBType(command.toString());\n          \n          \n            \n                                primaryColor = (HSBType) command;", "author": "cpmeister", "createdAt": "2020-10-28T19:26:01Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNTg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513705896", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-28T19:27:34Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE5MjYzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514192638", "bodyText": "FIXED", "author": "Skinah", "createdAt": "2020-10-29T11:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNjI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513706240", "bodyText": "not implemented?", "author": "cpmeister", "createdAt": "2020-10-28T19:28:15Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0NDg5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514944892", "bodyText": "Correct, it is implemented on the MASTER controls just not on the colour selections for the FX use. I removed this code to make it shorter.", "author": "Skinah", "createdAt": "2020-10-30T08:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNjI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxMDk2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513710964", "bodyText": "What you are doing here is kinda inefficient with all of the new object creation going on.\nIf you take advantage of the built-in type conversion functions in State you can make this much more concise.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            BigDecimal bigTemp = new BigDecimal(command.toString());\n          \n          \n            \n                            if (OnOffType.OFF.equals(command)) {\n          \n          \n            \n                                bigTemp = BigDecimal.ZERO;\n          \n          \n            \n                            } else if (OnOffType.ON.equals(command)) {\n          \n          \n            \n                                bigTemp = new BigDecimal(255);\n          \n          \n            \n                            } else {\n          \n          \n            \n                                bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n          \n          \n            \n                            }\n          \n          \n            \n                            BigDecimal bigTemp = ((State)command).as(PercentType.class).multiply(BIG_DECIMAL_2_55));\n          \n      \n    \n    \n  \n\nThe same change would apply for the CHANNEL_INTENSITY case as well.", "author": "cpmeister", "createdAt": "2020-10-28T19:37:01Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                BigDecimal bigTemp = new BigDecimal(command.toString());\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = BigDecimal.ZERO;\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                }", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNDc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513714777", "bodyText": "String parsing is an expensive operation, please avoid where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n          \n          \n            \n                                        + primaryColor.getSaturation().toString() + \",command\");\n          \n          \n            \n                                primaryColor = new HSBType(primaryColor.getHue(), primaryColor.getSaturation(),  ((State)command).as(PercentType.class));", "author": "cpmeister", "createdAt": "2020-10-28T19:44:00Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNTA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513715040", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                secondaryColor = new HSBType(command.toString());\n          \n          \n            \n                                secondaryColor = (HSBType) command;", "author": "cpmeister", "createdAt": "2020-10-28T19:44:25Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNTE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513715185", "bodyText": "same here.", "author": "cpmeister", "createdAt": "2020-10-28T19:44:42Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0NzAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514147015", "bodyText": "FIXED", "author": "Skinah", "createdAt": "2020-10-29T10:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNTE4NQ=="}], "type": "inlineReview"}, {"oid": "d3f8aa82864778c13dda3e6419ea77eb4904db80", "url": "https://github.com/openhab/openhab-addons/commit/d3f8aa82864778c13dda3e6419ea77eb4904db80", "message": "V3\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:32Z", "type": "commit"}, {"oid": "66fa166c8edc090fa302e76d41c3887101ce7ed5", "url": "https://github.com/openhab/openhab-addons/commit/66fa166c8edc090fa302e76d41c3887101ce7ed5", "message": "formatting.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:35Z", "type": "commit"}, {"oid": "9a536cd20b19574e73ad8f1349fa179a8851c4f5", "url": "https://github.com/openhab/openhab-addons/commit/9a536cd20b19574e73ad8f1349fa179a8851c4f5", "message": "V3 binding\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "a9db5de295c9bbf9c96961b48661403ca19e13e4", "url": "https://github.com/openhab/openhab-addons/commit/a9db5de295c9bbf9c96961b48661403ca19e13e4", "message": "POM fixed\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "ae8d5d1ef8f4bd63ffe507069de69c702e1dd27c", "url": "https://github.com/openhab/openhab-addons/commit/ae8d5d1ef8f4bd63ffe507069de69c702e1dd27c", "message": "Add comments.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "792205fa1c258c6dd5e63556415644d1d2a66664", "url": "https://github.com/openhab/openhab-addons/commit/792205fa1c258c6dd5e63556415644d1d2a66664", "message": "add to CODEOWNERS\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "d3342614158940c717ef493be203d6c2c1512a97", "url": "https://github.com/openhab/openhab-addons/commit/d3342614158940c717ef493be203d6c2c1512a97", "message": "Comments\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "e3dfba2f94d34cff7d593e63275c99891e068baa", "url": "https://github.com/openhab/openhab-addons/commit/e3dfba2f94d34cff7d593e63275c99891e068baa", "message": "Spotless and POM fixed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "9588cad82ef69c4afdd8539d29d81aa08e34e279", "url": "https://github.com/openhab/openhab-addons/commit/9588cad82ef69c4afdd8539d29d81aa08e34e279", "message": "Update examples to be compatible with 'Create equipment from thing' in\nV3.x\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "878f185b867825a910bc8c5d6f3f20eb82e5061d", "url": "https://github.com/openhab/openhab-addons/commit/878f185b867825a910bc8c5d6f3f20eb82e5061d", "message": "Change thing type category\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "464e95179848d0656dd1ab552808ea2d046866f9", "url": "https://github.com/openhab/openhab-addons/commit/464e95179848d0656dd1ab552808ea2d046866f9", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "31146450a0db01aa652ab9eeedfb62b349529022", "url": "https://github.com/openhab/openhab-addons/commit/31146450a0db01aa652ab9eeedfb62b349529022", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "ce88330c4390c9012267748b9a77e03fc75378c9", "url": "https://github.com/openhab/openhab-addons/commit/ce88330c4390c9012267748b9a77e03fc75378c9", "message": "Update bundles/org.openhab.binding.wled/src/main/feature/feature.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "a40b4ad91db4cb6edcc87601332d8517cb05736c", "url": "https://github.com/openhab/openhab-addons/commit/a40b4ad91db4cb6edcc87601332d8517cb05736c", "message": "Update bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "613005121a9187ca0436f764537075221f596620", "url": "https://github.com/openhab/openhab-addons/commit/613005121a9187ca0436f764537075221f596620", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "23f7e6b105c1d4d54d136d2f0e7640ede84e2800", "url": "https://github.com/openhab/openhab-addons/commit/23f7e6b105c1d4d54d136d2f0e7640ede84e2800", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "55904473a5dffb3901ffbab96c31104814077025", "url": "https://github.com/openhab/openhab-addons/commit/55904473a5dffb3901ffbab96c31104814077025", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "333b1505417a327954874dd78d4c26008507c779", "url": "https://github.com/openhab/openhab-addons/commit/333b1505417a327954874dd78d4c26008507c779", "message": "remove unneeded threadpool.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "ab70200d92bff684b479e5f26adc177fa40ebf36", "url": "https://github.com/openhab/openhab-addons/commit/ab70200d92bff684b479e5f26adc177fa40ebf36", "message": "Use BigDecimal.ZERO\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "b5182e4839fa76ec7bc199b7caf9fdf3c5ccc4f8", "url": "https://github.com/openhab/openhab-addons/commit/b5182e4839fa76ec7bc199b7caf9fdf3c5ccc4f8", "message": "Readme cleanup\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "55e3d80f7ef45489e27e3150a6f04c3d71246adf", "url": "https://github.com/openhab/openhab-addons/commit/55e3d80f7ef45489e27e3150a6f04c3d71246adf", "message": "Rule actions made lower case and readme info added.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "bad563dadadca2474644aafefcd03ca5344e13e0", "url": "https://github.com/openhab/openhab-addons/commit/bad563dadadca2474644aafefcd03ca5344e13e0", "message": "removed logging.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "b8de0ab1d2d6ba3ce06910438d7190bfc4d0f402", "url": "https://github.com/openhab/openhab-addons/commit/b8de0ab1d2d6ba3ce06910438d7190bfc4d0f402", "message": "no more logging to info.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "d2f0e77bbcd733558750d0fdd2ef70c7719173ae", "url": "https://github.com/openhab/openhab-addons/commit/d2f0e77bbcd733558750d0fdd2ef70c7719173ae", "message": "withRepresentationProperty added.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "912b01c213a401c257fca62117fd6067ac29bea3", "url": "https://github.com/openhab/openhab-addons/commit/912b01c213a401c257fca62117fd6067ac29bea3", "message": "simplify code\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "c1541a278d651ddb653f175022dd3a71b9500347", "url": "https://github.com/openhab/openhab-addons/commit/c1541a278d651ddb653f175022dd3a71b9500347", "message": "Change to using Number:Time\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "a979cd87927d48a3c558e80575a95daa25fcd052", "url": "https://github.com/openhab/openhab-addons/commit/a979cd87927d48a3c558e80575a95daa25fcd052", "message": "Segment feature added.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "8f5d0fdf56ae0abfa791e5fbe9cefc3c796b3b70", "url": "https://github.com/openhab/openhab-addons/commit/8f5d0fdf56ae0abfa791e5fbe9cefc3c796b3b70", "message": "Change Number:Time to use pattern=\"%.1f Second\"\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "c243f95da9b891639ffd3f1765277fc4ef581308", "url": "https://github.com/openhab/openhab-addons/commit/c243f95da9b891639ffd3f1765277fc4ef581308", "message": "UOM fixes.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "03762ec96809fe2c716d6dbb5ded99957ac6eb2c", "url": "https://github.com/openhab/openhab-addons/commit/03762ec96809fe2c716d6dbb5ded99957ac6eb2c", "message": "readme sitemap updated.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "9aa4c8cc2920f83eb65f38d9653c4894b2296f26", "url": "https://github.com/openhab/openhab-addons/commit/9aa4c8cc2920f83eb65f38d9653c4894b2296f26", "message": "Allow segment commands to be bypassed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "1bb86969742ad2e6e924c20622d2b14d5d33e6bb", "url": "https://github.com/openhab/openhab-addons/commit/1bb86969742ad2e6e924c20622d2b14d5d33e6bb", "message": "Update bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "e2869a5db689ffec7fef08f0dcc255dfa2828d95", "url": "https://github.com/openhab/openhab-addons/commit/e2869a5db689ffec7fef08f0dcc255dfa2828d95", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedActions.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "d9be35a4ef720c085f0a84814d5a248a03797178", "url": "https://github.com/openhab/openhab-addons/commit/d9be35a4ef720c085f0a84814d5a248a03797178", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedBindingConstants.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "a1b02b49ec9fc2e8f45703fc45ee1e6b4211e749", "url": "https://github.com/openhab/openhab-addons/commit/a1b02b49ec9fc2e8f45703fc45ee1e6b4211e749", "message": "Update bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "981e33f743f72d9c6fdf8aaed49295ccd0441d35", "url": "https://github.com/openhab/openhab-addons/commit/981e33f743f72d9c6fdf8aaed49295ccd0441d35", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\ncommand.toString()\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "e4c673a1d8bc1c2e3a8877ce1f00bc3d9a215143", "url": "https://github.com/openhab/openhab-addons/commit/e4c673a1d8bc1c2e3a8877ce1f00bc3d9a215143", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "a4e5a55ef6bacd6e51fd3de20937aba5eb3a95b2", "url": "https://github.com/openhab/openhab-addons/commit/a4e5a55ef6bacd6e51fd3de20937aba5eb3a95b2", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "80881a5c26a5a8785cda41a6ce2a1172f4cca725", "url": "https://github.com/openhab/openhab-addons/commit/80881a5c26a5a8785cda41a6ce2a1172f4cca725", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "bd11f2d950937b965cc57528eb663eea4178cb1b", "url": "https://github.com/openhab/openhab-addons/commit/bd11f2d950937b965cc57528eb663eea4178cb1b", "message": "Use casting instead of parsing strings.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "be4fe1964f1333cb68f7bc7a291bc668e641dc26", "url": "https://github.com/openhab/openhab-addons/commit/be4fe1964f1333cb68f7bc7a291bc668e641dc26", "message": "Add debug logging for discovery timeouts.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T08:40:50Z", "type": "commit"}, {"oid": "eb1f704a5af775c62541ac020024e244052833a6", "url": "https://github.com/openhab/openhab-addons/commit/eb1f704a5af775c62541ac020024e244052833a6", "message": "fix build error\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T11:12:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        palleteOptions.add(new StateOption(\"\" + counter++, value));\n          \n          \n            \n                        palleteOptions.add(new StateOption(Integer.toString(counter++), value));", "author": "cpmeister", "createdAt": "2020-10-31T04:02:34Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final BigDecimal BIG_DECIMAL_2_55 = new BigDecimal(2.55);\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452367", "bodyText": "At the very least you should log the payload that failed to parse. That way a user would have a better idea of what went wrong.", "author": "cpmeister", "createdAt": "2020-10-31T04:04:36Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final BigDecimal BIG_DECIMAL_2_55 = new BigDecimal(2.55);\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2MDE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515560144", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-11-01T01:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452390", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-31T04:04:44Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final BigDecimal BIG_DECIMAL_2_55 = new BigDecimal(2.55);\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2MDE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515560155", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-11-01T01:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM5MA=="}], "type": "inlineReview"}, {"oid": "6b657c7538912f19f2ce8d2d64dd5729b86d884e", "url": "https://github.com/openhab/openhab-addons/commit/6b657c7538912f19f2ce8d2d64dd5729b86d884e", "message": "Remove Paho from feature.xml\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-31T23:51:41Z", "type": "commit"}, {"oid": "c56f0190ddec080cbc17eb70e74b6425f8db87f7", "url": "https://github.com/openhab/openhab-addons/commit/c56f0190ddec080cbc17eb70e74b6425f8db87f7", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>", "committedDate": "2020-10-31T23:56:39Z", "type": "commit"}, {"oid": "66977e0c887c6f8ec799155c096cdf10b246e231", "url": "https://github.com/openhab/openhab-addons/commit/66977e0c887c6f8ec799155c096cdf10b246e231", "message": "Sync send and receive added.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-01T00:58:52Z", "type": "commit"}, {"oid": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "url": "https://github.com/openhab/openhab-addons/commit/dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "message": "Fix discovery bug.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-01T03:34:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515584897", "bodyText": "I can't really tell if this method is used anywhere, if it is then you should make the return type List instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static LinkedList<String> listOfResults(String message, String element, String end) {\n          \n          \n            \n                    LinkedList<String> results = new LinkedList<String>();\n          \n          \n            \n                static List<String> listOfResults(String message, String element, String end) {\n          \n          \n            \n                    List<String> results = new LinkedList<>();", "author": "cpmeister", "createdAt": "2020-11-01T07:03:18Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHelper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import java.util.LinkedList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link WLedHelper} Provides helper classes that are used from multiple classes in the binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WLedHelper {\n+\n+    /**\n+     * @return A string that starts after finding the element and terminates when it finds the first occurrence of the\n+     *         end string after the element.\n+     */\n+    static String getValue(String message, String element, String end) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex != -1) // -1 means \"not found\"\n+        {\n+            int endIndex = message.indexOf(end, startIndex + element.length());\n+            if (endIndex != -1) {\n+                return message.substring(startIndex + element.length(), endIndex);\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    static LinkedList<String> listOfResults(String message, String element, String end) {\n+        LinkedList<String> results = new LinkedList<String>();", "originalCommit": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515585187", "bodyText": "If temp is empty wouldn't this loop forever?", "author": "cpmeister", "createdAt": "2020-11-01T07:06:33Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHelper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import java.util.LinkedList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link WLedHelper} Provides helper classes that are used from multiple classes in the binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WLedHelper {\n+\n+    /**\n+     * @return A string that starts after finding the element and terminates when it finds the first occurrence of the\n+     *         end string after the element.\n+     */\n+    static String getValue(String message, String element, String end) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex != -1) // -1 means \"not found\"\n+        {\n+            int endIndex = message.indexOf(end, startIndex + element.length());\n+            if (endIndex != -1) {\n+                return message.substring(startIndex + element.length(), endIndex);\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    static LinkedList<String> listOfResults(String message, String element, String end) {\n+        LinkedList<String> results = new LinkedList<String>();\n+        String temp = \"\";\n+        for (int startLookingFromIndex = 0; startLookingFromIndex != -1;) {\n+            startLookingFromIndex = message.indexOf(element, startLookingFromIndex);\n+            if (startLookingFromIndex >= 0) {\n+                temp = getValue(message.substring(startLookingFromIndex), element, end);\n+                if (!temp.isEmpty()) {\n+                    results.add(temp);\n+                    ++startLookingFromIndex;\n+                }\n+            }\n+        }", "originalCommit": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwMjI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515702279", "bodyText": "FIXED: thanks for finding this.", "author": "Skinah", "createdAt": "2020-11-02T01:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515585351", "bodyText": "The config field shouldn't be initialized in the constructor. This should be done in initialize() instead. But it looks like you are already doing that so just remove it here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    config = getConfigAs(WLedConfiguration.class);", "author": "cpmeister", "createdAt": "2020-11-01T07:08:53Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);", "originalCommit": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY5ODc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515698764", "bodyText": "If I do that then I get \"The @nonnull field config may not have been initialized\", error by the compiler. If I make the config nullable then I have to check every time I use it, if it is null. So I went with this approach by doing it twice. How should it be handled then?", "author": "Skinah", "createdAt": "2020-11-02T01:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0NDc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515744785", "bodyText": "The general pattern in other bindings is to initially set the config to a default instance. So in this case just define your config field as:\nprivate WLedConfiguration config = new WLedConfiguration();", "author": "cpmeister", "createdAt": "2020-11-02T05:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r516444185", "bodyText": "FIXED: Thank you, its so obvious now you pointed it out.", "author": "Skinah", "createdAt": "2020-11-03T06:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ=="}], "type": "inlineReview"}, {"oid": "870821ce0c67e93edb505da1485ec242e3b4e907", "url": "https://github.com/openhab/openhab-addons/commit/870821ce0c67e93edb505da1485ec242e3b4e907", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHelper.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>", "committedDate": "2020-11-02T01:05:36Z", "type": "commit"}, {"oid": "2af2b72772aca04f3e13e4e49be27cf6f5a0b547", "url": "https://github.com/openhab/openhab-addons/commit/2af2b72772aca04f3e13e4e49be27cf6f5a0b547", "message": "Prevent endless loop.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-02T01:23:58Z", "type": "commit"}, {"oid": "351c1fd2776e528deff0b18b62f0630026daa384", "url": "https://github.com/openhab/openhab-addons/commit/351c1fd2776e528deff0b18b62f0630026daa384", "message": "Stop double init of config.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-03T06:06:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r516471540", "bodyText": "Please address the null build warnings. If there are any others please address them by using a local variable like so:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingFuture != null) {\n          \n          \n            \n                        pollingFuture.cancel(true);\n          \n          \n            \n                    }\n          \n          \n            \n                    Future<?> future = pollingFuture;\n          \n          \n            \n                    if (future != null) {\n          \n          \n            \n                        future.cancel(true);\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-11-03T07:44:04Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config = new WLedConfiguration();\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields:{}\", e.getMessage());\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields:{}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness255 = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness255.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(BIG_DECIMAL_2_55,\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<ns>1</ns>\")) {\n+            updateState(CHANNEL_SYNC_SEND, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SYNC_SEND, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nr>1</nr>\")) {\n+            updateState(CHANNEL_SYNC_RECEIVE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SYNC_RECEIVE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(BIG_DECIMAL_2_55,\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness255);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness255);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        BigDecimal bigTemp;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SYNC_SEND:\n+                if (OnOffType.OFF.equals(command)) {\n+                    sendGetRequest(\"/win&NS=0\");\n+                } else {\n+                    sendGetRequest(\"/win&NS=1\");\n+                }\n+                break;\n+            case CHANNEL_SYNC_RECEIVE:\n+                if (OnOffType.OFF.equals(command)) {\n+                    sendGetRequest(\"/win&NR=0\");\n+                } else {\n+                    sendGetRequest(\"/win&NR=1\");\n+                }\n+                break;\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + ((PercentType) command).toBigDecimal().multiply(BIG_DECIMAL_2_55));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + ((PercentType) command).toBigDecimal().multiply(BIG_DECIMAL_2_55));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness255.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness255.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    primaryColor = (HSBType) command;\n+                    masterBrightness255 = primaryColor.getBrightness().toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\"\n+                                + masterBrightness255);\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    masterBrightness255 = ((PercentType) command).toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness255);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof HSBType) {\n+                    primaryColor = (HSBType) command;\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof PercentType) {\n+                    primaryColor = new HSBType(primaryColor.getHue(), primaryColor.getSaturation(),\n+                            ((PercentType) command));\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof HSBType) {\n+                    secondaryColor = (HSBType) command;\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof PercentType) {\n+                    secondaryColor = new HSBType(secondaryColor.getHue(), secondaryColor.getSaturation(),\n+                            ((PercentType) command));\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                bigTemp = ((State) command).as(PercentType.class).toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                sendGetRequest(\"/win&SX=\" + bigTemp);\n+                break;\n+            case CHANNEL_INTENSITY:\n+                bigTemp = ((State) command).as(PercentType.class).toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                sendGetRequest(\"/win&IX=\" + bigTemp);\n+                break;\n+            case CHANNEL_SLEEP:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&NL=1\");\n+                } else {\n+                    sendGetRequest(\"/win&NL=0\");\n+                }\n+                break;\n+            case CHANNEL_PRESETS:\n+                sendGetRequest(\"/win&PL=\" + command);\n+                break;\n+            case CHANNEL_PRESET_DURATION:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> seconds = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+                    if (seconds != null) {\n+                        bigTemp = new BigDecimal(seconds.intValue()).multiply(new BigDecimal(1000));\n+                        sendGetRequest(\"/win&PT=\" + bigTemp.intValue());\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TRANS_TIME:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> seconds = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+                    if (seconds != null) {\n+                        bigTemp = new BigDecimal(seconds.intValue()).multiply(new BigDecimal(1000));\n+                        sendGetRequest(\"/win&TT=\" + bigTemp.intValue());\n+                    }\n+                }\n+                break;\n+            case CHANNEL_PRESET_CYCLE:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&CY=1\");\n+                } else {\n+                    sendGetRequest(\"/win&CY=0\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void savePreset(int presetIndex) {\n+        if (presetIndex > 16) {\n+            logger.warn(\"Presets above 16 do not exist, and the action sent {}\", presetIndex);\n+            return;\n+        }\n+        sendGetRequest(\"/win&PS=\" + presetIndex);\n+    }\n+\n+    private void pollLED() {\n+        sendGetRequest(\"/win\");\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WLedConfiguration.class);\n+        if (!config.address.contains(\"://\")) {\n+            logger.debug(\"Address was not entered in correct format, it may be the raw IP so adding http:// to start\");\n+            config.address = \"http://\" + config.address;\n+        }\n+        pollingFuture = scheduler.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingFuture != null) {\n+            pollingFuture.cancel(true);\n+        }", "originalCommit": "351c1fd2776e528deff0b18b62f0630026daa384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU0NTgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r516545803", "bodyText": "Thank you for showing how it is meant to be handled, all warnings of that type are gone.", "author": "Skinah", "createdAt": "2020-11-03T09:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTU0MA=="}], "type": "inlineReview"}, {"oid": "f3fe2cd6d0a1b4e19adf78cf4fa5bb2ef0af3a78", "url": "https://github.com/openhab/openhab-addons/commit/f3fe2cd6d0a1b4e19adf78cf4fa5bb2ef0af3a78", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>", "committedDate": "2020-11-03T09:44:07Z", "type": "commit"}, {"oid": "b1e5e3cc4ce636ec2396cbc2819c7641597347c4", "url": "https://github.com/openhab/openhab-addons/commit/b1e5e3cc4ce636ec2396cbc2819c7641597347c4", "message": "Fix null compiler warnings.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-03T09:53:20Z", "type": "commit"}]}