{"pr_number": 6990, "pr_title": "[jablotron] Jablotron binding initial contribution", "pr_createdAt": "2020-02-09T21:28:02Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6990", "timeline": [{"oid": "16a96c4dd5c1040b1454049737a29a23954838dc", "url": "https://github.com/openhab/openhab-addons/commit/16a96c4dd5c1040b1454049737a29a23954838dc", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-09T22:08:51Z", "type": "forcePushed"}, {"oid": "797d454db6a38f8da451152b7f1369ccee64a806", "url": "https://github.com/openhab/openhab-addons/commit/797d454db6a38f8da451152b7f1369ccee64a806", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-09T22:26:21Z", "type": "forcePushed"}, {"oid": "22dbdd1d616c9c97df3d6f3dff8e1e5045a1f8e2", "url": "https://github.com/openhab/openhab-addons/commit/22dbdd1d616c9c97df3d6f3dff8e1e5045a1f8e2", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-09T22:34:18Z", "type": "forcePushed"}, {"oid": "321abab03798bd745baa0a2f82e432e69040d778", "url": "https://github.com/openhab/openhab-addons/commit/321abab03798bd745baa0a2f82e432e69040d778", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-14T20:20:41Z", "type": "forcePushed"}, {"oid": "d70edcd01a2dc8695cc5774f620ce727573d1494", "url": "https://github.com/openhab/openhab-addons/commit/d70edcd01a2dc8695cc5774f620ce727573d1494", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-14T21:52:21Z", "type": "forcePushed"}, {"oid": "fc3b2af066d901d0227b2c76baa1ebb370dd6861", "url": "https://github.com/openhab/openhab-addons/commit/fc3b2af066d901d0227b2c76baa1ebb370dd6861", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-14T22:21:26Z", "type": "forcePushed"}, {"oid": "b1b15e21b9ef1c9bf457ef0e5816a382fa6403ac", "url": "https://github.com/openhab/openhab-addons/commit/b1b15e21b9ef1c9bf457ef0e5816a382fa6403ac", "message": "[jablotron] improved the documentation\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-16T18:14:20Z", "type": "forcePushed"}, {"oid": "68677f3868c09c3d5269440cd443fcd8e520180e", "url": "https://github.com/openhab/openhab-addons/commit/68677f3868c09c3d5269440cd443fcd8e520180e", "message": "[jablotron] proper reaction to an authentication challenge exception\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-02-17T18:44:06Z", "type": "forcePushed"}, {"oid": "5de2ba8ad7d8be60940e23dfe64d0b97e9acc98a", "url": "https://github.com/openhab/openhab-addons/commit/5de2ba8ad7d8be60940e23dfe64d0b97e9acc98a", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-03-01T09:18:08Z", "type": "forcePushed"}, {"oid": "fc69ce4a14aea33749cfdcf3093a55876b80f924", "url": "https://github.com/openhab/openhab-addons/commit/fc69ce4a14aea33749cfdcf3093a55876b80f924", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-03-01T09:31:23Z", "type": "forcePushed"}, {"oid": "901ebbe210b8573566465f5808b21eab29b878b6", "url": "https://github.com/openhab/openhab-addons/commit/901ebbe210b8573566465f5808b21eab29b878b6", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-03-21T13:29:18Z", "type": "forcePushed"}, {"oid": "5d94922868aedede9f3a983875748fbb966bd2f8", "url": "https://github.com/openhab/openhab-addons/commit/5d94922868aedede9f3a983875748fbb966bd2f8", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-04-22T18:27:58Z", "type": "forcePushed"}, {"oid": "0ea482b55ffb96cf438937fd0d8db5a440bfb9ab", "url": "https://github.com/openhab/openhab-addons/commit/0ea482b55ffb96cf438937fd0d8db5a440bfb9ab", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-08-19T16:27:20Z", "type": "forcePushed"}, {"oid": "135b27fb724206ad55bd73cd9da2db54f9734e65", "url": "https://github.com/openhab/openhab-addons/commit/135b27fb724206ad55bd73cd9da2db54f9734e65", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-08-19T16:27:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482949572", "bodyText": "Can you implement registration of a bridge bound discovery as a ThingHandlerService. See this preview documentation on how that works: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "author": "Hilbrand", "createdAt": "2020-09-03T12:46:05Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClientFactory httpClientFactory;\n+\n+    @Activate\n+    public JablotronHandlerFactory(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return THING_TYPE_BRIDGE.equals(thingTypeUID) || SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_BRIDGE)) {\n+            JablotronBridgeHandler handler = new JablotronBridgeHandler((Bridge) thing, httpClientFactory.getCommonHttpClient());\n+            registerItemDiscoveryService(handler);", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484123672", "bodyText": "ok, done", "author": "octa22", "createdAt": "2020-09-06T22:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950045", "bodyText": "static final should be above other fields.", "author": "Hilbrand", "createdAt": "2020-09-03T12:46:49Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117465", "bodyText": "moved to JablotronBindingConstants class", "author": "octa22", "createdAt": "2020-09-06T21:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950863", "bodyText": "Can you catch the specific exception.", "author": "Hilbrand", "createdAt": "2020-09-03T12:48:13Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {\n+                logger.info(\"Cannot find any Jablotron device\");\n+                return;\n+            }\n+\n+            for (JablotronDiscoveredService service : services) {\n+                String serviceId = String.valueOf(service.getId());\n+                logger.debug(\"Found Jablotron service: {} id: {}\", service.getName(), serviceId);\n+\n+                String serviceType = service.getServiceType().toLowerCase();\n+                if (serviceType.equals(THING_TYPE_OASIS.getId())) {\n+                    oasisDiscovered(\"Jablotron OASIS Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100.getId())) {\n+                    ja100Discovered(\"Jablotron JA100 Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100F.getId())) {\n+                    ja100fDiscovered(\"Jablotron JA100+ Alarm : \" + service.getName(), serviceId);\n+                } else {\n+                    logger.info(\"Unsupported device type discovered: {} with serviceId: {} and type: {}\", service.getName(), serviceId, service.getServiceType());\n+                }\n+            }\n+        } catch (Exception ex) {", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117330", "bodyText": "removed, not necessary to catch the generic exception", "author": "octa22", "createdAt": "2020-09-06T21:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950983", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (services == null || services.size() == 0) {\n          \n          \n            \n                        if (services == null || services.isEmpty()) {", "author": "Hilbrand", "createdAt": "2020-09-03T12:48:26Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzE2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117160", "bodyText": "ok", "author": "octa22", "createdAt": "2020-09-06T21:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955281", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        doInit();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::doInit);", "author": "Hilbrand", "createdAt": "2020-09-03T12:55:05Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNjczMg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484116732", "bodyText": "ok", "author": "octa22", "createdAt": "2020-09-06T21:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                @Nullable ScheduledFuture<?> future = null;\n          \n      \n    \n    \n  \n\nprotected?", "author": "Hilbrand", "createdAt": "2020-09-03T12:55:39Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117561", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-06T21:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTk3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955976", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Gson gson = new Gson();\n          \n          \n            \n                protected final Gson gson = new Gson();", "author": "Hilbrand", "createdAt": "2020-09-03T12:56:09Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNjc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484116786", "bodyText": "made final", "author": "octa22", "createdAt": "2020-09-06T21:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483426784", "bodyText": "It this needed?", "author": "Hilbrand", "createdAt": "2020-09-04T07:01:27Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMzcxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484123710", "bodyText": "removed", "author": "octa22", "createdAt": "2020-09-06T22:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483426983", "bodyText": "This is probably not needed as it is already done in stopBackgroundDiscovery.", "author": "Hilbrand", "createdAt": "2020-09-04T07:01:57Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117911", "bodyText": "agree", "author": "octa22", "createdAt": "2020-09-06T21:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzM2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483427363", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    future = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        updateAlarmStatus();\n          \n          \n            \n                    }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);\n          \n          \n            \n                    future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "author": "Hilbrand", "createdAt": "2020-09-04T07:02:57Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(() -> {\n+            updateAlarmStatus();\n+        }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117109", "bodyText": "ok", "author": "octa22", "createdAt": "2020-09-06T21:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODc1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483428756", "bodyText": "To make this class a lot readable better move the generic parts in these methods to a single method and call that from the other methods.", "author": "Hilbrand", "createdAt": "2020-09-04T07:06:10Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzMzkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485133936", "bodyText": "I did some changes to make this class more readable", "author": "octa22", "createdAt": "2020-09-08T19:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTIxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483429210", "bodyText": "Is this Exception thrown or can it be a specific exception that is being catched here?", "author": "Hilbrand", "createdAt": "2020-09-04T07:07:08Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        try {\n+            JablotronControlResponse response = sendUserCode(code);\n+            scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);\n+\n+            if (response == null) {\n+                logger.debug(\"null response/status received\");\n+            }\n+        } catch (Exception e) {", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNjk3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484116977", "bodyText": "removed catching of this generic exception", "author": "octa22", "createdAt": "2020-09-06T21:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483794600", "bodyText": "Maybe add some context to this debug message. Like what was send.", "author": "Hilbrand", "createdAt": "2020-09-04T18:50:11Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label).withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        }\n+        else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {\n+            List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+            if (infos.size() > 0) {\n+                logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+                DecimalType newState = new DecimalType(infos.get(0).getValue());\n+                updateState(channel.getUID(), newState);\n+            } else {\n+                logger.debug(\"No segment information received\");\n+            }\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    public synchronized void controlPGMSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, thingConfig.getCode());\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106422", "bodyText": "added context", "author": "octa22", "createdAt": "2020-09-06T19:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796014", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                @Nullable ScheduledFuture<?> future = null;", "author": "Hilbrand", "createdAt": "2020-09-04T18:53:47Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjQ4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106480", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-06T19:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796063", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Gson gson = new Gson();\n          \n          \n            \n                private final Gson gson = new Gson();", "author": "Hilbrand", "createdAt": "2020-09-04T18:53:58Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjcxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106715", "bodyText": "added final", "author": "octa22", "createdAt": "2020-09-06T19:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796588", "bodyText": "Is this necessay to override?. Same for disposed method?", "author": "Hilbrand", "createdAt": "2020-09-04T18:55:08Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106608", "bodyText": "removed, you were right, not necessary", "author": "octa22", "createdAt": "2020-09-06T19:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwMjQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483802497", "bodyText": "The design you have used here is that a thing id represents a identiffier. However, convention is that the id of a thing should not be used, but can freely be defined by the user. The design should be that the serviceId is a parameter of a thing.", "author": "Hilbrand", "createdAt": "2020-09-04T19:10:11Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status, String code) throws SecurityException {\n+        String url;\n+        JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+        if (handler == null) {\n+            logger.debug(\"Thing handler is null\");\n+            return null;\n+        }\n+\n+        if (handler.isInService()) {\n+            logger.debug(\"Cannot send command because the alarm is in the service mode\");\n+            return null;\n+        }\n+\n+        try {\n+            url = JABLOTRON_API_URL + \"controlSegment.json\";\n+            String urlParameters = \"service=\" + th.getThingTypeUID().getId() + \"&serviceId=\" + th.getUID().getId() + \"&segmentId=\" + section + \"&segmentKey=\" + key + \"&expected_status=\" + status + \"&control_time=0&control_code=\" + code + \"&system=\" + SYSTEM;\n+            logger.debug(\"Sending POST to url address: {} to control section: {}\", url, section);\n+            logger.trace(\"Url parameters: {}\", urlParameters);\n+\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Control response: {}\", line);\n+            JablotronControlResponse response = gson.fromJson(line, JablotronControlResponse.class);\n+            if (!response.isStatus()) {\n+                logger.debug(\"Error during sending user code: {}\", response.getErrorMessage());\n+            }\n+            return response;\n+        } catch (TimeoutException e) {\n+            logger.debug(\"sendUserCode timeout exception\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendUserCode exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+                throw new SecurityException(AUTHENTICATION_CHALLENGE);\n+            } else {\n+                logger.debug(\"sendUserCode exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(Thing th, String alarm) {\n+        String url = JABLOTRON_API_URL + alarm + \"/eventHistoryGet.json\";\n+        String urlParameters = \"{\\\"limit\\\":1, \\\"service-id\\\":\" + th.getUID().getId() + \"}\";\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"get event history: {}\", line);\n+            JablotronGetEventHistoryResponse response = gson.fromJson(line, JablotronGetEventHistoryResponse.class);\n+            if (200 != response.getHttpCode()) {\n+                logger.debug(\"Got error while getting history with http code: {}\", response.getHttpCode());\n+            }\n+            return response.getData().getEvents();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting alarm history!\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendGetEventHistory exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"sendGetEventHistory exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest(Thing th) {\n+        String url = JABLOTRON_API_URL + \"dataUpdate.json\";\n+        String urlParameters = \"data=[{ \\\"filter_data\\\":[{\\\"data_type\\\":\\\"section\\\"},{\\\"data_type\\\":\\\"pgm\\\"},{\\\"data_type\\\":\\\"thermometer\\\"},{\\\"data_type\\\":\\\"thermostat\\\"}],\\\"service_type\\\":\\\"\" + th.getThingTypeUID().getId() + \"\\\",\\\"service_id\\\":\" + th.getUID().getId() + \",\\\"data_group\\\":\\\"serviceData\\\"}]&system=\" + SYSTEM;", "originalCommit": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExMDAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484110037", "bodyText": "OK, changed design so the serviceId is a parameter of the thing", "author": "octa22", "createdAt": "2020-09-06T20:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwMjQ5Nw=="}], "type": "inlineReview"}, {"oid": "fd5e10d20825e53071c28421cbe41e948b0b3d2d", "url": "https://github.com/openhab/openhab-addons/commit/fd5e10d20825e53071c28421cbe41e948b0b3d2d", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "a1c5f2bb0924e0f6d02b68e1651304f4425f7266", "url": "https://github.com/openhab/openhab-addons/commit/a1c5f2bb0924e0f6d02b68e1651304f4425f7266", "message": "[jablotron] added support for JA100 thermometers\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "b951b508ec412dd3ef99e3fa0af4033c53228ed6", "url": "https://github.com/openhab/openhab-addons/commit/b951b508ec412dd3ef99e3fa0af4033c53228ed6", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "415bbfeb705363edb54324518a06b1c277b08af9", "url": "https://github.com/openhab/openhab-addons/commit/415bbfeb705363edb54324518a06b1c277b08af9", "message": "[jablotron] improved the documentation\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "a40fe3db2a2fb9f73e24ea13d1e45ad13c9be432", "url": "https://github.com/openhab/openhab-addons/commit/a40fe3db2a2fb9f73e24ea13d1e45ad13c9be432", "message": "[jablotron] proper reaction to an authentication challenge exception\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "2090ab03e884f6c944d8dfb3908294c368376e42", "url": "https://github.com/openhab/openhab-addons/commit/2090ab03e884f6c944d8dfb3908294c368376e42", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "8c904e3ff7298b8d84760d013617bd8eb7a36ab4", "url": "https://github.com/openhab/openhab-addons/commit/8c904e3ff7298b8d84760d013617bd8eb7a36ab4", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:30Z", "type": "commit"}, {"oid": "211a0ba826f477603b801ef9c5bfc1c90f2478e2", "url": "https://github.com/openhab/openhab-addons/commit/211a0ba826f477603b801ef9c5bfc1c90f2478e2", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:31Z", "type": "commit"}, {"oid": "8998bd20454a7789d89eabb807f3da7e2af8ec33", "url": "https://github.com/openhab/openhab-addons/commit/8998bd20454a7789d89eabb807f3da7e2af8ec33", "message": "[jablotron] Bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:31Z", "type": "commit"}, {"oid": "8c508ac966c84921920e6b660b54dafc37c76736", "url": "https://github.com/openhab/openhab-addons/commit/8c508ac966c84921920e6b660b54dafc37c76736", "message": "[jablotron] added support for the thermostat temperature\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:31Z", "type": "commit"}, {"oid": "a029f424e56b4a3bc39b73147d3336ecbd4b4456", "url": "https://github.com/openhab/openhab-addons/commit/a029f424e56b4a3bc39b73147d3336ecbd4b4456", "message": "[jablotron] applied mvn:spotless\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:31Z", "type": "commit"}, {"oid": "7fdea73f32b1dbad02b9f990cafa0f2b777871ec", "url": "https://github.com/openhab/openhab-addons/commit/7fdea73f32b1dbad02b9f990cafa0f2b777871ec", "message": "[jablotron] Fixes based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:45:31Z", "type": "commit"}, {"oid": "51cf2d1d427168f58488e404374fb842d8f26172", "url": "https://github.com/openhab/openhab-addons/commit/51cf2d1d427168f58488e404374fb842d8f26172", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:46:52Z", "type": "commit"}, {"oid": "51cf2d1d427168f58488e404374fb842d8f26172", "url": "https://github.com/openhab/openhab-addons/commit/51cf2d1d427168f58488e404374fb842d8f26172", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T19:46:52Z", "type": "forcePushed"}, {"oid": "60de8c7ff2ab05cfd2d545ab87074d210268d604", "url": "https://github.com/openhab/openhab-addons/commit/60de8c7ff2ab05cfd2d545ab87074d210268d604", "message": "[jablotron] serviceId is mandatory config parameter now\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T20:19:38Z", "type": "commit"}, {"oid": "5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "url": "https://github.com/openhab/openhab-addons/commit/5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "message": "[jablotron] next bucket of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T23:13:51Z", "type": "commit"}, {"oid": "5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "url": "https://github.com/openhab/openhab-addons/commit/5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "message": "[jablotron] next bucket of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-06T23:13:51Z", "type": "forcePushed"}, {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "url": "https://github.com/openhab/openhab-addons/commit/c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "message": "[jablotron] code cleanup\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-07T21:02:52Z", "type": "commit"}, {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "url": "https://github.com/openhab/openhab-addons/commit/c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "message": "[jablotron] code cleanup\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-07T21:02:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzU3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485137577", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true)\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class)", "author": "Hilbrand", "createdAt": "2020-09-08T19:09:18Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)", "originalCommit": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485198947", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-08T21:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485137778", "bodyText": "This field can be removed.", "author": "Hilbrand", "createdAt": "2020-09-08T19:09:43Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();", "originalCommit": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485199340", "bodyText": "removed", "author": "octa22", "createdAt": "2020-09-08T21:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTYzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485139632", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final int TIMEOUT = 10;\n          \n          \n            \n                public static final int TIMEOUT_SEC = 10;", "author": "Hilbrand", "createdAt": "2020-09-08T19:13:24Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/JablotronBindingConstants.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link JablotronBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBindingConstants {\n+\n+    private static final String BINDING_ID = \"jablotron\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_BRIDGE = new ThingTypeUID(BINDING_ID, \"bridge\");\n+    public static final ThingTypeUID THING_TYPE_OASIS = new ThingTypeUID(BINDING_ID, \"oasis\");\n+    public static final ThingTypeUID THING_TYPE_JA100 = new ThingTypeUID(BINDING_ID, \"ja100\");\n+    public static final ThingTypeUID THING_TYPE_JA100F = new ThingTypeUID(BINDING_ID, \"ja100f\");\n+\n+    // Common alarm channels\n+    public static final String CHANNEL_ALARM = \"alarm\";\n+    public static final String CHANNEL_LAST_CHECK_TIME = \"lastCheckTime\";\n+    public static final String CHANNEL_LAST_EVENT = \"lastEvent\";\n+    public static final String CHANNEL_LAST_EVENT_CLASS = \"lastEventClass\";\n+    public static final String CHANNEL_LAST_EVENT_TIME = \"lastEventTime\";\n+    public static final String CHANNEL_LAST_EVENT_INVOKER = \"lastEventInvoker\";\n+    public static final String CHANNEL_LAST_EVENT_SECTION = \"lastEventSection\";\n+\n+    // List of all OASIS Channel ids\n+    public static final String CHANNEL_COMMAND = \"command\";\n+    public static final String CHANNEL_STATUS_A = \"statusA\";\n+    public static final String CHANNEL_STATUS_B = \"statusB\";\n+    public static final String CHANNEL_STATUS_ABC = \"statusABC\";\n+    public static final String CHANNEL_STATUS_PGX = \"statusPGX\";\n+    public static final String CHANNEL_STATUS_PGY = \"statusPGY\";\n+\n+    // Constants\n+    public static final String JABLOTRON_API_URL = \"https://api.jablonet.net/api/1.6/\";\n+    public static final String AGENT = \"Swagger-Codegen/1.0.0/android\";\n+    public static final int TIMEOUT = 10;", "originalCommit": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTYzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485199636", "bodyText": "renamed", "author": "octa22", "createdAt": "2020-09-08T21:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485141173", "bodyText": "As this is an abstract class maybe use getClass() to know which specific subclass logs:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(getClass());", "author": "Hilbrand", "createdAt": "2020-09-08T19:16:22Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);", "originalCommit": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMDI2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485200263", "bodyText": "ok, fixed", "author": "octa22", "createdAt": "2020-09-08T21:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTE3Mw=="}], "type": "inlineReview"}, {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "url": "https://github.com/openhab/openhab-addons/commit/a590e81e68f4bb50a74b76dce0635a7906ca04ab", "message": "[jablotron] next bunch of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-08T21:26:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486585894", "bodyText": "Logging to info should be used rarely. This could be debug. Same for below.", "author": "fwolter", "createdAt": "2020-09-10T19:31:44Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        List<JablotronDiscoveredService> services = bridgeHandler.discoverServices();\n+\n+        if (services == null || services.isEmpty()) {\n+            logger.info(\"Cannot find any Jablotron device\");", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMzQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487133413", "bodyText": "Agreed. Changed the severity to debug", "author": "octa22", "createdAt": "2020-09-11T15:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487134060", "bodyText": "The below info severity is important for creating an issue. I would keep it as info so we can easily find out the ids of unsupported alarms", "author": "octa22", "createdAt": "2020-09-11T15:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486587711", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2020-09-10T19:35:26Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMjE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487132150", "bodyText": "older alarms (JA80, JA100) override this method to correctly update the sections/segments status.\nThe JA100F alarm does not need it at all, so it is not abstract.", "author": "octa22", "createdAt": "2020-09-11T15:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyMjYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487222609", "bodyText": "In this case it's good practice to make it abstract to show that this method is meant to be overwritten. In the single class, which doesn't override it, you could add a comment like \"// nothing\" in the method.", "author": "fwolter", "createdAt": "2020-09-11T18:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2Mzk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487263974", "bodyText": "OK, I will do it abstract", "author": "octa22", "createdAt": "2020-09-11T20:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4ODQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486588495", "bodyText": "Calendar is old fashioned. You could do this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n          \n          \n            \n                    ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());", "author": "fwolter", "createdAt": "2020-09-10T19:36:56Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487134654", "bodyText": "OK, Fixed", "author": "octa22", "createdAt": "2020-09-11T15:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4ODQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4OTA0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486589047", "bodyText": "Is this necessary to be executed asynchronously? You could schedule the updateAlarmStatus() task directly here.", "author": "fwolter", "createdAt": "2020-09-10T19:38:04Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDY5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487150692", "bodyText": "good hint, fixed", "author": "octa22", "createdAt": "2020-09-11T16:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4OTA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MjY2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486592663", "bodyText": "You could fix the compiler warning by storing the result of getBridge() into a local variable and work with that.", "author": "fwolter", "createdAt": "2020-09-10T19:45:20Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory(alarmName);\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }\n+        }\n+        return response;\n+    }\n+\n+    protected @Nullable JablotronBridgeHandler getBridgeHandler() {\n+        if (getBridge() != null && getBridge().getHandler() != null) {", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0Mzg0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487143841", "bodyText": "introduced the local var.", "author": "octa22", "createdAt": "2020-09-11T16:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MjY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MzE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486593147", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> future = null;", "author": "fwolter", "createdAt": "2020-09-10T19:46:24Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjM2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487142361", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-11T16:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5Mzg1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486593856", "bodyText": "The annotation could be removed, as the compiler is more intelligent on local variables to see, that you're doing a null check.", "author": "fwolter", "createdAt": "2020-09-10T19:47:51Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487142914", "bodyText": "ok", "author": "octa22", "createdAt": "2020-09-11T16:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5Mzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486594536", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!\"\".equals(service.getWarning())) {\n          \n          \n            \n                                if (!service.getWarning().isEmpty()) {", "author": "fwolter", "createdAt": "2020-09-10T19:49:21Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NDE2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487144168", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-11T16:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486594942", "bodyText": "The log message could be removed, as the status update is already logged by the framework.", "author": "fwolter", "createdAt": "2020-09-10T19:50:10Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NTUwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487145501", "bodyText": "hmm I do not get it. The logger logs something different than status update. Keeping", "author": "octa22", "createdAt": "2020-09-11T16:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392338", "bodyText": "You're right, sorry.", "author": "fwolter", "createdAt": "2020-09-12T09:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486596092", "bodyText": "The log message could be removed, as the status update is already logged by the framework. Same for below.", "author": "fwolter", "createdAt": "2020-09-10T19:52:25Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NTkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487145923", "bodyText": "OK", "author": "octa22", "createdAt": "2020-09-11T16:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486596478", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Nullable", "author": "fwolter", "createdAt": "2020-09-10T19:53:12Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Interrupt during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Syntax error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        @Nullable", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487147341", "bodyText": "fixed, including the occurences below", "author": "octa22", "createdAt": "2020-09-11T16:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486597720", "bodyText": "Can you handle the RefreshType command?", "author": "fwolter", "createdAt": "2020-09-10T19:55:39Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"SEC-\") && command instanceof StringType) {\n+            if (\"PARTIAL_ARM\".equals(command.toString())) {\n+                controlComponent(channelUID.getId(), \"CONTROL-SECTION\", \"DISARM\");\n+            }\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-SECTION\", command.toString()));\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PG-\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-PG\", command.toString()));\n+        }\n+    }", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MTcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487151725", "bodyText": "their API is very slow, often experiences timeouts. Since I can update the status only of the whole alarm including all channels, calling this update method for each channel would kill this binding.", "author": "octa22", "createdAt": "2020-09-11T16:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNDE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487214187", "bodyText": "This challenges many bindings. For this use case ExpiringCache has been introduced. See https://www.openhab.org/javadoc/v2.5/org/eclipse/smarthome/core/cache/expiringcache", "author": "fwolter", "createdAt": "2020-09-11T18:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyNzU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487327595", "bodyText": "ok, implemented the expiring cache", "author": "octa22", "createdAt": "2020-09-11T23:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486600465", "bodyText": "See above. Handle refresh.", "author": "fwolter", "createdAt": "2020-09-10T20:01:10Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MjAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487152019", "bodyText": "their API is very slow, often experiences timeouts. Since I can update the status only of the whole alarm including all channels, calling this update method for each channel would kill this binding.", "author": "octa22", "createdAt": "2020-09-11T16:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMjg3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486602871", "bodyText": "Is there a reason why you create the temperature Channel dynamically? Is the temperature sensor not always present at JA-100 devices?", "author": "fwolter", "createdAt": "2020-09-10T20:06:00Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODIwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487148207", "bodyText": "It makes sense only to create it dynamically, it is not included out of the box, but as an optional peripheral.", "author": "octa22", "createdAt": "2020-09-11T16:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMjg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNDMwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486604306", "bodyText": "Did you test this? Are there Channels starting with STATE_?", "author": "fwolter", "createdAt": "2020-09-10T20:09:00Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487148437", "bodyText": "Yes, the dynamically created", "author": "octa22", "createdAt": "2020-09-11T16:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNDMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNjIxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486606215", "bodyText": "See above. refresh", "author": "fwolter", "createdAt": "2020-09-10T20:12:57Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MjM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487152367", "bodyText": "their API is very slow, often experiences timeouts. Since I can update the status only of the whole alarm including all channels, calling this update method for each channel would kill this binding.", "author": "octa22", "createdAt": "2020-09-11T16:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNjIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486608409", "bodyText": "You don't need to poll the state, as the Channel has already the new value, the user set before.\nOr does setting one Channel affect the state of another Channel?", "author": "fwolter", "createdAt": "2020-09-10T20:17:12Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487148889", "bodyText": "Yes, sending a user code immediately changes states of the sections. So it is the fastest way how to update the other channels states.", "author": "octa22", "createdAt": "2020-09-11T16:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486608507", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-10T20:17:25Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received during the control of section: {}\", section);\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        JablotronControlResponse response = sendUserCode(code);\n+        scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0OTA2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487149066", "bodyText": "the same as above", "author": "octa22", "createdAt": "2020-09-11T16:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxODg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486618873", "bodyText": "As bridgeHandler is Nullable, you have to do a null check before accessing it. You can store it to a local variable and do the null check on that. Same for the others in this file.", "author": "fwolter", "createdAt": "2020-09-10T20:37:20Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {", "originalCommit": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487419830", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-12T15:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxODg3Mw=="}], "type": "inlineReview"}, {"oid": "d4b5ba212823258ad7b10e18f3c2f3a63030b810", "url": "https://github.com/openhab/openhab-addons/commit/d4b5ba212823258ad7b10e18f3c2f3a63030b810", "message": "[jablotron] another bunch of improvements based on code revires\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-11T16:53:14Z", "type": "commit"}, {"oid": "516302a479c102f6f7f8e8cbd8904bf67e5c3c89", "url": "https://github.com/openhab/openhab-addons/commit/516302a479c102f6f7f8e8cbd8904bf67e5c3c89", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-12T06:41:41Z", "type": "forcePushed"}, {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f", "url": "https://github.com/openhab/openhab-addons/commit/bb824dab23246fe665151e79780dc81f6fe4928f", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-12T06:57:07Z", "type": "commit"}, {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f", "url": "https://github.com/openhab/openhab-addons/commit/bb824dab23246fe665151e79780dc81f6fe4928f", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-12T06:57:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487389521", "bodyText": "These don't need to be nullable, as they are initialized in the constructor.", "author": "fwolter", "createdAt": "2020-09-12T09:20:09Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMzMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487423339", "bodyText": "ok, removed nullable", "author": "octa22", "createdAt": "2020-09-12T16:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTYyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487389621", "bodyText": "To eliminate the compiler warnings, you could move this initialization to the JablotronAlarmHandler constructor.", "author": "fwolter", "createdAt": "2020-09-12T09:21:24Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422079", "bodyText": "moved to constructor", "author": "octa22", "createdAt": "2020-09-12T15:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDIxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390219", "bodyText": "If I see correctly, eventCache is always non-null in your implementation.", "author": "fwolter", "createdAt": "2020-09-12T09:28:47Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjA0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422047", "bodyText": "fixed", "author": "octa22", "createdAt": "2020-09-12T15:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390466", "bodyText": "channel cannot be null at this point.", "author": "fwolter", "createdAt": "2020-09-12T09:30:52Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"STATE_\") || channel.startsWith(\"PGM_\") || channel.startsWith(\"THERMOMETER_\")\n+                || channel.startsWith(\"THERMOSTAT_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMTAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487421028", "bodyText": "ok", "author": "octa22", "createdAt": "2020-09-12T15:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MTcxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487391712", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class)\n          \n          \n            \n            @Component(configurationPid = \"binding.jablotron\", service = ThingHandlerFactory.class)", "author": "fwolter", "createdAt": "2020-09-12T09:45:52Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class)", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422677", "bodyText": "added the conf. pid", "author": "octa22", "createdAt": "2020-09-12T15:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MTcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjI3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392274", "bodyText": "Is is a retry code?", "author": "fwolter", "createdAt": "2020-09-12T09:52:44Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            switch (channel) {\n+                case CHANNEL_LAST_EVENT_TIME:\n+                    updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+                    break;\n+                case CHANNEL_LAST_EVENT:\n+                    updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_CLASS:\n+                    updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_INVOKER:\n+                    updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_SECTION:\n+                    updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMTY3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487421676", "bodyText": "old retry code, removed", "author": "octa22", "createdAt": "2020-09-12T15:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392421", "bodyText": "But these are redundant.", "author": "fwolter", "createdAt": "2020-09-12T09:54:37Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422885", "bodyText": "I don't think so, I need the 200 error code to be sure everyting is ok", "author": "octa22", "createdAt": "2020-09-12T15:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDQzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487430435", "bodyText": "I meant only the logger lines 195 and 199. Updating the Thing state is fine.", "author": "fwolter", "createdAt": "2020-09-12T17:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzOTM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487439393", "bodyText": "Still it is useful to have this information if you tail the openhab.log. Their API is very unreliable and this helps me to quickly see what happened during login", "author": "octa22", "createdAt": "2020-09-12T19:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0Nzg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487447885", "bodyText": "The state change originated by updateStatus() is logged to events.log. Including the status detail message. You could tail both files with the same tail command or adjust your logging config in userdata/etc/org.ops4j.pax.logging.cfg if this is more comfortable to you.", "author": "fwolter", "createdAt": "2020-09-12T20:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxNDExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487514111", "bodyText": "ok, removed", "author": "octa22", "createdAt": "2020-09-13T10:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392564", "bodyText": "What is throwing a SecurityException here?", "author": "fwolter", "createdAt": "2020-09-12T09:55:50Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    protected void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), WWW_FORM_URLENCODED).send();\n+\n+            if (logger.isTraceEnabled()) {\n+                String line = resp.getContentAsString();\n+                logger.trace(\"logout response: {}\", line);\n+            }\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            // Silence\n+        }\n+    }\n+\n+    public @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+        String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+        JablotronGetServiceResponse response = sendJsonMessage(url, urlParameters, JablotronGetServiceResponse.class);\n+\n+        if (response == null) {\n+            return null;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+        }\n+\n+        return response.getData().getServices();\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status,\n+            String code) throws SecurityException {", "originalCommit": "bb824dab23246fe665151e79780dc81f6fe4928f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422961", "bodyText": "as I mentioned, old code.\nremoved the SecurityException from the header. thanks", "author": "octa22", "createdAt": "2020-09-12T15:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjU2NA=="}], "type": "inlineReview"}, {"oid": "a55fc34028923eec2bd5850ca43374dbc7816a1b", "url": "https://github.com/openhab/openhab-addons/commit/a55fc34028923eec2bd5850ca43374dbc7816a1b", "message": "[jablotron] next bunch of improvements related to the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-12T16:45:47Z", "type": "commit"}, {"oid": "a55fc34028923eec2bd5850ca43374dbc7816a1b", "url": "https://github.com/openhab/openhab-addons/commit/a55fc34028923eec2bd5850ca43374dbc7816a1b", "message": "[jablotron] next bunch of improvements related to the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-12T16:45:47Z", "type": "forcePushed"}, {"oid": "ef8689324beb15b05eb31b4c76011cdff64751f8", "url": "https://github.com/openhab/openhab-addons/commit/ef8689324beb15b05eb31b4c76011cdff64751f8", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-12T20:07:45Z", "type": "forcePushed"}, {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "url": "https://github.com/openhab/openhab-addons/commit/a24a1fd3e9b0b42b246535a2373bab007dbe3856", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-13T10:54:42Z", "type": "commit"}, {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "url": "https://github.com/openhab/openhab-addons/commit/a24a1fd3e9b0b42b246535a2373bab007dbe3856", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-13T10:54:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjgwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487552807", "bodyText": "This needs to be of type QuantityType. Please pay attention to use import org.eclipse.smarthome.core.library.unit.SIUnits, as there is another class with the same name in a different package.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DecimalType newState = new DecimalType(infos.get(0).getValue());\n          \n          \n            \n                        updateState(channel.getUID(), newState);\n          \n          \n            \n                        updateState(channel.getUID(), QuantityType.valueOf(infos.get(0).getValue(), SIUnits.CELSIUS));", "author": "fwolter", "createdAt": "2020-09-13T17:03:28Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+        if (infos.size() > 0) {\n+            logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+            DecimalType newState = new DecimalType(infos.get(0).getValue());\n+            updateState(channel.getUID(), newState);", "originalCommit": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTcwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487561707", "bodyText": "OK", "author": "octa22", "createdAt": "2020-09-13T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzc5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487553794", "bodyText": "The field could theoretically be modified by another thread exactly between the null check and the access at isCancelled(). This is why the compiler generates a warning. To mitigate this, you can store the field to a local variable before checking it:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (discoveryJob == null || discoveryJob.isCancelled()) {\n          \n          \n            \n                        discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n          \n          \n            \n                    }\n          \n          \n            \n                    ScheduledFuture<?> localDiscoveryJob = discoveryJob;\n          \n          \n            \n            \n          \n          \n            \n                    if (localDiscoveryJob == null || localDiscoveryJob.isCancelled()) {\n          \n          \n            \n                        discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n          \n          \n            \n                    }", "author": "fwolter", "createdAt": "2020-09-13T17:13:45Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }", "originalCommit": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTg1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487561851", "bodyText": "ok", "author": "octa22", "createdAt": "2020-09-13T18:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487553953", "bodyText": "Here too and same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n          \n          \n            \n                    JablotronBridgeHandler localBridgeHandler = bridgeHandler;\n          \n          \n            \n                    if (localBridgeHandler != null) {\n          \n          \n            \n                        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, localBridgeHandler.getThing().getUID(), serviceId);", "author": "fwolter", "createdAt": "2020-09-13T17:15:17Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);", "originalCommit": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MjQyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487562428", "bodyText": "ok, done", "author": "octa22", "createdAt": "2020-09-13T18:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDAzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487554036", "bodyText": "Here for dataCache.", "author": "fwolter", "createdAt": "2020-09-13T17:16:08Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());", "originalCommit": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487563817", "bodyText": "done", "author": "octa22", "createdAt": "2020-09-13T18:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487554054", "bodyText": "And here.", "author": "fwolter", "createdAt": "2020-09-13T17:16:38Z", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_COMMAND:\n+                    if (command instanceof StringType) {\n+                        scheduler.execute(() -> {\n+                            sendCommand(command.toString());\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGX:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGY:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        switch (channel) {\n+            case CHANNEL_STATUS_A:\n+                updateSegmentStatus(\"STATE_1\", dataCache.getValue());", "originalCommit": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487563834", "bodyText": "done", "author": "octa22", "createdAt": "2020-09-13T18:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDA1NA=="}], "type": "inlineReview"}, {"oid": "c7cd72baa91c882e3e482b05ceabe69518a30697", "url": "https://github.com/openhab/openhab-addons/commit/c7cd72baa91c882e3e482b05ceabe69518a30697", "message": "[jablotron] improvements based on code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>", "committedDate": "2020-09-13T18:58:33Z", "type": "commit"}]}