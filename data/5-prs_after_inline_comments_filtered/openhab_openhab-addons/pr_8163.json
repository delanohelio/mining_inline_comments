{"pr_number": 8163, "pr_title": "[studer] Initial contribution", "pr_createdAt": "2020-07-20T23:26:45Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8163", "timeline": [{"oid": "983db276415b9d46c544adefdeedaf59f894597d", "url": "https://github.com/openhab/openhab-addons/commit/983db276415b9d46c544adefdeedaf59f894597d", "message": "[studer] Initial contribution", "committedDate": "2020-07-20T23:42:49Z", "type": "forcePushed"}, {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "url": "https://github.com/openhab/openhab-addons/commit/0fec996bb398b4e6e9c879bea3c18f5108737a57", "message": "[studer] Initial contribution\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-07-20T23:46:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwOTYwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459709603", "bodyText": "Is there a reason why you made this static?", "author": "fwolter", "createdAt": "2020-07-23T20:29:37Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderConfiguration.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link StuderConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderConfiguration {\n+\n+    /**\n+     * Refresh interval in seconds\n+     */\n+    private static int refresh = 5;", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxMDIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459710232", "bodyText": "It's good practice to append the unit to the field name e.g. refreshSec.", "author": "fwolter", "createdAt": "2020-07-23T20:30:50Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxMjM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459712353", "bodyText": "You could initialize this field with en empty array to avoid declaring it as Nullable. Then, the suppression annotation can be removed, too.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer @Nullable [] registers;\n          \n          \n            \n                private Integer[] registers = new Integer[0];", "author": "fwolter", "createdAt": "2020-07-23T20:34:50Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDM0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459714344", "bodyText": "ciao is never used. What is your intention with this assignment?", "author": "fwolter", "createdAt": "2020-07-23T20:38:41Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459714466", "bodyText": "Do you ignore the exception by intention?", "author": "fwolter", "createdAt": "2020-07-23T20:38:59Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459715558", "bodyText": "You could use the local variable, then the compiler doesn't complain.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (studerConfig == null || comms == null) {\n          \n          \n            \n                    if (studerConfig == null || mycomms == null) {", "author": "fwolter", "createdAt": "2020-07-23T20:41:07Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNjY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459716641", "bodyText": "Can you use a speaking name for n? E.g. registerNumber", "author": "fwolter", "createdAt": "2020-07-23T20:43:12Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNzM1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459717351", "bodyText": "Can you remove this?", "author": "fwolter", "createdAt": "2020-07-23T20:44:38Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {\n+        // TODO Auto-generated method stub", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNzc1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459717756", "bodyText": "See above n.", "author": "fwolter", "createdAt": "2020-07-23T20:45:24Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNDMzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459724337", "bodyText": "What do you expect to throw a NumberFormatException? The cast in line 331 will throw a ClassCastException if quantity is not a number. You could hexToFloat() let return the complex type Float, which can be null, too. Then, the cast is not needed.", "author": "fwolter", "createdAt": "2020-07-23T20:58:39Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {\n+        // TODO Auto-generated method stub\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            try {\n+                if (type.equals(THING_TYPE_BSP)) {\n+                    updateState(CHANNELS_BSP.get(n), new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(n)));\n+                } else if (type.equals(THING_TYPE_XTENDER)) {\n+                    handlePolledDataXtender(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                    handlePolledDataVarioTrack(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                    handlePolledDataVarioString(n, quantity);\n+                }\n+            } catch (NumberFormatException e) {", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNTk5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459725992", "bodyText": "vsmode can't be null as getVSModeByCode() is declared as NonNull. So, this will always yield false. Same for below.", "author": "fwolter", "createdAt": "2020-07-23T21:01:50Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {\n+        // TODO Auto-generated method stub\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            try {\n+                if (type.equals(THING_TYPE_BSP)) {\n+                    updateState(CHANNELS_BSP.get(n), new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(n)));\n+                } else if (type.equals(THING_TYPE_XTENDER)) {\n+                    handlePolledDataXtender(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                    handlePolledDataVarioTrack(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                    handlePolledDataVarioString(n, quantity);\n+                }\n+            } catch (NumberFormatException e) {\n+                // Do nothing\n+            }\n+        }\n+        resetCommunicationError();\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the VarioString slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     */\n+    @SuppressWarnings(\"null\")\n+    protected void handlePolledDataVarioString(int n, Object quantity) {\n+        switch (CHANNELS_VARIOSTRING.get(n)) {\n+            case CHANNEL_PV_OPERATING_MODE:\n+            case CHANNEL_PV1_OPERATING_MODE:\n+            case CHANNEL_PV2_OPERATING_MODE:\n+                VSMode vsmode = StuderParser.getVSModeByCode((int) (float) quantity);\n+                updateState(CHANNELS_VARIOSTRING.get(n),\n+                        vsmode == null ? UnDefType.UNDEF : new StringType(vsmode.name()));", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459728956", "bodyText": "Reading the configuration must be done in initialize() of the ThingHandler, because the ThingHandler object is re-used when the configuration is changed. In this case dispose() followed by initialize() is invoked on the same object.", "author": "fwolter", "createdAt": "2020-07-23T21:07:59Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.studer\", service = ThingHandlerFactory.class)\n+public class StuderHandlerFactory extends BaseThingHandlerFactory {\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandlerFactory.class);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        Configuration config = thing.getConfiguration();", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMTgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459731818", "bodyText": "You could create a configuration DTO, which can be filled automatically by invoking BaseThingHandler.getConfigAs(). That would avoid such type checks. However, If you want to stick with this implementation, it's good practice to check the type with instanceof beforehand, instead of relying on catching a ClassCastException or a NullPointerException. Also, you might give the user an advise, in case he forgets to specify the slave address or used a wrong type.", "author": "fwolter", "createdAt": "2020-07-23T21:14:30Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.studer\", service = ThingHandlerFactory.class)\n+public class StuderHandlerFactory extends BaseThingHandlerFactory {\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandlerFactory.class);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        Configuration config = thing.getConfiguration();\n+        int slaveAddress = 0;\n+        try {\n+            slaveAddress = ((BigDecimal) config.get(SLAVE_ADDRESS)).intValue();\n+        } catch (Exception e) {\n+            // Do nothing\n+        }", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzgyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459733828", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "author": "fwolter", "createdAt": "2020-07-23T21:18:47Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;\n+        }\n+    }\n+\n+    public enum State {\n+        OFF(0),\n+        ON(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        State(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static State getStateByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return State.OFF;\n+            case 1:\n+                return State.ON;\n+            default:\n+                return State.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTType {\n+        VT80(0),\n+        VT65(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTType(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTType getVTTypeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTType.VT80;\n+            case 1:\n+                return VTType.VT65;\n+            default:\n+                return VTType.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTMode {\n+        NIGHT(0),\n+        STARTUP(1),\n+        CHARGER(3),\n+        SECURITY(5),\n+        OFF(6),\n+        CHARGE(8),\n+        CHARGEV(9),\n+        CHARGEI(10),\n+        CHARGET(11),\n+        CHIBSP(12),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTMode getVTModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTMode.NIGHT;\n+            case 1:\n+                return VTMode.STARTUP;\n+            case 3:\n+                return VTMode.CHARGER;\n+            case 5:\n+                return VTMode.SECURITY;\n+            case 6:\n+                return VTMode.OFF;\n+            case 8:\n+                return VTMode.CHARGE;\n+            case 9:\n+                return VTMode.CHARGEV;\n+            case 10:\n+                return VTMode.CHARGEI;\n+            case 11:\n+                return VTMode.CHARGET;\n+            case 12:\n+                return VTMode.CHIBSP;\n+            default:\n+                return VTMode.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VSMode {\n+        NIGHT(0),\n+        SECURITY(1),\n+        OFF(2),\n+        CHARGE(3),\n+        CHARGEV(4),\n+        CHARGEI(5),\n+        CHARGEP(6),\n+        CHARGEIPV(7),\n+        CHARGET(8),\n+        CHIBSP(10),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VSMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VSMode getVSModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VSMode.NIGHT;\n+            case 1:\n+                return VSMode.SECURITY;\n+            case 2:\n+                return VSMode.OFF;\n+            case 3:\n+                return VSMode.CHARGE;\n+            case 4:\n+                return VSMode.CHARGEV;\n+            case 5:\n+                return VSMode.CHARGEI;\n+            case 6:\n+                return VSMode.CHARGEP;\n+            case 7:\n+                return VSMode.CHARGEIPV;\n+            case 8:\n+                return VSMode.CHARGET;\n+            case 10:\n+                return VSMode.CHIBSP;\n+            default:\n+                return VSMode.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Convert an hex string to float\n+     *\n+     * @param hex string to convert from\n+     * @return the converted float\n+     */\n+    public @Nullable Object hexToFloat(String hex) {\n+        String t = hex.replaceAll(\" \", \"\");\n+        try {\n+            float f = Float.intBitsToFloat((int) Long.parseLong(t, 16));\n+            if (Float.isNaN(f)) {\n+                return null;\n+            } else {\n+                return f;\n+            }\n+        } catch (Exception e) {", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczODI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459738248", "bodyText": "This field is never used.", "author": "fwolter", "createdAt": "2020-07-23T21:28:11Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0MDY0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459740647", "bodyText": "The logger is never used.", "author": "fwolter", "createdAt": "2020-07-23T21:33:31Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.studer\", service = ThingHandlerFactory.class)\n+public class StuderHandlerFactory extends BaseThingHandlerFactory {\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandlerFactory.class);", "originalCommit": "0fec996bb398b4e6e9c879bea3c18f5108737a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ea603a8bb46f8c99c2a44500398d0107d31e1dcb", "url": "https://github.com/openhab/openhab-addons/commit/ea603a8bb46f8c99c2a44500398d0107d31e1dcb", "message": "Applied feedback from fwolter\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-07-25T00:00:00Z", "type": "forcePushed"}, {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da", "url": "https://github.com/openhab/openhab-addons/commit/1beda2af42278133bf6c04d0a361266dbcc601da", "message": "Preparation for next development cycle\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-07-25T01:48:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MDExOA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460550118", "bodyText": "Can you remove this? Same for 3 method annotations below.", "author": "fwolter", "createdAt": "2020-07-26T17:01:46Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")", "originalCommit": "1beda2af42278133bf6c04d0a361266dbcc601da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MDE5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460550191", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n          \n          \n            \n                    logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());", "author": "fwolter", "createdAt": "2020-07-26T17:02:42Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());", "originalCommit": "1beda2af42278133bf6c04d0a361266dbcc601da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MDgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460550816", "bodyText": "These annotations can be removed. The compiler can detect it on local variables itself.", "author": "fwolter", "createdAt": "2020-07-26T17:08:02Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable", "originalCommit": "1beda2af42278133bf6c04d0a361266dbcc601da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MTI0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460551249", "bodyText": "This will throw an IllegalArgumentException, if the user doesn't set studerConfig.refreshSec or set it to 0. You could add a sanity check in initialize().", "author": "fwolter", "createdAt": "2020-07-26T17:12:42Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {", "originalCommit": "1beda2af42278133bf6c04d0a361266dbcc601da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0NjI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460846290", "bodyText": "I hadn't noticed, now I change it into required on config description XML files with a minimum value of 1. Refresh setted to 0 isn't handled by registerRegularPoll method but I based the code on the SunSpec binding. I tested it and I think a check is not needed", "author": "giovannimirulla", "createdAt": "2020-07-27T12:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MTI0OQ=="}], "type": "inlineReview"}, {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "url": "https://github.com/openhab/openhab-addons/commit/ef8c36c89dd25dfc366754439f5d01bf55f443ef", "message": "Applied feedback from fwolter (few minor things)\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-07-27T12:16:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNjcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477206724", "bodyText": "In the readme it is named refresh. In general configuration parameters, like refresh don't have the unit in the name. (Something we do require for static final fields.)", "author": "Hilbrand", "createdAt": "2020-08-26T10:44:05Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderConfiguration.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link StuderConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderConfiguration {\n+    /**\n+     * Address of slave device\n+     */\n+    public int slaveAddress = 0;\n+    /**\n+     * Refresh interval in seconds\n+     */\n+    public int refreshSec = 5;", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwOTc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477209761", "bodyText": "To make the code a little bit better return Float here. It allows for less casting in the rest of the code. Or you can just return the primitive float and instead of doing the null check later on, do the isNaN check. That way you can work with primitive values.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable Object hexToFloat(String hex) {\n          \n          \n            \n                public @Nullable Float hexToFloat(String hex) {", "author": "Hilbrand", "createdAt": "2020-08-26T10:50:13Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;\n+        }\n+    }\n+\n+    public enum State {\n+        OFF(0),\n+        ON(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        State(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static State getStateByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return State.OFF;\n+            case 1:\n+                return State.ON;\n+            default:\n+                return State.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTType {\n+        VT80(0),\n+        VT65(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTType(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTType getVTTypeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTType.VT80;\n+            case 1:\n+                return VTType.VT65;\n+            default:\n+                return VTType.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTMode {\n+        NIGHT(0),\n+        STARTUP(1),\n+        CHARGER(3),\n+        SECURITY(5),\n+        OFF(6),\n+        CHARGE(8),\n+        CHARGEV(9),\n+        CHARGEI(10),\n+        CHARGET(11),\n+        CHIBSP(12),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTMode getVTModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTMode.NIGHT;\n+            case 1:\n+                return VTMode.STARTUP;\n+            case 3:\n+                return VTMode.CHARGER;\n+            case 5:\n+                return VTMode.SECURITY;\n+            case 6:\n+                return VTMode.OFF;\n+            case 8:\n+                return VTMode.CHARGE;\n+            case 9:\n+                return VTMode.CHARGEV;\n+            case 10:\n+                return VTMode.CHARGEI;\n+            case 11:\n+                return VTMode.CHARGET;\n+            case 12:\n+                return VTMode.CHIBSP;\n+            default:\n+                return VTMode.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VSMode {\n+        NIGHT(0),\n+        SECURITY(1),\n+        OFF(2),\n+        CHARGE(3),\n+        CHARGEV(4),\n+        CHARGEI(5),\n+        CHARGEP(6),\n+        CHARGEIPV(7),\n+        CHARGET(8),\n+        CHIBSP(10),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VSMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VSMode getVSModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VSMode.NIGHT;\n+            case 1:\n+                return VSMode.SECURITY;\n+            case 2:\n+                return VSMode.OFF;\n+            case 3:\n+                return VSMode.CHARGE;\n+            case 4:\n+                return VSMode.CHARGEV;\n+            case 5:\n+                return VSMode.CHARGEI;\n+            case 6:\n+                return VSMode.CHARGEP;\n+            case 7:\n+                return VSMode.CHARGEIPV;\n+            case 8:\n+                return VSMode.CHARGET;\n+            case 10:\n+                return VSMode.CHIBSP;\n+            default:\n+                return VSMode.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Convert an hex string to float\n+     *\n+     * @param hex string to convert from\n+     * @return the converted float\n+     */\n+    public @Nullable Object hexToFloat(String hex) {", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwOTg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477209897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Object quantity = parser.hexToFloat(hexString);\n          \n          \n            \n                    Float quantity = parser.hexToFloat(hexString);", "author": "Hilbrand", "createdAt": "2020-08-26T10:50:30Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMDU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477210543", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));\n          \n          \n            \n                                    new QuantityType<>(quantity, UNIT_CHANNELS_BSP.get(registerNumber)));", "author": "Hilbrand", "createdAt": "2020-08-26T10:51:49Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            if (type.equals(THING_TYPE_BSP)) {\n+                updateState(CHANNELS_BSP.get(registerNumber),\n+                        new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMDY3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477210670", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void handlePolledDataVarioString(int registerNumber, Object quantity) {\n          \n          \n            \n                protected void handlePolledDataVarioString(int registerNumber, Float quantity) {", "author": "Hilbrand", "createdAt": "2020-08-26T10:52:04Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            if (type.equals(THING_TYPE_BSP)) {\n+                updateState(CHANNELS_BSP.get(registerNumber),\n+                        new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));\n+            } else if (type.equals(THING_TYPE_XTENDER)) {\n+                handlePolledDataXtender(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                handlePolledDataVarioTrack(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                handlePolledDataVarioString(registerNumber, quantity);\n+            }\n+        }\n+        resetCommunicationError();\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the VarioString slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     */\n+    protected void handlePolledDataVarioString(int registerNumber, Object quantity) {", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMDkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477210925", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            VSMode vsmode = StuderParser.getVSModeByCode((int) (float) quantity);\n          \n          \n            \n                            VSMode vsmode = StuderParser.getVSModeByCode(quantity.intValue());", "author": "Hilbrand", "createdAt": "2020-08-26T10:52:38Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            if (type.equals(THING_TYPE_BSP)) {\n+                updateState(CHANNELS_BSP.get(registerNumber),\n+                        new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));\n+            } else if (type.equals(THING_TYPE_XTENDER)) {\n+                handlePolledDataXtender(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                handlePolledDataVarioTrack(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                handlePolledDataVarioString(registerNumber, quantity);\n+            }\n+        }\n+        resetCommunicationError();\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the VarioString slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     */\n+    protected void handlePolledDataVarioString(int registerNumber, Object quantity) {\n+        switch (CHANNELS_VARIOSTRING.get(registerNumber)) {\n+            case CHANNEL_PV_OPERATING_MODE:\n+            case CHANNEL_PV1_OPERATING_MODE:\n+            case CHANNEL_PV2_OPERATING_MODE:\n+                VSMode vsmode = StuderParser.getVSModeByCode((int) (float) quantity);", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxODUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477218535", "bodyText": "It looks that in cases the value is unknown the channel should be set to UnDefType.UNDEF. That is the generic indicator the status is unknown. You seem to create a custom undefined state here. Same comment for the other enums. I also see this because the unknown state isn't mentioned in the options list in the thing xml files. That seem to suggest the unknown state should be the undef state I mentioned.", "author": "Hilbrand", "createdAt": "2020-08-26T11:08:05Z", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;", "originalCommit": "ef8c36c89dd25dfc366754439f5d01bf55f443ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk2MjY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r483962654", "bodyText": "I created it because the studer devices have UNKNOWN state and because when I pass the Mode on updateState, I pass as StringType. I change it and now when the UNKNOWN state occurs the updateState has UnDefType.UNDEF", "author": "giovannimirulla", "createdAt": "2020-09-05T15:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxODUzNQ=="}], "type": "inlineReview"}, {"oid": "bc1c2b70bba1430d2b6fa0207b4d0657f43ada84", "url": "https://github.com/openhab/openhab-addons/commit/bc1c2b70bba1430d2b6fa0207b4d0657f43ada84", "message": "[studer] Initial contribution\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:26Z", "type": "commit"}, {"oid": "a072bc4be83473b08801f7a4f3eda43bea159041", "url": "https://github.com/openhab/openhab-addons/commit/a072bc4be83473b08801f7a4f3eda43bea159041", "message": "Revert \"[studer] Initial contribution\"\n\nThis reverts commit 43bfe046e1844d7610d0b0fa6bcdcb57424ca1b6.\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:26Z", "type": "commit"}, {"oid": "11d65b2e7c1cf6b1938843c6ce6139fc6ad7ef33", "url": "https://github.com/openhab/openhab-addons/commit/11d65b2e7c1cf6b1938843c6ce6139fc6ad7ef33", "message": "[studer] Initial contribution\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:27Z", "type": "commit"}, {"oid": "af386adff7174fec80df3216cc1897315f7646d2", "url": "https://github.com/openhab/openhab-addons/commit/af386adff7174fec80df3216cc1897315f7646d2", "message": "Applied feedback from fwolter\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:28Z", "type": "commit"}, {"oid": "272be340f3262793636e88260b31ce0069b06134", "url": "https://github.com/openhab/openhab-addons/commit/272be340f3262793636e88260b31ce0069b06134", "message": "Preparation for next development cycle\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:28Z", "type": "commit"}, {"oid": "c27bd648b86911739f690cadb39c8454d3ca2441", "url": "https://github.com/openhab/openhab-addons/commit/c27bd648b86911739f690cadb39c8454d3ca2441", "message": "Applied feedback from fwolter (few minor things)\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:29Z", "type": "commit"}, {"oid": "db001b52f06c92529a370c6b2bbd6e80e25a2237", "url": "https://github.com/openhab/openhab-addons/commit/db001b52f06c92529a370c6b2bbd6e80e25a2237", "message": "Applied feedback from Hilbrand\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:29Z", "type": "commit"}, {"oid": "bd8046e6d6ba92e26edf7c76d58229bb58cdeb71", "url": "https://github.com/openhab/openhab-addons/commit/bd8046e6d6ba92e26edf7c76d58229bb58cdeb71", "message": "Update pom.xml\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:30Z", "type": "commit"}, {"oid": "bd8046e6d6ba92e26edf7c76d58229bb58cdeb71", "url": "https://github.com/openhab/openhab-addons/commit/bd8046e6d6ba92e26edf7c76d58229bb58cdeb71", "message": "Update pom.xml\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-05T16:11:30Z", "type": "forcePushed"}, {"oid": "9e79a63caf6156aceaf4f05ec98e24fe7da39dbb", "url": "https://github.com/openhab/openhab-addons/commit/9e79a63caf6156aceaf4f05ec98e24fe7da39dbb", "message": "Applied feedback from Hilbrand (few minor things)\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-06T20:07:20Z", "type": "commit"}, {"oid": "9e79a63caf6156aceaf4f05ec98e24fe7da39dbb", "url": "https://github.com/openhab/openhab-addons/commit/9e79a63caf6156aceaf4f05ec98e24fe7da39dbb", "message": "Applied feedback from Hilbrand (few minor things)\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-06T20:07:20Z", "type": "forcePushed"}, {"oid": "ef0613f7d88f6759fb3e25775f2dd2e791290d4d", "url": "https://github.com/openhab/openhab-addons/commit/ef0613f7d88f6759fb3e25775f2dd2e791290d4d", "message": "Merge branch '2.5.x' into 2.5.x", "committedDate": "2020-09-06T20:09:49Z", "type": "commit"}, {"oid": "a771929a9d8b15f36fc6bd9b0d135e45603a3d3c", "url": "https://github.com/openhab/openhab-addons/commit/a771929a9d8b15f36fc6bd9b0d135e45603a3d3c", "message": "Fix violations commit\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-06T20:28:40Z", "type": "commit"}, {"oid": "a771929a9d8b15f36fc6bd9b0d135e45603a3d3c", "url": "https://github.com/openhab/openhab-addons/commit/a771929a9d8b15f36fc6bd9b0d135e45603a3d3c", "message": "Fix violations commit\n\nSigned-off-by: Giovanni Mirulla <mirullagiovanni@gmail.com>", "committedDate": "2020-09-06T20:28:40Z", "type": "forcePushed"}]}