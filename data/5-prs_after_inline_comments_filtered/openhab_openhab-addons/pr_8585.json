{"pr_number": 8585, "pr_title": "[playstation] Initial contribution", "pr_createdAt": "2020-09-26T16:46:03Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8585", "timeline": [{"oid": "6cb4e2e27e831e0a20c73885d209a7418987be68", "url": "https://github.com/openhab/openhab-addons/commit/6cb4e2e27e831e0a20c73885d209a7418987be68", "message": "[playstation] Initial contribution.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-09-26T14:21:04Z", "type": "commit"}, {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879", "url": "https://github.com/openhab/openhab-addons/commit/a8c66b99af1137f6fe388c6072f14876186d7879", "message": "[playstation] Fixed problem after conversion to openHAB 3.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-09-26T16:35:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499722108", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        byte[] discover = \"SRCH\".getBytes();\n          \n          \n            \n                        byte[] discover = \"SRCH\".getBytes(StandardCharsets.UTF_8);", "author": "fwolter", "createdAt": "2020-10-05T16:24:01Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS3Handler.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.nio.channels.SocketChannel;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS3Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS3Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS3Handler.class);\n+    private static final int SOCKET_TIMEOUT_SECONDS = 2;\n+\n+    private PS3Configuration config = new PS3Configuration();\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public PS3Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!(command instanceof RefreshType)) {\n+            if (CHANNEL_POWER.equals(channelUID.getId()) && command instanceof OnOffType) {\n+                if (command.equals(OnOffType.ON)) {\n+                    turnOnPS3();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS3Configuration.class);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS3 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * This tries to connect to port 5223 on the PS3,\n+     * if the connection times out the PS3 is OFF, if connection is refused the PS3 is ON.\n+     */\n+    private void updateAllChannels() {\n+        try (SocketChannel channel = SocketChannel.open()) {\n+            Socket socket = channel.socket();\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            channel.configureBlocking(true);\n+            channel.connect(new InetSocketAddress(config.ipAddress, DEFAULT_PS3_WAKE_ON_LAN_PORT));\n+        } catch (IOException e) {\n+            String message = e.getMessage();\n+            if (message.contains(\"refused\")) {\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else if (message.contains(\"timed out\") || message.contains(\"is down\")) {\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            } else {\n+                logger.debug(\"PS3 read power, IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void turnOnPS3() {\n+        try {\n+            InetAddress bcAddress = InetAddress.getByName(\"255.255.255.255\");\n+\n+            // send WOL magic packet\n+            byte[] magicPacket = makeWOLMagicPacket(thing.getProperties().get(Thing.PROPERTY_MAC_ADDRESS));\n+            logger.debug(\"PS3 wol packet: {}\", magicPacket);\n+            DatagramPacket wakePacket = new DatagramPacket(magicPacket, magicPacket.length, bcAddress,\n+                    DEFAULT_PS3_WAKE_ON_LAN_PORT);\n+            // send discover\n+            byte[] discover = \"SRCH\".getBytes();", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NjUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500066513", "bodyText": "My hunch is that it's more towards ASCII since it's 4 bytes and not a String. Is it ok to use \"StandardCharsets.US_ASCII\" instead?", "author": "FluBBaOfWard", "createdAt": "2020-10-06T07:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwMDkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500400932", "bodyText": "Sure!", "author": "fwolter", "createdAt": "2020-10-06T15:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDQyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499724424", "bodyText": "Can you add a comment where you got the public key from, in case it needs an update?", "author": "fwolter", "createdAt": "2020-10-05T16:27:50Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Crypto.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Crypto} is responsible for encryption and decryption of\n+ * packets to / from the PS4.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Crypto {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Crypto.class);\n+\n+    private static final String PUBLIC_KEY = \"-----BEGIN PUBLIC KEY-----\"", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2MzU5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500063593", "bodyText": "I got it from the code of ps4waker. Should I write that in the code you mean?", "author": "FluBBaOfWard", "createdAt": "2020-10-06T07:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwMDI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500400287", "bodyText": "Yes, that would be nice.", "author": "fwolter", "createdAt": "2020-10-06T15:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499724901", "bodyText": "Logging to info should be used rarely. This could be debug or warn. Same for below.", "author": "fwolter", "createdAt": "2020-10-05T16:28:39Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Crypto.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Crypto} is responsible for encryption and decryption of\n+ * packets to / from the PS4.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Crypto {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Crypto.class);\n+\n+    private static final String PUBLIC_KEY = \"-----BEGIN PUBLIC KEY-----\"\n+            + \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfAO/MDk5ovZpp7xlG9J\"\n+            + \"JKc4Sg4ztAz+BbOt6Gbhub02tF9bryklpTIyzM0v817pwQ3TCoigpxEcWdTykhDL\"\n+            + \"cGhAbcp6E7Xh8aHEsqgtQ/c+wY1zIl3fU//uddlB1XuipXthDv6emXsyyU/tJWqc\"\n+            + \"zy9HCJncLJeYo7MJvf2TE9nnlVm1x4flmD0k1zrvb3MONqoZbKb/TQVuVhBv7SM+\"\n+            + \"U5PSi3diXIx1Nnj4vQ8clRNUJ5X1tT9XfVmKQS1J513XNZ0uYHYRDzQYujpLWucu\"\n+            + \"ob7v50wCpUm3iKP1fYCixMP6xFm0jPYz1YQaMV35VkYwc40qgk3av0PDS+1G0dCm\" + \"swIDAQAB\"\n+            + \"-----END PUBLIC KEY-----\";\n+\n+    private final byte[] remoteSeed = new byte[16];\n+    private final byte[] randomSeed = new byte[16];\n+    private @Nullable Cipher ps4Cipher;\n+    private @Nullable Cipher aesEncryptCipher;\n+    private @Nullable Cipher aesDecryptCipher;\n+\n+    PS4Crypto() {\n+        ps4Cipher = getRsaCipher(PUBLIC_KEY);\n+    }\n+\n+    void clearCiphers() {\n+        aesEncryptCipher = null;\n+        aesDecryptCipher = null;\n+    }\n+\n+    void initCiphers() {\n+        new SecureRandom().nextBytes(randomSeed);\n+        SecretKeySpec keySpec = new SecretKeySpec(randomSeed, \"AES\");\n+        IvParameterSpec ivSpec = new IvParameterSpec(remoteSeed);\n+        try {\n+            Cipher encCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+            encCipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n+            Cipher decCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+            decCipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n+            logger.debug(\"Ciphers initialized.\");\n+            aesEncryptCipher = encCipher;\n+            aesDecryptCipher = decCipher;\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+                | InvalidAlgorithmParameterException e) {\n+            logger.warn(\"Can not initialize ciphers.\", e);\n+        }\n+    }\n+\n+    int parseHelloResponsePacket(ByteBuffer rBuffer) {\n+        int result = -1;\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.info(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NzU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500067595", "bodyText": "I will change it to debug for now.\nQuestion, is warn better than info? Should info never be used in bindings?", "author": "FluBBaOfWard", "createdAt": "2020-10-06T07:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwMjk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500402998", "bodyText": "Warn would fit better in this case. Here is the definition of info: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-10-06T15:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNzc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499727745", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        scheduler.execute(() -> login());\n          \n          \n            \n                                        scheduler.execute(this::login);", "author": "fwolter", "createdAt": "2020-10-05T16:33:38Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2MjA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500062044", "bodyText": "not working since I have another login which takes an argument.", "author": "FluBBaOfWard", "createdAt": "2020-10-06T07:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNzc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjM3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499736379", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    secondScrStr = \"http://\" + config.ipAddress + \":\" + Integer.toString(port);\n          \n          \n            \n                                    secondScrStr = \"http://\" + config.ipAddress + \":\" + port;", "author": "fwolter", "createdAt": "2020-10-05T16:48:30Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + Integer.toString(port);", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2Nzc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r500067781", "bodyText": "Will fix.", "author": "FluBBaOfWard", "createdAt": "2020-10-06T07:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczODYyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499738621", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            scheduler.schedule(() -> login(), 20, TimeUnit.SECONDS);\n          \n          \n            \n                                            scheduler.schedule(this::login, 20, TimeUnit.SECONDS);", "author": "fwolter", "createdAt": "2020-10-05T16:52:15Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + Integer.toString(port);\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);\n+    }\n+\n+    private void waitAndConnectToPS4() {\n+        try {\n+            getConnection();\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendStandby() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStandbyPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Ask PS4 if the OSK is open so we can get and set text.\n+     */\n+    private void sendOSKStart() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStartPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Sets the entire OSK string on the PS4.\n+     *\n+     * @param text The text to set in the OSK.\n+     */\n+    private void setOSKText(String text) {\n+        logger.debug(\"Sending osk text packet,\\\"{}\\\"\", text);\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStringChangePacket(text);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Tries to start an application on the PS4.\n+     *\n+     * @param applicationId The unique id for the application (CUSAxxxxx).\n+     */\n+    private void startApplication(String applicationId) {\n+        ByteBuffer outPacket = PS4PacketHandler.makeApplicationPacket(applicationId);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    private void sendRemoteKey(int pushedKey) {\n+        try {\n+            SocketChannelHandler scHandler = socketChannelHandler;\n+            int preWait = (scHandler == null || !loggedIn) ? POST_CONNECT_SENDKEY_DELAY_MS : 0;\n+            SocketChannel channel = getConnection();\n+\n+            scheduler.schedule(() -> {\n+                ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n+                sendPacketEncrypted(outPacket, channel);\n+\n+                scheduler.schedule(() -> {\n+                    // Send remote key\n+                    ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n+                    sendPacketEncrypted(keyPacket, channel);\n+\n+                    scheduler.schedule(() -> {\n+                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n+                        sendPacketEncrypted(offPacket, channel);\n+\n+                        scheduler.schedule(() -> {\n+                            ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n+                            sendPacketEncrypted(closePacket, channel);\n+                        }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                    }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+            }, preWait, TimeUnit.MILLISECONDS);\n+\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void parseSearchResponse(DatagramPacket packet) {\n+        byte[] data = packet.getData();\n+        String message = new String(data, StandardCharsets.UTF_8);\n+        String applicationName = \"\";\n+        String applicationId = \"\";\n+\n+        String[] rowStrings = message.trim().split(\"\\\\r?\\\\n\");\n+        for (String row : rowStrings) {\n+            int index = row.indexOf(':');\n+            if (index == -1) {\n+                OnOffType power = null;\n+                if (row.contains(\"200\")) {\n+                    power = OnOffType.ON;\n+                } else if (row.contains(\"620\")) {\n+                    power = OnOffType.OFF;\n+                }\n+                if (power != null) {\n+                    updateState(CHANNEL_POWER, power);\n+                    if (!currentPower.equals(power)) {\n+                        currentPower = power;\n+                        if (power.equals(OnOffType.ON) && config.autoConnect) {\n+                            SocketChannelHandler scHandler = socketChannelHandler;\n+                            if (scHandler == null || !loggedIn) {\n+                                logger.debug(\"Trying to login after power on.\");\n+                                scheduler.schedule(() -> login(), 20, TimeUnit.SECONDS);", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MTIzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499741230", "bodyText": "See above. Logging to info.", "author": "fwolter", "createdAt": "2020-10-05T16:56:44Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/discovery/PlayStationDiscovery.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal.discovery;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.util.HexUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PlayStationDiscovery} is responsible for discovering\n+ * all PS4 devices\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")\n+public class PlayStationDiscovery extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PlayStationDiscovery.class);\n+\n+    private static final int DISCOVERY_TIMEOUT_SECONDS = 2;\n+\n+    private @Nullable NetworkAddressService networkAS;\n+\n+    public PlayStationDiscovery() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SECONDS * 2, true);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Updating discovered things (new scan)\");\n+        discover();\n+        discoverPS3();\n+    }\n+\n+    @Reference\n+    public void bindNetworkAddressService(NetworkAddressService network) {\n+        networkAS = network;\n+    }\n+\n+    private @Nullable InetAddress getBroadcastAdress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getConfiguredBroadcastAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                } else {\n+                    return InetAddress.getByName(\"255.255.255.255\");\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable InetAddress getIPv4Adress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getPrimaryIpv4HostAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Trying to discover all PS4 devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket(0, getIPv4Adress())) {\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(DISCOVERY_TIMEOUT_SECONDS * 1000);\n+\n+            InetAddress bcAddress = getBroadcastAdress();\n+\n+            // send discover\n+            byte[] discover = \"SRCH * HTTP/1.1\\ndevice-discovery-protocol-version:00020020\\n\".getBytes();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, bcAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            logger.debug(\"Discover message sent: '{}'\", discover);\n+\n+            // wait for responses\n+            while (true) {\n+                byte[] rxbuf = new byte[256];\n+                packet = new DatagramPacket(rxbuf, rxbuf.length);\n+                try {\n+                    socket.receive(packet);\n+                    parsePS4Packet(packet);\n+                } catch (SocketTimeoutException e) {\n+                    break; // leave the endless loop\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"No PS4 device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private synchronized void discoverPS3() {\n+        logger.trace(\"Trying to discover all PS3 devices that have \\\"Connect PS Vita System Using Network\\\" on.\");\n+\n+        InetAddress bcAddress = getBroadcastAdress();\n+        InetAddress localAddress = getIPv4Adress();\n+\n+        if (localAddress == null || bcAddress == null) {\n+            logger.info(\"No IP/Broadcast address found. Make sure OpenHab is configured!\");", "originalCommit": "a8c66b99af1137f6fe388c6072f14876186d7879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "url": "https://github.com/openhab/openhab-addons/commit/1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "message": "[playstation] Fixed requested changes from the pr.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-10-06T18:29:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501271751", "bodyText": "This type of nested delayed scheduling is what happens when use of sleep is forbidden. I'd almost prefer you using sleep here instead in order for the code to become linear, but sleep is only allowed on executors that your handler is managing and scheduler isn't one of them.\nThe biggest drawback of this nested scheduler structure is that you can't cancel these chain of commands once it gets started. Cancelling async tasks is a required part of cleanup when the handler is getting disposed of.\nI think the simplest and cleanest approach would be to manage your own ExecutorService instance in your handler which you can create through the Executors utility functions. Just make sure to use new NamedThreadFactory(<id>, true) for the ThreadFactory parameter. <id> can be any String value that you want, but since it is used as the part of the thread name you should make sure that you make it some value that can easily be tied back to this binding.\nThen you can rewrite this logic to use sleep inside of a lambda. Just make sure to exit early if an interrupt is received.\nprivate @Nullable ExecutorService executor;\nprivate @Nullable Future<?> sendKeyFuture;\n...\npublic void initialize(){\n...\n    executor = Executors.<you decide which method>;\n...\n}\n\npublic void dispose(){\n...\n    dispose(sendKeyFuture);\n    dispose(executor);\n...\n}\n\nprivate static void dispose(@Nullable Future<?> future){\n    if(future != null){\n        future.cancel(true);\n    }\n}\nprivate static void dispose(@Nullable ExecutorService executor){\n    if(executor != null){\n        executor.shutdownNow();\n    }\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> {\n          \n          \n            \n                            ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n          \n          \n            \n                            sendPacketEncrypted(outPacket, channel);\n          \n          \n            \n            \n          \n          \n            \n                            scheduler.schedule(() -> {\n          \n          \n            \n                                // Send remote key\n          \n          \n            \n                                ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n          \n          \n            \n                                sendPacketEncrypted(keyPacket, channel);\n          \n          \n            \n            \n          \n          \n            \n                                scheduler.schedule(() -> {\n          \n          \n            \n                                    ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n          \n          \n            \n                                    sendPacketEncrypted(offPacket, channel);\n          \n          \n            \n            \n          \n          \n            \n                                    scheduler.schedule(() -> {\n          \n          \n            \n                                        ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n          \n          \n            \n                                        sendPacketEncrypted(closePacket, channel);\n          \n          \n            \n                                    }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n          \n          \n            \n            \n          \n          \n            \n                                }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n          \n          \n            \n            \n          \n          \n            \n                            }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n          \n          \n            \n            \n          \n          \n            \n                        }, preWait, TimeUnit.MILLISECONDS);\n          \n          \n            \n                Future<?> sendKeyFuture = executor.submit(() -> {\n          \n          \n            \n                    try{\n          \n          \n            \n                        Thread.sleep(preWait);\n          \n          \n            \n                        ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n          \n          \n            \n                        sendPacketEncrypted(outPacket, channel);\n          \n          \n            \n                        Thread.sleep(MIN_SENDKEY_DELAY_MS);\n          \n          \n            \n                        \n          \n          \n            \n                        ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n          \n          \n            \n                        sendPacketEncrypted(keyPacket, channel);\n          \n          \n            \n                        Thread.sleep(MIN_HOLDKEY_DELAY_MS);\n          \n          \n            \n                        \n          \n          \n            \n                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n          \n          \n            \n                        sendPacketEncrypted(offPacket, channel);\n          \n          \n            \n                        Thread.sleep(MIN_SENDKEY_DELAY_MS);\n          \n          \n            \n                        \n          \n          \n            \n                        ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n          \n          \n            \n                        sendPacketEncrypted(closePacket, channel);\n          \n          \n            \n                    }catch(InterruptedException ex){\n          \n          \n            \n                        //do nothing, just exit early\n          \n          \n            \n                    }\n          \n          \n            \n                });\n          \n      \n    \n    \n  \n\nJust to clarify, in general sleep should be avoided if possible, but I think this circumstance is an exception since you have a series of chained operations that each need to be delayed from eachother.", "author": "cpmeister", "createdAt": "2020-10-07T19:54:41Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);\n+    }\n+\n+    private void waitAndConnectToPS4() {\n+        try {\n+            getConnection();\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendStandby() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStandbyPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Ask PS4 if the OSK is open so we can get and set text.\n+     */\n+    private void sendOSKStart() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStartPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Sets the entire OSK string on the PS4.\n+     *\n+     * @param text The text to set in the OSK.\n+     */\n+    private void setOSKText(String text) {\n+        logger.debug(\"Sending osk text packet,\\\"{}\\\"\", text);\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStringChangePacket(text);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Tries to start an application on the PS4.\n+     *\n+     * @param applicationId The unique id for the application (CUSAxxxxx).\n+     */\n+    private void startApplication(String applicationId) {\n+        ByteBuffer outPacket = PS4PacketHandler.makeApplicationPacket(applicationId);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    private void sendRemoteKey(int pushedKey) {\n+        try {\n+            SocketChannelHandler scHandler = socketChannelHandler;\n+            int preWait = (scHandler == null || !loggedIn) ? POST_CONNECT_SENDKEY_DELAY_MS : 0;\n+            SocketChannel channel = getConnection();\n+\n+            scheduler.schedule(() -> {\n+                ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n+                sendPacketEncrypted(outPacket, channel);\n+\n+                scheduler.schedule(() -> {\n+                    // Send remote key\n+                    ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n+                    sendPacketEncrypted(keyPacket, channel);\n+\n+                    scheduler.schedule(() -> {\n+                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n+                        sendPacketEncrypted(offPacket, channel);\n+\n+                        scheduler.schedule(() -> {\n+                            ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n+                            sendPacketEncrypted(closePacket, channel);\n+                        }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                    }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+            }, preWait, TimeUnit.MILLISECONDS);", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg5MjU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r506892568", "bodyText": "I'm sorry for the long delay in answering this, I just had to gather some energy.\nObviously I need to learn a bit more about openHAB and the ScheduledExecutorService.\nI guess the Scheduler keeps some kind of reference to my binding to keep the GC in the VM from releasing the memory as long as it's scheduled, right?\nAnd after openHAB has called dispose() I can't \"talk\" to openHAB any more, right?\nAre there any more things to look out for in this context?\nMaybe more to the point, what bad things can happen if a scheduler is not cancelled after dispose() is called?", "author": "FluBBaOfWard", "createdAt": "2020-10-17T08:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3ODc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r508978783", "bodyText": "ScheduledExecutorService isn't really an openHAB thing. It is part of the core java concurrency utilities. The key thing you need to understand about ScheduledExecutorService is that you can use it to run task asynchronously in another thread. The ScheduledExecutorService manages a pool of threads that it uses to execute tasks that are submitted to it through the execute or submit methods. The submit methods return a Future instance which is tied to the task you submitted. Through that Future you wait and get the result of the task (if any) or cancel that task.\n\nI guess the Scheduler keeps some kind of reference to my binding to keep the GC in the VM from releasing the memory as long as it's scheduled, right?\n\nThat is true as long as the task is running, one all asynchronous tasks stop running the references can be cleanup with the GC since they are no longer in use.\n\nAnd after openHAB has called dispose() I can't \"talk\" to openHAB any more, right?\n\nNot true, which is part of the problem. OpenHAB expects the handler to have been stopped after it calls dispose. There is nothing stopping the handler or binding from continuing to run and accessing openHAB resources even after dispose is called. But such a thing would cause a large number or problems which is why we enforce proper cleanup during dispose.\n\nAre there any more things to look out for in this context?\n\nAsynchronous tasks can get tricky when it comes to cleanup and especially so when asynchronous tasks spawn other asynchronous tasks. My best advise it to try to minimize such behaviors if possible.\n\nMaybe more to the point, what bad things can happen if a scheduler is not cancelled after dispose() is called?\n\nWell, the obvious problem is that the tasks keep running. If your task is meant to perform a periodic task, that periodic task would never stop. The only way to stop it at that point is to restart openHAB entirely.\nBut keep in mind, the scheduler that you inherit from the BaseThingHandler class doesn't require cleanup, only the Futures that you create with it require cleanup. Any executor service that you create yourself during initialize would require cleanup though.", "author": "cpmeister", "createdAt": "2020-10-21T04:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQxMTkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r523411929", "bodyText": "I absolutely understand that reoccurring tasks needs to be canceled, and that I can not / should not talk to openHAB after the plug-in is disposed.\nBut as the coding-guidelines for developing plug-ins states:\nOverridden methods from abstract classes or interfaces are expected to return fast unless otherwise stated in their JavaDoc. Expensive operations should therefore rather be scheduled as a job.\nI guess this includes the dispose method as well? And say I need to send a bye bye message that somehow has 5 second timeout, how does this match up?\nIf this was clearer in the documentation it would have saved me a lot of time and effort, if this can be made clear in Coding Guidelines I guess it can save some other developers time and effort as well.\nI really appreciate the time and effort you and the whole openHAB team has spent but I don't have enough of that right now.\nSo should I close this PR until I get some more of that, or just let it linger?", "author": "FluBBaOfWard", "createdAt": "2020-11-14T11:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQxMzE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r523413140", "bodyText": "For most protocols a bye message is not mandatory (in fact I don't know any binding where it has been absolutely necessary). The communication simply times out when OH disconnects and the other side drops the connection.\nIf I see correctly the nested scheduling in your code involves no periodic tasks and will finish deterministic. IMHO this is not as critical. But why don't you simply apply @cpmeister 's code suggestion, as it seems the last issue to merge this PR?", "author": "fwolter", "createdAt": "2020-11-14T12:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk1NDMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r523954303", "bodyText": "The point is not about this specific issue with nested schedulers, I can probably just do them serially with higher delays. The point I'm trying find an answer to is if all schedulers need to be tracked all the time so they can be canceled in the dispose method and if you in that case can't use schedulers in the dispose method, even though you have to return \"fast\".", "author": "FluBBaOfWard", "createdAt": "2020-11-16T08:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk1NzE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r523957187", "bodyText": "All tasks with a delay or periodic tasks should be tracked and cancelled in dispose(). Starting tasks in dispose() should be avoided, but if there is a necessity we can discuss that.", "author": "fwolter", "createdAt": "2020-11-16T08:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAyMTc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r524021772", "bodyText": "Ok. Are there any examples of such a tracker or guidelines on how to code one?\nCan I just keep a collection of scheduled futures and they remove themselves after they are finished? Can I get hold of the future from within the callback?\nSorry, feel like a noob right now.", "author": "FluBBaOfWard", "createdAt": "2020-11-16T09:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0OTAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r524049010", "bodyText": "The general approach is to store a reference everytime you schedule a task and invoke cancel() on it in dispose().\nYou could also add them to a list and iterate over the list in dispose(). But care must be taken that cancelled tasks are being removed to avoid memory leaks. An example can be found here: https://github.com/openhab/openhab-addons/pull/8634/files#diff-bbf0a7bd12dc4a35896e525a7330859ea9f746e9f895f7c4d1c9a1b76efacefbR202", "author": "fwolter", "createdAt": "2020-11-16T09:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI0MDI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r524240248", "bodyText": "The general approach is to store a reference everytime you schedule a task and invoke cancel() on it in dispose().\n\nThis works as long as you can be sure that the scheduler is not run again while one is still active, how does one make sure that is not the case?\n\nYou could also add them to a list and iterate over the list in dispose(). But care must be taken that cancelled tasks are being removed to avoid memory leaks.\n\nI guess all finished tasks must be removed as well? Otherwise you will just fill up the collection until dispose is called...\n\nAn example can be found here: https://github.com/openhab/openhab-addons/pull/8634/files#diff-bbf0a7bd12dc4a35896e525a7330859ea9f746e9f895f7c4d1c9a1b76efacefbR202\n\nThanks I will take a look.\nEdit: That looks good, I guess this would be nice to include in the Guidelines for noobs like me =)", "author": "FluBBaOfWard", "createdAt": "2020-11-16T12:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MjQyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501292426", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private synchronized void discover() {\n          \n          \n            \n                private synchronized void discoverPS4() {", "author": "cpmeister", "createdAt": "2020-10-07T20:33:31Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/discovery/PlayStationDiscovery.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal.discovery;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.util.HexUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PlayStationDiscovery} is responsible for discovering\n+ * all PS4 devices\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")\n+public class PlayStationDiscovery extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PlayStationDiscovery.class);\n+\n+    private static final int DISCOVERY_TIMEOUT_SECONDS = 2;\n+\n+    private @Nullable NetworkAddressService networkAS;\n+\n+    public PlayStationDiscovery() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SECONDS * 2, true);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Updating discovered things (new scan)\");\n+        discover();\n+        discoverPS3();\n+    }\n+\n+    @Reference\n+    public void bindNetworkAddressService(NetworkAddressService network) {\n+        networkAS = network;\n+    }\n+\n+    private @Nullable InetAddress getBroadcastAdress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getConfiguredBroadcastAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                } else {\n+                    return InetAddress.getByName(\"255.255.255.255\");\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable InetAddress getIPv4Adress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getPrimaryIpv4HostAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void discover() {", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4ODg1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r506888859", "bodyText": "Hopefully this won't be needed, we'll see November 19.", "author": "FluBBaOfWard", "createdAt": "2020-10-17T08:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MjQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI1MzI5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r529253298", "bodyText": "Fixed.", "author": "FluBBaOfWard", "createdAt": "2020-11-24T07:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MjQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MzgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501293838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")\n          \n          \n            \n            @Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"discovery.playstation\")", "author": "cpmeister", "createdAt": "2020-10-07T20:36:14Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/discovery/PlayStationDiscovery.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal.discovery;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.util.HexUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PlayStationDiscovery} is responsible for discovering\n+ * all PS4 devices\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5OTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501299407", "bodyText": "You should keep track of the returned future so that it can be canceled if this handler gets disposed.", "author": "cpmeister", "createdAt": "2020-10-07T20:46:02Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5OTU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501299565", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-07T20:46:20Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwMDY0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501300647", "bodyText": "At this point I think you might as well manage your own scheduler so that you can destroy any pending tasks a part of handler disposal. It would certainly be easier than trying to keep track of all of these scheduled task futures.", "author": "cpmeister", "createdAt": "2020-10-07T20:48:20Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);\n+    }\n+\n+    private void waitAndConnectToPS4() {\n+        try {\n+            getConnection();\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendStandby() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStandbyPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Ask PS4 if the OSK is open so we can get and set text.\n+     */\n+    private void sendOSKStart() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStartPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Sets the entire OSK string on the PS4.\n+     *\n+     * @param text The text to set in the OSK.\n+     */\n+    private void setOSKText(String text) {\n+        logger.debug(\"Sending osk text packet,\\\"{}\\\"\", text);\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStringChangePacket(text);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Tries to start an application on the PS4.\n+     *\n+     * @param applicationId The unique id for the application (CUSAxxxxx).\n+     */\n+    private void startApplication(String applicationId) {\n+        ByteBuffer outPacket = PS4PacketHandler.makeApplicationPacket(applicationId);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    private void sendRemoteKey(int pushedKey) {\n+        try {\n+            SocketChannelHandler scHandler = socketChannelHandler;\n+            int preWait = (scHandler == null || !loggedIn) ? POST_CONNECT_SENDKEY_DELAY_MS : 0;\n+            SocketChannel channel = getConnection();\n+\n+            scheduler.schedule(() -> {\n+                ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n+                sendPacketEncrypted(outPacket, channel);\n+\n+                scheduler.schedule(() -> {\n+                    // Send remote key\n+                    ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n+                    sendPacketEncrypted(keyPacket, channel);\n+\n+                    scheduler.schedule(() -> {\n+                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n+                        sendPacketEncrypted(offPacket, channel);\n+\n+                        scheduler.schedule(() -> {\n+                            ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n+                            sendPacketEncrypted(closePacket, channel);\n+                        }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                    }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+            }, preWait, TimeUnit.MILLISECONDS);\n+\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void parseSearchResponse(DatagramPacket packet) {\n+        byte[] data = packet.getData();\n+        String message = new String(data, StandardCharsets.UTF_8);\n+        String applicationName = \"\";\n+        String applicationId = \"\";\n+\n+        String[] rowStrings = message.trim().split(\"\\\\r?\\\\n\");\n+        for (String row : rowStrings) {\n+            int index = row.indexOf(':');\n+            if (index == -1) {\n+                OnOffType power = null;\n+                if (row.contains(\"200\")) {\n+                    power = OnOffType.ON;\n+                } else if (row.contains(\"620\")) {\n+                    power = OnOffType.OFF;\n+                }\n+                if (power != null) {\n+                    updateState(CHANNEL_POWER, power);\n+                    if (!currentPower.equals(power)) {\n+                        currentPower = power;\n+                        if (power.equals(OnOffType.ON) && config.autoConnect) {\n+                            SocketChannelHandler scHandler = socketChannelHandler;\n+                            if (scHandler == null || !loggedIn) {\n+                                logger.debug(\"Trying to login after power on.\");\n+                                scheduler.schedule(() -> login(), 20, TimeUnit.SECONDS);", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwMjQ0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501302449", "bodyText": "You should check whether or not this handler has been disposed of before you try scheduling more things here.", "author": "cpmeister", "createdAt": "2020-10-07T20:51:40Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS3Handler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS3Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS3Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS3Handler.class);\n+    private static final int SOCKET_TIMEOUT_SECONDS = 2;\n+\n+    private PS3Configuration config = new PS3Configuration();\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public PS3Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!(command instanceof RefreshType)) {\n+            if (CHANNEL_POWER.equals(channelUID.getId()) && command instanceof OnOffType) {\n+                if (command.equals(OnOffType.ON)) {\n+                    turnOnPS3();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS3Configuration.class);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS3 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * This tries to connect to port 5223 on the PS3,\n+     * if the connection times out the PS3 is OFF, if connection is refused the PS3 is ON.\n+     */\n+    private void updateAllChannels() {\n+        try (SocketChannel channel = SocketChannel.open()) {\n+            Socket socket = channel.socket();\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            channel.configureBlocking(true);\n+            channel.connect(new InetSocketAddress(config.ipAddress, DEFAULT_PS3_WAKE_ON_LAN_PORT));\n+        } catch (IOException e) {\n+            String message = e.getMessage();\n+            if (message.contains(\"refused\")) {\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else if (message.contains(\"timed out\") || message.contains(\"is down\")) {\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            } else {\n+                logger.debug(\"PS3 read power, IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void turnOnPS3() {\n+        try {\n+            InetAddress bcAddress = InetAddress.getByName(\"255.255.255.255\");\n+\n+            // send WOL magic packet\n+            byte[] magicPacket = makeWOLMagicPacket(thing.getProperties().get(Thing.PROPERTY_MAC_ADDRESS));\n+            logger.debug(\"PS3 wol packet: {}\", magicPacket);\n+            DatagramPacket wakePacket = new DatagramPacket(magicPacket, magicPacket.length, bcAddress,\n+                    DEFAULT_PS3_WAKE_ON_LAN_PORT);\n+            // send discover\n+            byte[] discover = \"SRCH\".getBytes(StandardCharsets.US_ASCII);\n+            DatagramPacket srchPacket = new DatagramPacket(discover, discover.length, bcAddress,\n+                    DEFAULT_PS3_WAKE_ON_LAN_PORT);\n+            logger.debug(\"Search message: '{}'\", discover);\n+\n+            // wait for responses\n+            byte[] rxbuf = new byte[256];\n+            DatagramPacket receivePacket = new DatagramPacket(rxbuf, rxbuf.length);\n+            scheduler.execute(() -> wakeMethod(srchPacket, receivePacket, wakePacket, 34));\n+        } catch (IOException e) {\n+            logger.debug(\"No PS3 device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void wakeMethod(DatagramPacket srchPacket, DatagramPacket receivePacket, DatagramPacket wakePacket,\n+            int triesLeft) {\n+        try (DatagramSocket searchSocket = new DatagramSocket(); DatagramSocket wakeSocket = new DatagramSocket();) {\n+            wakeSocket.setBroadcast(true);\n+            searchSocket.setBroadcast(true);\n+            searchSocket.setSoTimeout(1000);\n+\n+            searchSocket.send(srchPacket);\n+            try {\n+                searchSocket.receive(receivePacket);\n+                logger.debug(\"PS3 started?: '{}'\", receivePacket);\n+                return;\n+            } catch (SocketTimeoutException e) {\n+                // try again\n+            }\n+            wakeSocket.send(wakePacket);\n+            if (triesLeft <= 0) {\n+                logger.debug(\"PS3 not started!\");\n+            } else {\n+                scheduler.execute(() -> wakeMethod(srchPacket, receivePacket, wakePacket, triesLeft - 1));", "originalCommit": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d616c1ef3e50524875d201dd4c89027c4bfbd0b", "url": "https://github.com/openhab/openhab-addons/commit/5d616c1ef3e50524875d201dd4c89027c4bfbd0b", "message": "[playstation] Some more fixes for the PR.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-10-17T08:36:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTI0NTQ2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r519245460", "bodyText": "This should be set to false during initialization. Otherwise the handler instance can't be reused.", "author": "cpmeister", "createdAt": "2020-11-08T02:08:33Z", "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS3Handler.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private final Logger logger = LoggerFactory.getLogger(PS3Handler.class);\n     private static final int SOCKET_TIMEOUT_SECONDS = 2;\n+    private boolean isDisposed = false;", "originalCommit": "5d616c1ef3e50524875d201dd4c89027c4bfbd0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a0b70c027d0582a316c9d0906a2521213fc518e2", "url": "https://github.com/openhab/openhab-addons/commit/a0b70c027d0582a316c9d0906a2521213fc518e2", "message": "[playstation] Fixed initialisation of isDisposed in PS3Handler.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-11-14T11:41:26Z", "type": "commit"}, {"oid": "f1e4cb61f06f97b34fb54ac02fe2f70ae82fe156", "url": "https://github.com/openhab/openhab-addons/commit/f1e4cb61f06f97b34fb54ac02fe2f70ae82fe156", "message": "[playstation] Fixed handling of Futures during dispose.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-11-23T18:22:27Z", "type": "commit"}, {"oid": "0f808c5c1afe108e13039fe5e84266a257cf64a4", "url": "https://github.com/openhab/openhab-addons/commit/0f808c5c1afe108e13039fe5e84266a257cf64a4", "message": "[playstation] Hopefully fixed the null issue.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>", "committedDate": "2020-11-24T17:10:38Z", "type": "commit"}]}