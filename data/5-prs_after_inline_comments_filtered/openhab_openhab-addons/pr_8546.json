{"pr_number": 8546, "pr_title": "[unifiedremote] Initial contribution", "pr_createdAt": "2020-09-22T15:53:26Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8546", "timeline": [{"oid": "156fed2f7e7906edd05b042d10fb188b954fd852", "url": "https://github.com/openhab/openhab-addons/commit/156fed2f7e7906edd05b042d10fb188b954fd852", "message": "[unifiedremote] add binding code\n\nSigned-off-by: GiviMAD <miguelwork92@gmail.com>", "committedDate": "2020-09-22T15:56:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832912", "bodyText": "The HTTP can be retrieved from the framework via injection. Then, resources are re-used. See for example https://github.com/openhab/openhab-addons/blob/main/bundles/org.openhab.binding.automower/src/main/java/org/openhab/binding/automower/internal/AutomowerHandlerFactory.java#L60", "author": "fwolter", "createdAt": "2020-10-10T21:13:45Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832933", "bodyText": "This could be static. Same for the upper case fields below. Static fields should be moved to the top of the class.", "author": "fwolter", "createdAt": "2020-10-10T21:14:06Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzA5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833099", "bodyText": "This could be removed if you use the framework's HttpClient.", "author": "fwolter", "createdAt": "2020-10-10T21:15:49Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;\n+    private final String CONNECTION_ID_HEADER = \"UR-Connection-ID\";\n+    private @Nullable String connectionID;\n+    private @Nullable String connectionGUID;\n+\n+    private final String MOUSE_REMOTE = \"Relmtech.Basic Input\";\n+    private final String NAVIGATION_REMOTE = \"Unified.Navigation\";\n+    private final String POWER_REMOTE = \"Unified.Power\";\n+    private final String MEDIA_REMOTE = \"Unified.Media\";\n+    private final String MONITOR_REMOTE = \"Unified.Monitor\";\n+\n+    public UnifiedRemoteConnection(String host) {\n+        url = \"http://\" + host + \":\" + WEB_CLIENT_PORT + \"/client/\";\n+    }\n+\n+    public void authenticate() throws Exception {\n+        ContentResponse response = null;\n+        connectionGUID = \"web-\" + UUID.randomUUID().toString();\n+        if (!http.isStarted()) {\n+            http.start();\n+        }", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833139", "bodyText": "Better specify a timeout. Many bindings use 10 sec.", "author": "fwolter", "createdAt": "2020-10-10T21:16:14Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;\n+    private final String CONNECTION_ID_HEADER = \"UR-Connection-ID\";\n+    private @Nullable String connectionID;\n+    private @Nullable String connectionGUID;\n+\n+    private final String MOUSE_REMOTE = \"Relmtech.Basic Input\";\n+    private final String NAVIGATION_REMOTE = \"Unified.Navigation\";\n+    private final String POWER_REMOTE = \"Unified.Power\";\n+    private final String MEDIA_REMOTE = \"Unified.Media\";\n+    private final String MONITOR_REMOTE = \"Unified.Monitor\";\n+\n+    public UnifiedRemoteConnection(String host) {\n+        url = \"http://\" + host + \":\" + WEB_CLIENT_PORT + \"/client/\";\n+    }\n+\n+    public void authenticate() throws Exception {\n+        ContentResponse response = null;\n+        connectionGUID = \"web-\" + UUID.randomUUID().toString();\n+        if (!http.isStarted()) {\n+            http.start();\n+        }\n+        response = http.GET(getPath(\"connect\"));", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzY2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833663", "bodyText": "This can also be removed if using the framework's HttpClient.", "author": "fwolter", "createdAt": "2020-10-10T21:23:15Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;\n+    private final String CONNECTION_ID_HEADER = \"UR-Connection-ID\";\n+    private @Nullable String connectionID;\n+    private @Nullable String connectionGUID;\n+\n+    private final String MOUSE_REMOTE = \"Relmtech.Basic Input\";\n+    private final String NAVIGATION_REMOTE = \"Unified.Navigation\";\n+    private final String POWER_REMOTE = \"Unified.Power\";\n+    private final String MEDIA_REMOTE = \"Unified.Media\";\n+    private final String MONITOR_REMOTE = \"Unified.Monitor\";\n+\n+    public UnifiedRemoteConnection(String host) {\n+        url = \"http://\" + host + \":\" + WEB_CLIENT_PORT + \"/client/\";\n+    }\n+\n+    public void authenticate() throws Exception {\n+        ContentResponse response = null;\n+        connectionGUID = \"web-\" + UUID.randomUUID().toString();\n+        if (!http.isStarted()) {\n+            http.start();\n+        }\n+        response = http.GET(getPath(\"connect\"));\n+        JsonObject responseBody = jsonParser.parse(response.getContentAsString()).getAsJsonObject();\n+        connectionID = responseBody.get(\"id\").getAsString();\n+\n+        String password = UUID.randomUUID().toString();\n+        JsonObject authPayload = new JsonObject();\n+        authPayload.addProperty(\"Action\", 0);\n+        authPayload.addProperty(\"Request\", 0);\n+        authPayload.addProperty(\"Version\", 10);\n+        authPayload.addProperty(\"Password\", password);\n+        authPayload.addProperty(\"Platform\", \"web\");\n+        authPayload.addProperty(\"Source\", connectionGUID);\n+        request(authPayload);\n+\n+        JsonObject capabilitiesPayload = new JsonObject();\n+        JsonObject capabilitiesInnerPayload = new JsonObject();\n+        capabilitiesInnerPayload.addProperty(\"Actions\", true);\n+        capabilitiesInnerPayload.addProperty(\"Sync\", true);\n+        capabilitiesInnerPayload.addProperty(\"Grid\", true);\n+        capabilitiesInnerPayload.addProperty(\"Fast\", false);\n+        capabilitiesInnerPayload.addProperty(\"Loading\", true);\n+        capabilitiesInnerPayload.addProperty(\"Encryption2\", true);\n+        capabilitiesPayload.add(\"Capabilities\", capabilitiesInnerPayload);\n+        capabilitiesPayload.addProperty(\"Action\", 1);\n+        capabilitiesPayload.addProperty(\"Request\", 1);\n+        capabilitiesPayload.addProperty(\"Source\", connectionGUID);\n+        request(capabilitiesPayload);\n+    }\n+\n+    public ContentResponse mouseMove(String jsonIntArray)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        JsonArray cordinates = jsonParser.parse(jsonIntArray).getAsJsonArray();\n+        int x = cordinates.get(0).getAsInt();\n+        int y = cordinates.get(1).getAsInt();\n+        return this.execRemoteAction(\"Relmtech.Basic Input\", \"delta\",\n+                wrapValues(new String[] { \"0\", Integer.toString(x), Integer.toString(y) }));\n+    }\n+\n+    public ContentResponse sendKey(String key) throws InterruptedException, ExecutionException, TimeoutException {\n+        String remoteID = \"\";\n+        String actionName = \"\";\n+        String value = null;\n+        switch (key) {\n+            case \"LEFT_CLICK\":\n+                remoteID = MOUSE_REMOTE;\n+                actionName = \"left\";\n+                break;\n+            case \"RIGHT_CLICK\":\n+                remoteID = MOUSE_REMOTE;\n+                actionName = \"right\";\n+                break;\n+            case \"LOCK\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"lock\";\n+                break;\n+            case \"UNLOCK\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"unlock\";\n+                break;\n+            case \"SLEEP\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"sleep\";\n+                break;\n+            case \"SHUTDOWN\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"shutdown\";\n+                break;\n+            case \"RESTART\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"restart\";\n+                break;\n+            case \"LOGOFF\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"logoff\";\n+                break;\n+            case \"PLAY/PAUSE\":\n+            case \"PLAY\":\n+            case \"PAUSE\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"play_pause\";\n+                break;\n+            case \"NEXT\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"next\";\n+                break;\n+            case \"PREVIOUS\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"previous\";\n+                break;\n+            case \"STOP\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"stop\";\n+                break;\n+            case \"VOLUME_MUTE\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"volume_mute\";\n+                break;\n+            case \"VOLUME_UP\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"volume_up\";\n+                break;\n+            case \"VOLUME_DOWN\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"volume_down\";\n+                break;\n+            case \"BRIGHTNESS_UP\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"brightness_up\";\n+                break;\n+            case \"BRIGHTNESS_DOWN\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"brightness_down\";\n+                break;\n+            case \"MONITOR_OFF\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"turn_off\";\n+                break;\n+            case \"MONITOR_ON\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"turn_on\";\n+                break;\n+            case \"ESCAPE\":\n+            case \"SPACE\":\n+            case \"BACK\":\n+            case \"LWIN\":\n+            case \"CONTROL\":\n+            case \"TAB\":\n+            case \"MENU\":\n+            case \"RETURN\":\n+            case \"UP\":\n+            case \"DOWN\":\n+            case \"LEFT\":\n+            case \"RIGHT\":\n+                remoteID = NAVIGATION_REMOTE;\n+                actionName = \"toggle\";\n+                value = key;\n+                break;\n+        }\n+        JsonArray wrappedValues = null;\n+        if (value != null) {\n+            wrappedValues = wrapValues(new String[] { value });\n+        }\n+        return this.execRemoteAction(remoteID, actionName, wrappedValues);\n+    }\n+\n+    public ContentResponse keepAlive() throws InterruptedException, ExecutionException, TimeoutException {\n+        JsonObject payload = new JsonObject();\n+        payload.addProperty(\"KeepAlive\", true);\n+        payload.addProperty(\"Source\", connectionGUID);\n+        return request(payload);\n+    }\n+\n+    private ContentResponse execRemoteAction(String remoteID, String name, @Nullable JsonElement values)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        JsonObject payload = new JsonObject();\n+        JsonObject runInnerPayload = new JsonObject();\n+        JsonObject extrasInnerPayload = new JsonObject();\n+        if (values != null) {\n+            extrasInnerPayload.add(\"Values\", values);\n+            runInnerPayload.add(\"Extras\", extrasInnerPayload);\n+        }\n+        runInnerPayload.addProperty(\"Name\", name);\n+        payload.addProperty(\"ID\", remoteID);\n+        payload.addProperty(\"Action\", 7);\n+        payload.addProperty(\"Request\", 7);\n+        payload.add(\"Run\", runInnerPayload);\n+        payload.addProperty(\"Source\", connectionGUID);\n+        return request(payload);\n+    }\n+\n+    private ContentResponse request(JsonObject content)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Request request = http.POST(getPath(\"request\"));\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/json\");\n+        if (connectionID != null)\n+            request.header(CONNECTION_ID_HEADER, connectionID);\n+        String stringContent = content.toString();\n+        logger.debug(\"[Request Payload {} ]\", stringContent);\n+        request.content(new StringContentProvider(stringContent, \"utf-8\"));\n+        return request.send();\n+    }\n+\n+    private JsonArray wrapValues(String[] commandValues) {\n+        JsonArray values = new JsonArray();\n+        for (String value : commandValues) {\n+            JsonObject valueWrapper = new JsonObject();\n+            valueWrapper.addProperty(\"Value\", value);\n+            values.add(valueWrapper);\n+        }\n+        return values;\n+    }\n+\n+    private String getPath(String path) {\n+        return url + path;\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (http.isStarted()) {\n+            try {\n+                http.stop();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833706", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2020-10-10T21:23:45Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzczMg==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833732", "bodyText": "Loggers should not be final.", "author": "fwolter", "createdAt": "2020-10-10T21:24:00Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833818", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    client.call(serverInfo -> addNewServer(serverInfo));\n          \n          \n            \n                    client.call(this::addNewServer);", "author": "fwolter", "createdAt": "2020-10-10T21:24:47Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzg4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833883", "bodyText": "Can you add the representationProperty?", "author": "fwolter", "createdAt": "2020-10-10T21:25:19Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834012", "bodyText": "See above. Append unit.", "author": "fwolter", "createdAt": "2020-10-10T21:26:54Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834185", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-10-10T21:29:24Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDQxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834410", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "author": "fwolter", "createdAt": "2020-10-10T21:31:33Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834431", "bodyText": "See above. logging", "author": "fwolter", "createdAt": "2020-10-10T21:31:49Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {\n+                        logger.error(\"Exception parsing server discovery response from {}: {}\", host, ex.getMessage());", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDQ4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834488", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-10-10T21:32:33Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {\n+                        logger.error(\"Exception parsing server discovery response from {}: {}\", host, ex.getMessage());\n+                    }\n+                }\n+            } catch (SocketTimeoutException ste) {\n+                logger.debug(\"SocketTimeoutException during socket operation: {}\", ste.getMessage());\n+            } catch (IOException ioe) {\n+                logger.error(\"IOException during socket operation: {}\", ioe.getMessage());", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834557", "bodyText": "You could add this to the finally block, to close the socket also if an unchecked exception is thrown.", "author": "fwolter", "createdAt": "2020-10-10T21:33:14Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {\n+                        logger.error(\"Exception parsing server discovery response from {}: {}\", host, ex.getMessage());\n+                    }\n+                }\n+            } catch (SocketTimeoutException ste) {\n+                logger.debug(\"SocketTimeoutException during socket operation: {}\", ste.getMessage());\n+            } catch (IOException ioe) {\n+                logger.error(\"IOException during socket operation: {}\", ioe.getMessage());\n+            }\n+            socket.close();", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834639", "bodyText": "As the Thing doesn't provide any data, this could be removed entirely.", "author": "fwolter", "createdAt": "2020-10-10T21:34:21Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public UnifiedRemoteHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO: nothing to do for now\n+            return;\n+        }", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834834", "bodyText": "When using the framework's HttpClient, this could be the concrete Exceptions.", "author": "fwolter", "createdAt": "2020-10-10T21:36:18Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public UnifiedRemoteHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO: nothing to do for now\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        if (!isLinked(channelId))\n+            return;\n+        String stringCommand = command.toFullString();\n+        try {\n+            if (connection != null) {\n+                ContentResponse response;\n+                switch (channelId) {\n+                    case MOUSE_CHANNEL:\n+                        response = connection.mouseMove(stringCommand);\n+                        break;\n+                    case SEND_KEY_CHANNEL:\n+                        response = connection.sendKey(stringCommand);\n+                        break;\n+                    default:\n+                        return;\n+                }\n+                if (isErrorResponse(response)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Session expired\");\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection not initialized\");\n+            }\n+        } catch (Exception e) {", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNTAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502835017", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-10-10T21:38:38Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public UnifiedRemoteHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO: nothing to do for now\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        if (!isLinked(channelId))\n+            return;\n+        String stringCommand = command.toFullString();\n+        try {\n+            if (connection != null) {\n+                ContentResponse response;\n+                switch (channelId) {\n+                    case MOUSE_CHANNEL:\n+                        response = connection.mouseMove(stringCommand);\n+                        break;\n+                    case SEND_KEY_CHANNEL:\n+                        response = connection.sendKey(stringCommand);\n+                        break;\n+                    default:\n+                        return;\n+                }\n+                if (isErrorResponse(response)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Session expired\");\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection not initialized\");\n+            }\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Server request fail: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection = getNewConnection();\n+        initConnectionChecker();\n+    }\n+\n+    private UnifiedRemoteConnection getNewConnection() {\n+        config = getConfigAs(UnifiedRemoteConfiguration.class);\n+        return new UnifiedRemoteConnection(config.host);\n+    }\n+\n+    private void initConnectionChecker() {\n+        stopConnectionChecker();\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(() -> {\n+            try {\n+                ThingStatus status = thing.getStatus();\n+                if ((status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN) && connection != null) {\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                } else if (status == ThingStatus.ONLINE) {\n+                    if (isErrorResponse(connection.keepAlive())) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Keep alive failed\");\n+                    }\n+                }\n+            } catch (Exception e) {", "originalCommit": "156fed2f7e7906edd05b042d10fb188b954fd852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "243419e3850f4eb0ea6c65754992882eb4fbd3b7", "url": "https://github.com/openhab/openhab-addons/commit/243419e3850f4eb0ea6c65754992882eb4fbd3b7", "message": "[unifiedremote] pr review changes\n\nSigned-off-by: GiviMAD <miguelwork92@gmail.com>", "committedDate": "2020-10-18T12:54:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5NDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r507194070", "bodyText": "The representation property must be the name of the property, not the value.", "author": "fwolter", "createdAt": "2020-10-18T18:07:15Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(this::addNewServer);\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(serverInfo.macAddress)", "originalCommit": "243419e3850f4eb0ea6c65754992882eb4fbd3b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5NDM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r507194356", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (connectionCheckerSchedule != null && !connectionCheckerSchedule.isCancelled()) {\n          \n          \n            \n                    if (connectionCheckerSchedule != null) {", "author": "fwolter", "createdAt": "2020-10-18T18:09:58Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.net.ConnectException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private HttpClient httpClient;\n+\n+    public UnifiedRemoteHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channelId = channelUID.getId();\n+        if (!isLinked(channelId))\n+            return;\n+        String stringCommand = command.toFullString();\n+        try {\n+            if (connection != null) {\n+                ContentResponse response;\n+                switch (channelId) {\n+                    case MOUSE_CHANNEL:\n+                        response = connection.mouseMove(stringCommand);\n+                        break;\n+                    case SEND_KEY_CHANNEL:\n+                        response = connection.sendKey(stringCommand);\n+                        break;\n+                    default:\n+                        return;\n+                }\n+                if (isErrorResponse(response)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Session expired\");\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection not initialized\");\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            if (e.getCause() instanceof ConnectException) {\n+                // we assume thing is offline\n+                updateStatus(ThingStatus.OFFLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Unexpected exception: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection = getNewConnection();\n+        initConnectionChecker();\n+    }\n+\n+    private UnifiedRemoteConnection getNewConnection() {\n+        config = getConfigAs(UnifiedRemoteConfiguration.class);\n+        return new UnifiedRemoteConnection(this.httpClient, config.host);\n+    }\n+\n+    private void initConnectionChecker() {\n+        stopConnectionChecker();\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(() -> {\n+            try {\n+                ThingStatus status = thing.getStatus();\n+                if ((status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN) && connection != null) {\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                } else if (status == ThingStatus.ONLINE) {\n+                    if (isErrorResponse(connection.keepAlive())) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Keep alive failed\");\n+                    }\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                if (e.getCause() instanceof ConnectException) {\n+                    // we assume thing is offline\n+                    updateStatus(ThingStatus.OFFLINE);\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Unexpected exception: \" + e.getMessage());\n+                }\n+            }\n+        }, 0, 40, TimeUnit.SECONDS);\n+    }\n+\n+    private void stopConnectionChecker() {\n+        if (connectionCheckerSchedule != null && !connectionCheckerSchedule.isCancelled()) {", "originalCommit": "243419e3850f4eb0ea6c65754992882eb4fbd3b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "03b6ebf0d2a2c66b182dc91c4b91f52e476e8985", "url": "https://github.com/openhab/openhab-addons/commit/03b6ebf0d2a2c66b182dc91c4b91f52e476e8985", "message": "[unifiedremote] pr review changes\n\nSigned-off-by: GiviMAD <miguelwork92@gmail.com>", "committedDate": "2020-10-18T18:33:57Z", "type": "commit"}, {"oid": "ecf45849c3c45f786fb05ca0b6e0701cb6302fe0", "url": "https://github.com/openhab/openhab-addons/commit/ecf45849c3c45f786fb05ca0b6e0701cb6302fe0", "message": "Merge branch 'main' into unifiedremote", "committedDate": "2020-10-18T18:50:25Z", "type": "commit"}, {"oid": "e9e349776eac4b7028ed63aeb58a3846e43e60d7", "url": "https://github.com/openhab/openhab-addons/commit/e9e349776eac4b7028ed63aeb58a3846e43e60d7", "message": "Merge pull request #1 from openhab/main\n\n[MeteoAlerte] Update for OH3 (#8801)", "committedDate": "2020-10-20T00:33:23Z", "type": "commit"}, {"oid": "32c31439ded04dba4d5abe761f1b8a0473335ae6", "url": "https://github.com/openhab/openhab-addons/commit/32c31439ded04dba4d5abe761f1b8a0473335ae6", "message": "Merge branch 'main' into unifiedremote", "committedDate": "2020-10-21T12:45:49Z", "type": "commit"}, {"oid": "563a20878a8d15b62d13c821317e3161a534dc69", "url": "https://github.com/openhab/openhab-addons/commit/563a20878a8d15b62d13c821317e3161a534dc69", "message": "Merge pull request #2 from openhab/main\n\nmerge master", "committedDate": "2020-10-21T18:49:09Z", "type": "commit"}, {"oid": "b4f98a6d277424bd773d2617e0539b9c1c9b5359", "url": "https://github.com/openhab/openhab-addons/commit/b4f98a6d277424bd773d2617e0539b9c1c9b5359", "message": "pr review: fix warnings and minor changes\n\nSigned-off-by: GiviMAD <miguelwork92@gmail.com>", "committedDate": "2020-10-23T16:45:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyNjMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r511326329", "bodyText": "Is this nested class even needed? It doesn't have any fields. Can you just move all this logic into the UnifiedRemoteDiscoveryService class instead?", "author": "cpmeister", "createdAt": "2020-10-24T06:12:36Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(this::addNewServer);\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_MAC_ADDRESS, serverInfo.macAddress);\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(PARAMETER_MAC_ADDRESS)\n+                        .withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {", "originalCommit": "b4f98a6d277424bd773d2617e0539b9c1c9b5359", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyNjM0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r511326342", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.unifiedremote\")", "author": "cpmeister", "createdAt": "2020-10-24T06:12:50Z", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")", "originalCommit": "b4f98a6d277424bd773d2617e0539b9c1c9b5359", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5de85c0cd6193de7503f1e6424a02d768733af58", "url": "https://github.com/openhab/openhab-addons/commit/5de85c0cd6193de7503f1e6424a02d768733af58", "message": "pr review and minor changes\n\nSigned-off-by: GiviMAD <miguelwork92@gmail.com>", "committedDate": "2020-10-24T08:20:25Z", "type": "commit"}]}