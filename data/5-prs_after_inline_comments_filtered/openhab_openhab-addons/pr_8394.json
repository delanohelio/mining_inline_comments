{"pr_number": 8394, "pr_title": "[yioremote]YIO Remote Binding initial contribution", "pr_createdAt": "2020-09-04T06:48:28Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8394", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485171013", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-09-08T20:14:59Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+\n+    /**\n+     * Sample configuration parameter. Replace with your own.\n+     */", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MDI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485360297", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-09T06:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTQyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485171425", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-09-08T20:15:35Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615605", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-10T20:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172264", "bodyText": "You could store config to a local variable and do a null check on that to eliminate the compiler warning.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    config = getConfigAs(YIOremoteConfiguration.class);\n          \n          \n            \n                    YIOremoteConfiguration localConfig = config = getConfigAs(YIOremoteConfiguration.class);", "author": "fwolter", "createdAt": "2020-09-08T20:17:23Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NDQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485364485", "bodyText": "Cool Idea thanks for the Help :)", "author": "miloit", "createdAt": "2020-09-09T06:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172412", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-09-08T20:17:43Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjYxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662611", "bodyText": "removed", "author": "miloit", "createdAt": "2020-09-10T22:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172762", "bodyText": "Can you use the debugger instead of logging this? Same for below", "author": "fwolter", "createdAt": "2020-09-08T20:18:24Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615898", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-10T20:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662560", "bodyText": "yes solved", "author": "miloit", "createdAt": "2020-09-10T22:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172918", "bodyText": "Can you remove this?", "author": "fwolter", "createdAt": "2020-09-08T20:18:46Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjE5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662199", "bodyText": "removed", "author": "miloit", "createdAt": "2020-09-10T22:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485174338", "bodyText": "initialize() should return fast. This should be executed in a scheduler task, like in the generated skeleton code.", "author": "fwolter", "createdAt": "2020-09-08T20:21:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616077", "bodyText": "scheduler task implemented", "author": "miloit", "createdAt": "2020-09-10T20:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175137", "bodyText": "Please use camelCase. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n          \n          \n            \n                private WebSocketClient yioRemoteDockwebSocketClient = new WebSocketClient();", "author": "fwolter", "createdAt": "2020-09-08T20:23:07Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MDk2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485360962", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-09T06:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175473", "bodyText": "What's the purpose of the sleep?", "author": "fwolter", "createdAt": "2020-09-08T20:23:51Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616193", "bodyText": "to wait for the message", "author": "miloit", "createdAt": "2020-09-10T20:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzQ0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487167445", "bodyText": "it's a YIO DOck Bug currently", "author": "miloit", "createdAt": "2020-09-11T16:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175758", "bodyText": "Can you fix the formatting?", "author": "fwolter", "createdAt": "2020-09-08T20:24:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NTc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485365742", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-09T06:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175954", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "author": "fwolter", "createdAt": "2020-09-08T20:24:53Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662102", "bodyText": "not sure which one....therefore leave it for the first release", "author": "miloit", "createdAt": "2020-09-10T22:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjcwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485176702", "bodyText": "You could set the Thing to OFFLINE with updateStatus() instead of logging it. Then, the error message is logged and displayed in the UI. Same for above.", "author": "fwolter", "createdAt": "2020-09-08T20:26:28Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616495", "bodyText": "removed the logging", "author": "miloit", "createdAt": "2020-09-10T20:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzE4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485177184", "bodyText": "Better use the exception's message. Same for the others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.warn(\"JSON convertion failure {}\", e.toString());\n          \n          \n            \n                                logger.warn(\"JSON convertion failure {}\", e.getMessage());", "author": "fwolter", "createdAt": "2020-09-08T20:27:29Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NTQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485365415", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-09T06:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzU0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485177548", "bodyText": "This logging could be removed, as updateStatus() does it already.", "author": "fwolter", "createdAt": "2020-09-08T20:28:14Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616609", "bodyText": "removed", "author": "miloit", "createdAt": "2020-09-10T20:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178141", "bodyText": "Better set the Channel to UnDefType.UNDEF instead of a custom string.", "author": "fwolter", "createdAt": "2020-09-08T20:29:30Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDYyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486660622", "bodyText": "SOlved", "author": "miloit", "createdAt": "2020-09-10T22:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178490", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-09-08T20:30:07Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661838", "bodyText": "not sure therefore leve it as it is", "author": "miloit", "createdAt": "2020-09-10T22:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178825", "bodyText": "Please use the debugger instead of logging it.", "author": "fwolter", "createdAt": "2020-09-08T20:30:48Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4MDk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485680996", "bodyText": "This is a very appropriate use of logging, and should not be complained about.", "author": "9037568", "createdAt": "2020-09-09T14:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTI3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179274", "bodyText": "You could store pollingJob to a local variable an do a null check on that, to eliminate the compiler warning.", "author": "fwolter", "createdAt": "2020-09-08T20:31:44Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTkzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661930", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-10T22:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179334", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-08T20:31:51Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487167544", "bodyText": "Done", "author": "miloit", "createdAt": "2020-09-11T16:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419310", "bodyText": "I don't see a null check.", "author": "fwolter", "createdAt": "2020-09-12T15:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490730229", "bodyText": "Solved", "author": "miloit", "createdAt": "2020-09-18T06:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTY4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179685", "bodyText": "The framework takes care of the Channel values when the Thing is disposed. This can be removed.", "author": "fwolter", "createdAt": "2020-09-08T20:32:31Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168090", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-11T16:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179860", "bodyText": "Can you do this?", "author": "fwolter", "createdAt": "2020-09-08T20:32:51Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NjIwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485366202", "bodyText": "I deleted it...makes no sense", "author": "miloit", "createdAt": "2020-09-09T06:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485180723", "bodyText": "If I see correctly this is a trigger channel. So a refresh doesn't need to be handled.", "author": "fwolter", "createdAt": "2020-09-08T20:34:44Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODIxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168215", "bodyText": "removed", "author": "miloit", "createdAt": "2020-09-11T16:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181131", "bodyText": "No harm in updating an unlinked Channel.", "author": "fwolter", "createdAt": "2020-09-08T20:35:32Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDk0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486660946", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-10T22:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419452", "bodyText": "I still see the if.", "author": "fwolter", "createdAt": "2020-09-12T15:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490730100", "bodyText": "Solved", "author": "miloit", "createdAt": "2020-09-18T06:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTI2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181261", "bodyText": "See above. camelCase", "author": "fwolter", "createdAt": "2020-09-08T20:35:48Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTA5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661099", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-10T22:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181504", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-09-08T20:36:20Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661247", "bodyText": "not sure", "author": "miloit", "createdAt": "2020-09-10T22:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjA0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182043", "bodyText": "Please use underscores to separate the words.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum YIOREMOTEHANDLESTATUS {\n          \n          \n            \n                public static enum YIO_REMOTE_HANDLE_STATUS {", "author": "fwolter", "createdAt": "2020-09-08T20:37:21Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    private static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEHANDLESTATUS {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1OTcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485359723", "bodyText": "Changed to correct YIO_REMOTE_DOCK_HANDLE_STATUS", "author": "miloit", "createdAt": "2020-09-09T06:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjM5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182397", "bodyText": "The IOException is never thrown. So, this could be removed.", "author": "fwolter", "createdAt": "2020-09-08T20:38:04Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTE5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661190", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-10T22:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjU0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182541", "bodyText": "See above. null check", "author": "fwolter", "createdAt": "2020-09-08T20:38:22Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661441", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-10T22:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182806", "bodyText": "Please fix the formatting", "author": "fwolter", "createdAt": "2020-09-08T20:38:55Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661514", "bodyText": "fixed", "author": "miloit", "createdAt": "2020-09-10T22:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182912", "bodyText": "See above. camelCase", "author": "fwolter", "createdAt": "2020-09-08T20:39:09Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    private boolean decode_receivedMessage(JsonObject JsonObject_recievedJsonObject) {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTcxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661717", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-10T22:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485183919", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2020-09-08T20:41:11Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteWebsocketPolling.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link YIOremoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteWebsocketPolling implements Runnable {", "originalCommit": "0f272040f155fa011998af762c6688c23c06ac9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2ODMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487168333", "bodyText": "deleted", "author": "miloit", "createdAt": "2020-09-11T16:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487396956", "bodyText": "Did you push all of your changes? I still see this without underscores.", "author": "fwolter", "createdAt": "2020-09-12T10:50:42Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "originalCommit": "38f5564efadacf0ef4b99f120032e37f35477f87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NzQ4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487397480", "bodyText": "I see this YIOREMOTEDOCKHANDLESTATUS or do mean each possible state?", "author": "miloit", "createdAt": "2020-09-12T10:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NzcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487397704", "bodyText": "Sorry, my mistake. enum names should be camelCase.", "author": "fwolter", "createdAt": "2020-09-12T10:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Nzk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487397979", "bodyText": "No worries thanks for the review", "author": "miloit", "createdAt": "2020-09-12T11:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQwMDY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487400691", "bodyText": "There's a misunderstanding. The name of the Enum should be CamelCase and the members should be all uppercase and SNAKE_CASE.", "author": "fwolter", "createdAt": "2020-09-12T11:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODAxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418018", "bodyText": "Can the comment be removed?", "author": "fwolter", "createdAt": "2020-09-12T15:01:37Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTIwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429200", "bodyText": "Deleted", "author": "miloit", "createdAt": "2020-09-12T17:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODE4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418180", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-09-12T15:03:38Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429229", "bodyText": "Deleted", "author": "miloit", "createdAt": "2020-09-12T17:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418297", "bodyText": "The logger is never used.", "author": "fwolter", "createdAt": "2020-09-12T15:04:39Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable YIOremoteDockHandler handler;\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockActions.class);", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429179", "bodyText": "Deleted", "author": "miloit", "createdAt": "2020-09-12T17:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418323", "bodyText": "This is never used.", "author": "fwolter", "createdAt": "2020-09-12T15:04:54Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTIzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487429237", "bodyText": "Deleted", "author": "miloit", "createdAt": "2020-09-12T17:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODU3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418575", "bodyText": "What happens if the connection never gets established? As this is a thread of a shared thread pool, it shouldn't block for a long time. A better approach would be to execute the code below from within onConnect().", "author": "fwolter", "createdAt": "2020-09-12T15:07:54Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzOTY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487439673", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-12T19:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODY4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418688", "bodyText": "If this sleep is really necessary, better schedule a task in 1sec. for executing the code below.", "author": "fwolter", "createdAt": "2020-09-12T15:09:20Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487430651", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-12T17:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418915", "bodyText": "As this is nullable, you need to do a null check before. You can store pollingJob to a local variable and do the null check on that.", "author": "fwolter", "createdAt": "2020-09-12T15:11:26Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487430728", "bodyText": "this is what i don't understand exactly can you explain it a bit more", "author": "miloit", "createdAt": "2020-09-12T17:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMjIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487432232", "bodyText": "pollingJob can be null at this point, because it isn't inittialized in the constructor. So, you need to check if it is not null before accessing it: if (pollingJob != null).\nBut this would result in a compiler warning, as pollingJob is a field and could theoretically be modified by another thread exactly between the null check and the access in the next line.\nTo mitigate this, you can store pollingJob to a local variable before checking it:\n                                                        Future<?> localPollingJob = pollingJob;\n                                                        if (localPollingJob != null) {\n                                                            localPollingJob.cancel(true);\n                                                        }", "author": "fwolter", "createdAt": "2020-09-12T17:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MDIwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489170206", "bodyText": "Resolved", "author": "miloit", "createdAt": "2020-09-16T05:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODk5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418999", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "author": "fwolter", "createdAt": "2020-09-12T15:12:19Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568806", "bodyText": "There is no better way for this unfortunately", "author": "miloit", "createdAt": "2020-09-17T21:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTAwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419006", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-09-12T15:12:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568939", "bodyText": "Changed complete code", "author": "miloit", "createdAt": "2020-09-17T21:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTA2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419067", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-12T15:13:04Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MDM0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489170347", "bodyText": "I can't define an concret exception for this", "author": "miloit", "createdAt": "2020-09-16T05:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419134", "bodyText": "Instead of logging it, you could set the Thing state to OFFLINE.", "author": "fwolter", "createdAt": "2020-09-12T15:14:03Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDgzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487430833", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-12T17:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419178", "bodyText": "As this is fatal, better set the Thing to OFFLINE with an appropriate detail message.", "author": "fwolter", "createdAt": "2020-09-12T15:14:35Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzOTY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487439683", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-12T19:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419269", "bodyText": "Instead of logging this, you could add the text as detail message to updateStatus().", "author": "fwolter", "createdAt": "2020-09-12T15:15:16Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMTEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487431109", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-12T17:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419372", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String string_ircode) {\n          \n          \n            \n                public void sendircode(@Nullable String stringIRCode) {", "author": "fwolter", "createdAt": "2020-09-12T15:16:20Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());\n+            }\n+        });\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        if (isLinked(id)) {\n+            updateState(id, value);\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String string_ircode) {", "originalCommit": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMTEzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487431135", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-12T17:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489220713", "bodyText": "CamelCase and you don't need to repeat the name of the binding in the name necessarily as it is unique in the package.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum YIOREMOTEDOCKHANDLESTATUS {\n          \n          \n            \n                public static enum DockHandleStatus {", "author": "fwolter", "createdAt": "2020-09-16T07:26:25Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNTg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489315848", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T09:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489220767", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-16T07:26:33Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMDY2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489330665", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489221417", "bodyText": "These should be SNAKE_CASE. The prefix could be dropped, too, as it is redundant. Suggestion for a more meaningful name. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";\n          \n          \n            \n                public static final String RECEIVER_SWITCH_CHANNEL = \"receiverswitch\";", "author": "fwolter", "createdAt": "2020-09-16T07:27:42Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,\n+        IRRECEIVEROFF;\n+    }\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_YIOREMOTEDOCK = new ThingTypeUID(BINDING_ID, \"yioremotedock\");\n+\n+    // List of all Channel Groups Group Channel ids\n+    public static final String GROUP_INPUT = \"input\";\n+    public static final String GROUP_OUTPUT = \"output\";\n+\n+    // List of all Channel ids\n+    public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNTY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489315675", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T09:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223517", "bodyText": "This method has no body. You might want to call sendircode().", "author": "fwolter", "createdAt": "2020-09-16T07:31:16Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        yioremotedockhandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return yioremotedockhandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendircode(\n+            @ActionInput(name = \"ircode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String ircode) {\n+    }", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490464096", "bodyText": "Can you comment on that?", "author": "fwolter", "createdAt": "2020-09-17T18:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2ODE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490568142", "bodyText": "Changed", "author": "miloit", "createdAt": "2020-09-17T21:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223653", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n          \n          \n            \n                private @Nullable static YIOremoteDockHandler dockHandler;", "author": "fwolter", "createdAt": "2020-09-16T07:31:32Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNjY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489316641", "bodyText": "Why is \"yioremotedockhandler\" not oky? Because of the type?", "author": "miloit", "createdAt": "2020-09-16T09:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMDczMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489330730", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mzg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463875", "bodyText": "I still see all lower case", "author": "fwolter", "createdAt": "2020-09-17T18:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1ODQzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490558436", "bodyText": "Solved", "author": "miloit", "createdAt": "2020-09-17T20:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223975", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n          \n          \n            \n                private WebSocketClient webSocketClient = new WebSocketClient();", "author": "fwolter", "createdAt": "2020-09-16T07:32:03Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxODA3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489318078", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489224716", "bodyText": "Please don't prefix the field name with the type and drop the binding's name as these are both redundant. Please also use camelCase. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable URI uriyiodockwebsocketaddress;\n          \n          \n            \n                private @Nullable URI websocketAddress;", "author": "fwolter", "createdAt": "2020-09-16T07:33:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxODQxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489318416", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTMxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489225317", "bodyText": "You could include the exception's message:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n          \n          \n            \n                                    \"Initialize web socket failed\");\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n          \n          \n            \n                                    \"Initialize web socket failed: \"+e.getMessage());", "author": "fwolter", "createdAt": "2020-09-16T07:34:33Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxOTIyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489319225", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjE2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489226168", "bodyText": "Primitive types should be used where possible (boolean instead of Boolean).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            public void onConnect(Boolean booleanconnectedflag) {\n          \n          \n            \n                            public void onConnect(boolean connected) {", "author": "fwolter", "createdAt": "2020-09-16T07:36:06Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMDk0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489320945", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDg4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489230884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n          \n          \n            \n                private boolean decodeReceivedMessage(JsonObject message) {", "author": "fwolter", "createdAt": "2020-09-16T07:44:17Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMTUwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489321509", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489231188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean booleanresult = false;\n          \n          \n            \n                    boolean success = false;", "author": "fwolter", "createdAt": "2020-09-16T07:44:46Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMDU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489330570", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489231791", "bodyText": "What's the purpose of this assignment?", "author": "fwolter", "createdAt": "2020-09-16T07:45:47Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMTkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489321936", "bodyText": "To have no problem with nullable", "author": "miloit", "createdAt": "2020-09-16T10:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4MTE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489481141", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T14:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            yioremotedockhandler.booleanheartbeat = true;\n          \n          \n            \n                            booleanheartbeat = true;", "author": "fwolter", "createdAt": "2020-09-16T07:46:13Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMzcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489323713", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232371", "bodyText": "See above.", "author": "fwolter", "createdAt": "2020-09-16T07:46:47Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4MTMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489481339", "bodyText": "resolved was a left over from some testing", "author": "miloit", "createdAt": "2020-09-16T14:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjkwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else\n          \n          \n            \n            \n          \n          \n            \n                    {\n          \n          \n            \n                    } else {", "author": "fwolter", "createdAt": "2020-09-16T07:47:44Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNDE4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489324182", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489234326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    IRRECEIVERON,\n          \n          \n            \n                    IR_RECEIVER_ON,", "author": "fwolter", "createdAt": "2020-09-16T07:50:05Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzMTkwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489331904", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-16T10:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDUwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489234506", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String accesstoken = \"0\";\n          \n          \n            \n                public String accessToken = \"0\";", "author": "fwolter", "createdAt": "2020-09-16T07:50:22Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+    public @Nullable String host;\n+    public String accesstoken = \"0\";", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489324557", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489236038", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String stringIRCode) {\n          \n          \n            \n                public void sendIRCode(@Nullable String code) {", "author": "fwolter", "createdAt": "2020-09-16T07:52:51Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489329954", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-16T10:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489236778", "bodyText": "The argument is not used in this method.", "author": "fwolter", "createdAt": "2020-09-16T07:54:07Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjExNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326116", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzOTY1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489239657", "bodyText": "Is it reasonable to send an authentication request every 5 sec.?", "author": "fwolter", "createdAt": "2020-09-16T07:58:43Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326413", "bodyText": "to be faster and its normallz only running 2 after that the task is canceld", "author": "miloit", "createdAt": "2020-09-16T10:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzOTY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489241375", "bodyText": "Is there a reason this method is protected? You could also access the flag directly. I make a suggestion below.", "author": "fwolter", "createdAt": "2020-09-16T08:01:29Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489329565", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTU3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489241576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (yioremotedockhandler.getbooleanauthenticationok()) {\n          \n          \n            \n                                if (booleanauthenticationok) {", "author": "fwolter", "createdAt": "2020-09-16T08:01:48Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326536", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489242565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected boolean getbooleanheartbeat() {\n          \n          \n            \n                    boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n          \n          \n            \n                    yioremotedockhandler.booleanheartbeat = false;\n          \n          \n            \n                    return booleanresult;\n          \n          \n            \n                }\n          \n          \n            \n                private boolean getbooleanheartbeat() {\n          \n          \n            \n                    boolean result = booleanheartbeat;\n          \n          \n            \n                    booleanheartbeat = false;\n          \n          \n            \n                    return result;\n          \n          \n            \n                }", "author": "fwolter", "createdAt": "2020-09-16T08:03:38Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyNjYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489326616", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489243004", "bodyText": "See above. Access directly.", "author": "fwolter", "createdAt": "2020-09-16T08:04:26Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489329136", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-16T10:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489245236", "bodyText": "You could use JSON DTOs to send and receive JSON data. See here for example: https://github.com/openhab/openhab-addons/pull/8050/files#diff-904c4bebdb6a68e4a2c9d9c8289bdffdR99", "author": "fwolter", "createdAt": "2020-09-16T08:08:06Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+            logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\", messagepyload);\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+            stringlastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+            yioremoteDockwebSocketClient.sendMessage(\n+                    \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            logger.debug(\n+                    \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+            logger.debug(\"sending IR receiver on message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+            logger.debug(\"sending IR receiver off message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\"\n+                    + messagepyload + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            stringlastsendircode = messagepyload;\n+            logger.debug(\n+                    \"sending IR message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                    messagepyload);\n+        }\n+    }\n+}", "originalCommit": "327f0e7b9e3f1817f672d564e65422a9d6482ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NTQyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489485427", "bodyText": "I will look into this and keep it in mz mind for the next updated version is this okay for you?", "author": "miloit", "createdAt": "2020-09-16T14:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTE4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405183", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String gettype() {\n          \n          \n            \n                public String getType() {", "author": "fwolter", "createdAt": "2020-09-17T16:40:03Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzMzc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490433776", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405407", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject authenticationmessagejsonobject = new JsonObject();\n          \n          \n            \n                    JsonObject authenticationMessage = new JsonObject();", "author": "fwolter", "createdAt": "2020-09-17T16:40:26Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {\n+        return type;\n+    }\n+\n+    public String gettoken() {\n+        return token;\n+    }\n+\n+    public void settoken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationmessagejsonobject() {\n+        JsonObject authenticationmessagejsonobject = new JsonObject();", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNDgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490434819", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405906", "bodyText": "Same for the others\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getformat() {\n          \n          \n            \n                public String getFormat() {", "author": "fwolter", "createdAt": "2020-09-17T16:41:08Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCode.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link IRCode} the IRCode DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCode {\n+    private String code = \"0;0x0;0;0\";\n+    private String format = \"hex\";\n+\n+    public String getformat() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNzIzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490437230", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjE2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490406165", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-17T16:41:32Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getircodesendmessagejsonobject() {\n+        JsonObject ircodesendmessagejsonobject = new JsonObject();", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNzU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490437572", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjUzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490406539", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void seton() {\n          \n          \n            \n                public void setOn() {", "author": "fwolter", "createdAt": "2020-09-17T16:42:07Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void seton() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNzY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490437649", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490407475", "bodyText": "Same for the other fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n          \n          \n            \n                private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "author": "fwolter", "createdAt": "2020-09-17T16:43:35Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MDY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490440672", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T17:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408122", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            public void onConnect(boolean connectedflag) {\n          \n          \n            \n                            public void onConnect(boolean connected) {", "author": "fwolter", "createdAt": "2020-09-17T16:44:34Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NTI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490455287", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T18:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408267", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"Initialize web socket failed \" + e.getMessage());\n          \n          \n            \n                                    \"Initialize web socket failed: \" + e.getMessage());", "author": "fwolter", "createdAt": "2020-09-17T16:44:47Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MDkyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490440927", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODYxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408617", "bodyText": "Isn't this rather a CONFIGURATION_ERROR?", "author": "fwolter", "createdAt": "2020-09-17T16:45:17Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTI3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490441271", "bodyText": "right solved", "author": "miloit", "createdAt": "2020-09-17T17:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwOTg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490409868", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean decodereceivedMessage(JsonObject message) {\n          \n          \n            \n                private boolean decodeReceivedMessage(JsonObject message) {", "author": "fwolter", "createdAt": "2020-09-17T16:47:15Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490441531", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T17:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwOTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490410216", "bodyText": "Empty line\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n          \n          \n            \n            \n          \n          \n            \n                        {\n          \n          \n            \n                        } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {", "author": "fwolter", "createdAt": "2020-09-17T16:47:45Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTgzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490441835", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490410649", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private JsonObject convertStringtoJsonObject(String jsonString) {\n          \n          \n            \n                private JsonObject convertStringToJsonObject(String jsonString) {", "author": "fwolter", "createdAt": "2020-09-17T16:48:18Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MjI3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490442272", "bodyText": "Solved", "author": "miloit", "createdAt": "2020-09-17T17:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjIxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490466211", "bodyText": "Did you push your changes?", "author": "fwolter", "createdAt": "2020-09-17T18:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2Nzg1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490567852", "bodyText": "Yes", "author": "miloit", "createdAt": "2020-09-17T21:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490417686", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (command.toString().equals(\"ON\")) {\n          \n          \n            \n                            if (command == OnOffType.ON) {", "author": "fwolter", "createdAt": "2020-09-17T16:59:33Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MjgxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490442813", "bodyText": "solved thanks to learn more and more about the librarys", "author": "miloit", "createdAt": "2020-09-17T17:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490418016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String ircode) {\n          \n          \n            \n                public void sendIRCode(@Nullable String irCode) {", "author": "fwolter", "createdAt": "2020-09-17T17:00:05Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MzQ0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490443443", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T17:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODcyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490418726", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void startwebsocketpollingthread() {\n          \n          \n            \n                private void startWebsocketPollingThread() {", "author": "fwolter", "createdAt": "2020-09-17T17:01:12Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MzYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490443610", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T17:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490420103", "bodyText": "You could move the code within run() into a private method and then call the scheduler with this method:\nwebsocketpollingjob = scheduler.scheduleWithFixedDelay(this::myNewMethod, 0, 30, TimeUnit.SECONDS);\nThat avoids the boiler plate code of defining an anonymous class.", "author": "fwolter", "createdAt": "2020-09-17T17:03:25Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NDUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490444507", "bodyText": "thanks", "author": "miloit", "createdAt": "2020-09-17T17:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMDEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421167", "bodyText": "This method is only used in this class. Is there a reason why you don't access the field directly?", "author": "fwolter", "createdAt": "2020-09-17T17:05:18Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NDQ4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490454480", "bodyText": "sorry for that one missed it", "author": "miloit", "createdAt": "2020-09-17T18:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421656", "bodyText": "You could clarify in the method's name, that this isn't simply a getter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean getbooleanheartbeat() {\n          \n          \n            \n                public boolean getAndResetHeartbeat() {", "author": "fwolter", "createdAt": "2020-09-17T17:06:09Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NDk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490444961", "bodyText": "dones", "author": "miloit", "createdAt": "2020-09-17T17:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421910", "bodyText": "Same question as above.", "author": "fwolter", "createdAt": "2020-09-17T17:06:36Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1MzYzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490453635", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T18:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjU5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422597", "bodyText": "Better use a switch/case to check the enum fields. This way you get a compiler warning if you miss to handle any enum constant.", "author": "fwolter", "createdAt": "2020-09-17T17:07:43Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n+        if (messagetype.equals(YioRemoteMessages.AUTHENTICATE_MESSAGE)) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0ODk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490448978", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T17:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422791", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n          \n          \n            \n                public void sendMessage(YioRemoteMessages messageType, String messagePayload) {", "author": "fwolter", "createdAt": "2020-09-17T17:08:04Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490449325", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T17:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422880", "bodyText": "Suggested change", "author": "fwolter", "createdAt": "2020-09-17T17:08:17Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTU4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490449587", "bodyText": "removed", "author": "miloit", "createdAt": "2020-09-17T17:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDgyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490424829", "bodyText": "Is this class really necessary? It would reduce the complexity of the binding if you don't use this wrapper class but access the web socket directly with an inner class in the handler. Like you do it with this wrapper class now.", "author": "fwolter", "createdAt": "2020-09-17T17:11:39Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+\n+public class YIOremoteDockWebsocket {", "originalCommit": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1NDY5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490454690", "bodyText": "for my current programming skills this is better to understand", "author": "miloit", "createdAt": "2020-09-17T18:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MjYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490462608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonObject getauthenticationMessageJsonObject() {\n          \n          \n            \n                public JsonObject getAuthenticationMessageJsonObject() {", "author": "fwolter", "createdAt": "2020-09-17T18:16:22Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MTc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490471774", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MjYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mjc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490462750", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getauthenticationMessageString() {\n          \n          \n            \n                public String getAuthenticationMessageString() {", "author": "fwolter", "createdAt": "2020-09-17T18:16:37Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {\n+        JsonObject authenticationMessage = new JsonObject();\n+        authenticationMessage.addProperty(\"type\", type);\n+        authenticationMessage.addProperty(\"token\", token);\n+        return authenticationMessage;\n+    }\n+\n+    public String getauthenticationMessageString() {", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MTgyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490471829", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mjc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463005", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonObject getIRcodesendMessageJsonObject() {\n          \n          \n            \n                public JsonObject getIRcodeSendMessageJsonObject() {", "author": "fwolter", "createdAt": "2020-09-17T18:17:03Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490481502", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463109", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject ircodesendmessage = new JsonObject();\n          \n          \n            \n                    JsonObject irCodeSendMessage = new JsonObject();", "author": "fwolter", "createdAt": "2020-09-17T18:17:14Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MjMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490472318", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject ircodesendmessage = new JsonObject();\n          \n          \n            \n                    JsonObject irCodeSendMessage = new JsonObject();", "author": "fwolter", "createdAt": "2020-09-17T18:17:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();\n+        ircodesendmessage.addProperty(\"type\", type);\n+        ircodesendmessage.addProperty(\"command\", command);\n+        ircodesendmessage.addProperty(\"code\", ircode.getCode());\n+        ircodesendmessage.addProperty(\"format\", ircode.getFormat());\n+        return ircodesendmessage;\n+    }\n+\n+    public String getIRcodesendMessageString() {\n+        JsonObject ircodesendmessage = new JsonObject();", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MjQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490472438", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject irreceivermessage = new JsonObject();\n          \n          \n            \n                    JsonObject irReceiverMessage = new JsonObject();", "author": "fwolter", "createdAt": "2020-09-17T18:17:46Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NTQ0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490475445", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzU0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject irreceivermessage = new JsonObject();\n          \n          \n            \n                    JsonObject irReceiverMessage = new JsonObject();", "author": "fwolter", "createdAt": "2020-09-17T18:17:57Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();\n+        irreceivermessage.addProperty(\"type\", type);\n+        irreceivermessage.addProperty(\"command\", command);\n+        return irreceivermessage;\n+    }\n+\n+    public String getIRreceiverMessageString() {\n+        JsonObject irreceivermessage = new JsonObject();", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NTUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490475530", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490464417", "bodyText": "Please see all other fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Future<?> authenticationjob;\n          \n          \n            \n                private @Nullable Future<?> authenticationJob;", "author": "fwolter", "createdAt": "2020-09-17T18:19:33Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3ODE5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490478199", "bodyText": "removed never used", "author": "miloit", "createdAt": "2020-09-17T18:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NTY3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490465679", "bodyText": "I overlooked that during the first reviews. Sorry for that. Please check all other Enum comparisons in all classes.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n          \n          \n            \n                                                || yioRemoteDockActualStatus\n          \n          \n            \n                                                        .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n          \n          \n            \n                                        if (yioremotedockactualstatus == YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED\n          \n          \n            \n                                                || yioremotedockactualstatus == YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS) {", "author": "fwolter", "createdAt": "2020-09-17T18:21:52Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MDAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490480008", "bodyText": "done", "author": "miloit", "createdAt": "2020-09-17T18:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490466461", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else if (command.toString().equals(\"OFF\")) {\n          \n          \n            \n                            } else if (command == OnOffType.OFF) {", "author": "fwolter", "createdAt": "2020-09-17T18:23:21Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3Mjc2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490472760", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490467691", "bodyText": "Can you access the field directly without using this method?", "author": "fwolter", "createdAt": "2020-09-17T18:25:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendIRCode(@Nullable String irCode) {\n+        if (irCode != null) {\n+            if (irCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, irCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", irCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        switch (yioRemoteDockActualStatus) {\n+            case CONNECTION_ESTABLISHED:\n+                authenticationmessagehandler.setToken(localConfig.accessToken);\n+                sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+                break;\n+            case AUTHENTICATION_PROCESS:\n+                if (authenticationok) {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                    updateStatus(ThingStatus.ONLINE);\n+                    websocketpollingjob = scheduler.scheduleWithFixedDelay(this::pollingWebsocket, 0, 30,\n+                            TimeUnit.SECONDS);\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                } else {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+                }\n+                break;\n+            default:\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                break;\n+        }\n+    }\n+\n+    private void pollingWebsocket() {\n+        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+            if (getAndResetHeartbeat()) {\n+                updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                        ircodereceivedhandler.getCode() + ircodereceivedhandler.getFormat());\n+                logger.debug(\"heartbeat ok\");\n+                sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+            } else {\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                if (websocketpollingjob != null) {\n+                    websocketpollingjob.cancel(true);\n+                }\n+            }\n+        } else {\n+            if (websocketpollingjob != null) {\n+                websocketpollingjob.cancel(true);\n+            }\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    public boolean getAndResetHeartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioRemoteDockActualStatus() {\n+        return yioRemoteDockActualStatus;\n+    }", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MzkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490473912", "bodyText": "I learned thatis always better to have a get function instead of accessing directly. i use this also in the action handler therefore i have this with get", "author": "miloit", "createdAt": "2020-09-17T18:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAyOTA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491029057", "bodyText": "Private fields can be accessed directly within the same class to maintain code readability. As you use it in the Actions now, it's ok to keep the method.", "author": "fwolter", "createdAt": "2020-09-18T15:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODM0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468342", "bodyText": "This method is never used.", "author": "fwolter", "createdAt": "2020-09-17T18:26:36Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {\n+        if (yioremotedockwebsocketinterfacehandler != null) {\n+            yioremotedockwebsocketinterfacehandler.onMessage(stringreceivedmessage);\n+        }\n+    }\n+\n+    public String getstringreceivedmessage() {\n+        return this.stringreceivedmessage;\n+    }", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NDM1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490474355", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODUwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468501", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onText(Session session, String stringreceivedmessage) {\n          \n          \n            \n                public void onText(Session session, String receivedMessage) {", "author": "fwolter", "createdAt": "2020-09-17T18:26:52Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NDU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490474583", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODk1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468955", "bodyText": "Please check all occurrences.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n          \n          \n            \n                private @Nullable YIOremoteDockWebsocketInterface websocketHandler;", "author": "fwolter", "createdAt": "2020-09-17T18:27:39Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;", "originalCommit": "37458bc3cdd9883a88d8544b66acd7c91a4211c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NTA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490475068", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-17T18:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMjUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491032500", "bodyText": "Package names should be all lower case. The directory name is upper case in your case. Also it's good practice to make the names singular. So, dto would be good.", "author": "fwolter", "createdAt": "2020-09-18T15:38:27Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/DTOs/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal.dtos;", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NTcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491055729", "bodyText": "solved i pushed it first with DTOs than changed it to dtos but this was an error during pushung therefore put dto inside", "author": "miloit", "createdAt": "2020-09-18T16:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491033344", "bodyText": "As this class can be instantiated for multiple Docks, if the user adds multiple Things, this must not be static. Each Action object has its own handler.", "author": "fwolter", "createdAt": "2020-09-18T15:39:51Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NTM0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491055344", "bodyText": "okay but without static it shows me an error therefor i leave it as it is", "author": "miloit", "createdAt": "2020-09-18T16:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzODg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491138868", "bodyText": "The error is caused, since you can't access a non-static field from within a static method as sendIRCode() is. But if you change the code as proposed in the other comment, it's gonna work: Invoking the other non-static method by using the actions argument.", "author": "fwolter", "createdAt": "2020-09-18T19:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2MTI3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491161276", "bodyText": "Can you please simple write me the complete function correctly I don't get the point to do it right. Sorry. Thanks", "author": "miloit", "createdAt": "2020-09-18T19:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491174370", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-18T20:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDU1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491034555", "bodyText": "Just for the records, if you only check one Enum constant, an if is sufficient. You can keep this.", "author": "fwolter", "createdAt": "2020-09-18T15:41:54Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NDg0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491054847", "bodyText": "okay  ileve this", "author": "miloit", "createdAt": "2020-09-18T16:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNTY5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491035697", "bodyText": "You can simply invoke the other method:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        switch (dockHandler.getyioRemoteDockActualStatus()) {\n          \n          \n            \n                            case AUTHENTICATION_COMPLETE:\n          \n          \n            \n                                dockHandler.sendIRCode(irCode);\n          \n          \n            \n                                break;\n          \n          \n            \n                        }\n          \n          \n            \n                        ((YIOremoteDockActions) actions).sendIRCode(irCode);", "author": "fwolter", "createdAt": "2020-09-18T15:43:52Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    public static void sendIRCode(@Nullable ThingActions actions, @Nullable String irCode) {\n+        if (actions instanceof YIOremoteDockActions && dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+            }", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491054070", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-18T16:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjE2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491036163", "bodyText": "As dockHandler is nullable, you need to store it to a local variable and do a null check on it.", "author": "fwolter", "createdAt": "2020-09-18T15:44:40Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1NDU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491054564", "bodyText": "dones", "author": "miloit", "createdAt": "2020-09-18T16:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491036984", "bodyText": "Please double check the capitalization, as mentioned in the previous reviews.", "author": "fwolter", "createdAt": "2020-09-18T15:45:57Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1MzQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491053438", "bodyText": "resolved", "author": "miloit", "createdAt": "2020-09-18T16:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzODE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491038154", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            case CONNECTION_ESTABLISHED:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;\n          \n          \n            \n                                            case AUTHENTICATION_PROCESS:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;\n          \n          \n            \n                                            case CONNECTION_ESTABLISHED:\n          \n          \n            \n                                            case AUTHENTICATION_PROCESS:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;", "author": "fwolter", "createdAt": "2020-09-18T15:47:56Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode irCodeReceivedHandler = new IRCode();\n+    private IRCode irCodeSendHandler = new IRCode();\n+    private IRCodeSendMessage irCodeSendMessageHandler = new IRCodeSendMessage(irCodeSendHandler);\n+    private AuthenticationMessage authenticationMessageHandler = new AuthenticationMessage();\n+    private IRReceiverMessage irReceiverMessageHandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new WebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringToJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            switch (yioRemoteDockActualStatus) {\n+                                case CONNECTION_ESTABLISHED:\n+                                    authenticate();\n+                                    break;\n+                                case AUTHENTICATION_PROCESS:\n+                                    authenticate();\n+                                    break;", "originalCommit": "472243eeef11b587fc1b5e24490fe2522f785d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1MzMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491053310", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-18T16:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Njc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491146754", "bodyText": "You need to store dockHandler to a local variable and do the null check on that to get rid of the compiler warning. As dockHandler is a field it could be modified by another thread exactly after the null check and before the access in the following lines.", "author": "fwolter", "createdAt": "2020-09-18T19:22:23Z", "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        if (dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+                default:\n+                    break;\n+            }", "originalCommit": "df721cf32ddd8934a43fd4ad853bfdd163137ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491174495", "bodyText": "solved", "author": "miloit", "createdAt": "2020-09-18T20:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Njc1NA=="}], "type": "inlineReview"}, {"oid": "98045b9758cb63e8813b262d53660ea077d24b4e", "url": "https://github.com/openhab/openhab-addons/commit/98045b9758cb63e8813b262d53660ea077d24b4e", "message": "Initial\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:55Z", "type": "commit"}, {"oid": "0fa29da4356cb5e0d32a7e12daca69cb3f6e1bd2", "url": "https://github.com/openhab/openhab-addons/commit/0fa29da4356cb5e0d32a7e12daca69cb3f6e1bd2", "message": "Initial Websocket connect\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:55Z", "type": "commit"}, {"oid": "cb13441373c2f15360d8564d0771a9d6dd67f0f0", "url": "https://github.com/openhab/openhab-addons/commit/cb13441373c2f15360d8564d0771a9d6dd67f0f0", "message": "Initial websocket class\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:55Z", "type": "commit"}, {"oid": "40edeb3de1d53d0ab0a98ae1627147c0260e33f9", "url": "https://github.com/openhab/openhab-addons/commit/40edeb3de1d53d0ab0a98ae1627147c0260e33f9", "message": "Initiel websocket Class cleaned\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "c00022c2b178b2e05616ba142db0b12bb8fae8d8", "url": "https://github.com/openhab/openhab-addons/commit/c00022c2b178b2e05616ba142db0b12bb8fae8d8", "message": "Initial usage of Websocket client Class\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "eebb8377aa8a854e6adf52875841f1fa662b9f9e", "url": "https://github.com/openhab/openhab-addons/commit/eebb8377aa8a854e6adf52875841f1fa662b9f9e", "message": "Cleaning up YIOremoteHandler.class\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "265ff4655d4de629dc990a33f593cb6280458939", "url": "https://github.com/openhab/openhab-addons/commit/265ff4655d4de629dc990a33f593cb6280458939", "message": "Implementation of correct authentification procedure and error managment\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "6e35d7c7f86d5719b629ca34d9b32f7462658275", "url": "https://github.com/openhab/openhab-addons/commit/6e35d7c7f86d5719b629ca34d9b32f7462658275", "message": "Implementation of the Input and Output Channels\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "b080edd42ae1ed760b6e47ef64cd45a65581b0c0", "url": "https://github.com/openhab/openhab-addons/commit/b080edd42ae1ed760b6e47ef64cd45a65581b0c0", "message": "Renaming configuration\n\nRenaming\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "d66823c2b9049d0994e83e1e143f59119df3c385", "url": "https://github.com/openhab/openhab-addons/commit/d66823c2b9049d0994e83e1e143f59119df3c385", "message": "Implementing of YIODOCKRECEIVERSWITCH procedure\nImplementing of @OnWebSocketError procedure\nImplementing of string channel yiodocksendircode\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "4032bc745f3dae0fcd735a6c6941f38b8bb36766", "url": "https://github.com/openhab/openhab-addons/commit/4032bc745f3dae0fcd735a6c6941f38b8bb36766", "message": "Implementation of polling Thread\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "8871db53de7caa5da96eea31a33aa66e1162d221", "url": "https://github.com/openhab/openhab-addons/commit/8871db53de7caa5da96eea31a33aa66e1162d221", "message": "Implementation of right heartbeat function\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:56Z", "type": "commit"}, {"oid": "5b4521bb29a7ec665071a3e4f4f39263ebfc3441", "url": "https://github.com/openhab/openhab-addons/commit/5b4521bb29a7ec665071a3e4f4f39263ebfc3441", "message": "Rework of send message procedure\nRework of heartbeat procedure\ncleaning up the code\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "ff542c8625b89822595e45a68bd318f3bc08921e", "url": "https://github.com/openhab/openhab-addons/commit/ff542c8625b89822595e45a68bd318f3bc08921e", "message": "Dfinition of correct channels\nImplementing of channels\nError managment\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "ec1f9622bce5076f96fc195042ed1fc94ba1a5aa", "url": "https://github.com/openhab/openhab-addons/commit/ec1f9622bce5076f96fc195042ed1fc94ba1a5aa", "message": "Some error optimizing\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "f3748fe4405aa2cac39a5e980ff2ecc270df7a5a", "url": "https://github.com/openhab/openhab-addons/commit/f3748fe4405aa2cac39a5e980ff2ecc270df7a5a", "message": "Implementation of general status channel to the Binding instead of a only ir recieved code channel\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "6bd01c7cf947a3d653746a9b879dcf30468fb7f4", "url": "https://github.com/openhab/openhab-addons/commit/6bd01c7cf947a3d653746a9b879dcf30468fb7f4", "message": "Deleting some useless comments\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "1ecebfe3432728753478bf0d6cd8d842275f7958", "url": "https://github.com/openhab/openhab-addons/commit/1ecebfe3432728753478bf0d6cd8d842275f7958", "message": "Implementing of correct error handling during heartbeat\nAdding more debug informations\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "1002f9e5acb6915402fd7758900ded5a970a5ec4", "url": "https://github.com/openhab/openhab-addons/commit/1002f9e5acb6915402fd7758900ded5a970a5ec4", "message": "Update the readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "6093be076b3908570e9cc4429f7735af6659aec3", "url": "https://github.com/openhab/openhab-addons/commit/6093be076b3908570e9cc4429f7735af6659aec3", "message": "Update readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "37284dc55609be01fd7cfdb968b7a193cac73239", "url": "https://github.com/openhab/openhab-addons/commit/37284dc55609be01fd7cfdb968b7a193cac73239", "message": "Update readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:57Z", "type": "commit"}, {"oid": "858e7d3cf6162fcb871614b851774fc7a951bbdd", "url": "https://github.com/openhab/openhab-addons/commit/858e7d3cf6162fcb871614b851774fc7a951bbdd", "message": "Update readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "34cd29af2720b3fb14838e5df0101de8eff95df3", "url": "https://github.com/openhab/openhab-addons/commit/34cd29af2720b3fb14838e5df0101de8eff95df3", "message": "readme.md update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "20d35ba864d89a1ad9b5b1ed729eb1adb3ccc05c", "url": "https://github.com/openhab/openhab-addons/commit/20d35ba864d89a1ad9b5b1ed729eb1adb3ccc05c", "message": "Update of readme.md\nUpdate of Default values\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "1eaf7b569716ef0b00d9540de79b72991df5f837", "url": "https://github.com/openhab/openhab-addons/commit/1eaf7b569716ef0b00d9540de79b72991df5f837", "message": "readme.md update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "8cd8e124751d3710ac4e63f02a20439e6a6122cd", "url": "https://github.com/openhab/openhab-addons/commit/8cd8e124751d3710ac4e63f02a20439e6a6122cd", "message": "readme.md update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "fb8e49e91f4047e1db36ae0f214682c3ffe5c351", "url": "https://github.com/openhab/openhab-addons/commit/fb8e49e91f4047e1db36ae0f214682c3ffe5c351", "message": "cleaning error\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "825e02ed784fd0f529a85e733dd7e4618a1f18a8", "url": "https://github.com/openhab/openhab-addons/commit/825e02ed784fd0f529a85e733dd7e4618a1f18a8", "message": "cleaning coding errors\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "f4cdbea843e784b3568c0d4f8b66423f3ff79375", "url": "https://github.com/openhab/openhab-addons/commit/f4cdbea843e784b3568c0d4f8b66423f3ff79375", "message": "add yioremote binding to the POM\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "931ebd9070c4daa89e714dc8a81725697b6f5282", "url": "https://github.com/openhab/openhab-addons/commit/931ebd9070c4daa89e714dc8a81725697b6f5282", "message": "applying coding style\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:58Z", "type": "commit"}, {"oid": "77d5da401964ebc3fc0027f806095afde531c63f", "url": "https://github.com/openhab/openhab-addons/commit/77d5da401964ebc3fc0027f806095afde531c63f", "message": "Adding localisation de_DE\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "14ce2c451f0d0bed77d36e4c314ef0f72c76ad55", "url": "https://github.com/openhab/openhab-addons/commit/14ce2c451f0d0bed77d36e4c314ef0f72c76ad55", "message": "pom.xml update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "883ba80fd5a6e3927351c02f1e2707ec1860a564", "url": "https://github.com/openhab/openhab-addons/commit/883ba80fd5a6e3927351c02f1e2707ec1860a564", "message": "Renaming of thing to Dock thing\nRenaming of the hostip parameter to simply host\nupdating readme\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "0d978dd5408a40e3d7a0fcaa0892f8ec8bb38e86", "url": "https://github.com/openhab/openhab-addons/commit/0d978dd5408a40e3d7a0fcaa0892f8ec8bb38e86", "message": "remove of the prefix yiodock of all channels\nReadme Update\nDeleting non used comments\nChanged some coding according to the review\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "1a0eeeb04b69d1094d5d7907cdce0874f5f23138", "url": "https://github.com/openhab/openhab-addons/commit/1a0eeeb04b69d1094d5d7907cdce0874f5f23138", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "ecf5f3a752e7a3ab819d1b1844109be998134f63", "url": "https://github.com/openhab/openhab-addons/commit/ecf5f3a752e7a3ab819d1b1844109be998134f63", "message": "Changed initialization to background\nReadme Update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "6c6165df24dc94a4fa997880ce0863ea56412baa", "url": "https://github.com/openhab/openhab-addons/commit/6c6165df24dc94a4fa997880ce0863ea56412baa", "message": "implementing Action Handler\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:00:59Z", "type": "commit"}, {"oid": "c5b27997bda8b0796704a3354c4c45fdbd967111", "url": "https://github.com/openhab/openhab-addons/commit/c5b27997bda8b0796704a3354c4c45fdbd967111", "message": "Removing of Input label and adding action sendircode handler\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "78b4eaa722fff3d40380884dca01185c046d4866", "url": "https://github.com/openhab/openhab-addons/commit/78b4eaa722fff3d40380884dca01185c046d4866", "message": "minor code changed\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "9f263cc4d17eba31f856b962360cf113f7ee6c3d", "url": "https://github.com/openhab/openhab-addons/commit/9f263cc4d17eba31f856b962360cf113f7ee6c3d", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "35f9ac7c9f881b114c1644269ca2bcf17b775d0a", "url": "https://github.com/openhab/openhab-addons/commit/35f9ac7c9f881b114c1644269ca2bcf17b775d0a", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "c055f3638661d09acb881f72070830709993961b", "url": "https://github.com/openhab/openhab-addons/commit/c055f3638661d09acb881f72070830709993961b", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "3aee8c30bc86e2936b12b13233ae143d74b29d08", "url": "https://github.com/openhab/openhab-addons/commit/3aee8c30bc86e2936b12b13233ae143d74b29d08", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "dbe56095e7e892f2f988e4bf82412de674c4980b", "url": "https://github.com/openhab/openhab-addons/commit/dbe56095e7e892f2f988e4bf82412de674c4980b", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "5eeea7bd9bcdee70db9f1336b0139d6946153084", "url": "https://github.com/openhab/openhab-addons/commit/5eeea7bd9bcdee70db9f1336b0139d6946153084", "message": "COde Stzle changes\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:00Z", "type": "commit"}, {"oid": "ed2bf7a5e1c9f3b70a676fc8fc9f3f7ef49a0036", "url": "https://github.com/openhab/openhab-addons/commit/ed2bf7a5e1c9f3b70a676fc8fc9f3f7ef49a0036", "message": "Code styling\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "bfe156b279899b2c96c2bc8e446e2a7a0ac139a6", "url": "https://github.com/openhab/openhab-addons/commit/bfe156b279899b2c96c2bc8e446e2a7a0ac139a6", "message": "Update bundles/org.openhab.binding.yioremote/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "2bb29c7b39e1ad2370c23b3964a9b0b2ab906880", "url": "https://github.com/openhab/openhab-addons/commit/2bb29c7b39e1ad2370c23b3964a9b0b2ab906880", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "f92a114c75bfe112c7d349a5364f63ccbe5b809e", "url": "https://github.com/openhab/openhab-addons/commit/f92a114c75bfe112c7d349a5364f63ccbe5b809e", "message": "Complete rewrite of the YIO Dock Handler\nIntroducing of Websocket interface\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "f887ede2273c00182f8714e73e88ea96c9d7ed6f", "url": "https://github.com/openhab/openhab-addons/commit/f887ede2273c00182f8714e73e88ea96c9d7ed6f", "message": "code optimization error managment improved\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "a299b70c2dfb44cfc5b493f60477229712feecb3", "url": "https://github.com/openhab/openhab-addons/commit/a299b70c2dfb44cfc5b493f60477229712feecb3", "message": "Forgot to set the thing online - solved\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "d831aad8b8f7e0e3f77cb14d5b2ad7dbc11fadf3", "url": "https://github.com/openhab/openhab-addons/commit/d831aad8b8f7e0e3f77cb14d5b2ad7dbc11fadf3", "message": "Minor code improvements\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "07164d3b4aae4e9d2625cf6e9640179cc8405d76", "url": "https://github.com/openhab/openhab-addons/commit/07164d3b4aae4e9d2625cf6e9640179cc8405d76", "message": "changes from github review\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "c7577d9c3e4bc83777bed6959cea06fc7297a5d1", "url": "https://github.com/openhab/openhab-addons/commit/c7577d9c3e4bc83777bed6959cea06fc7297a5d1", "message": "json object used\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:01Z", "type": "commit"}, {"oid": "a6d288e8099e83402ae0c940fd671be21b69ca32", "url": "https://github.com/openhab/openhab-addons/commit/a6d288e8099e83402ae0c940fd671be21b69ca32", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "0c75aa8ac38c849d0a05a02ecf2527c26a571630", "url": "https://github.com/openhab/openhab-addons/commit/0c75aa8ac38c849d0a05a02ecf2527c26a571630", "message": "Faster authentication process\nIntroducing DTOs\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "854a640735809855e2161c51f58f7af04e427751", "url": "https://github.com/openhab/openhab-addons/commit/854a640735809855e2161c51f58f7af04e427751", "message": "code cleaning\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "1b826869aafda8117bfd1c1c0df9a5d3992badbc", "url": "https://github.com/openhab/openhab-addons/commit/1b826869aafda8117bfd1c1c0df9a5d3992badbc", "message": "resolved code review\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "2bd78ff2b268d306eec5b7eb0c077257a45b7950", "url": "https://github.com/openhab/openhab-addons/commit/2bd78ff2b268d306eec5b7eb0c077257a45b7950", "message": "github issues solved\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "37e14c2c5189772a0e6a48a26c644e83da0358db", "url": "https://github.com/openhab/openhab-addons/commit/37e14c2c5189772a0e6a48a26c644e83da0358db", "message": "code changes\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "9fec3159d22ae80fad6794e8651aa2597a425f3e", "url": "https://github.com/openhab/openhab-addons/commit/9fec3159d22ae80fad6794e8651aa2597a425f3e", "message": "minor code changes\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "4ba40be747dd4b3e6c82512c3b71f007a48d57bf", "url": "https://github.com/openhab/openhab-addons/commit/4ba40be747dd4b3e6c82512c3b71f007a48d57bf", "message": "Readme Update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "894d8616f6a85ba8d2d6f5bf4fbe28ab10ba34bd", "url": "https://github.com/openhab/openhab-addons/commit/894d8616f6a85ba8d2d6f5bf4fbe28ab10ba34bd", "message": "readme update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:02Z", "type": "commit"}, {"oid": "c4b2b63a85ca7891c6af5330acf4f77533401c56", "url": "https://github.com/openhab/openhab-addons/commit/c4b2b63a85ca7891c6af5330acf4f77533401c56", "message": "files reorganisation\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:03Z", "type": "commit"}, {"oid": "0b38fff027189a7a8a249004e91d95bbc1a2b95f", "url": "https://github.com/openhab/openhab-addons/commit/0b38fff027189a7a8a249004e91d95bbc1a2b95f", "message": "package renaming\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:03Z", "type": "commit"}, {"oid": "64697ad7fb9ed2c0703e422d1c698934dbd41608", "url": "https://github.com/openhab/openhab-addons/commit/64697ad7fb9ed2c0703e422d1c698934dbd41608", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:03Z", "type": "commit"}, {"oid": "6acd6489da27c8f3f99670757b34dd17ea4da6d2", "url": "https://github.com/openhab/openhab-addons/commit/6acd6489da27c8f3f99670757b34dd17ea4da6d2", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:03Z", "type": "commit"}, {"oid": "200461587c5241f52be8561fcb0c175b6e3b1a35", "url": "https://github.com/openhab/openhab-addons/commit/200461587c5241f52be8561fcb0c175b6e3b1a35", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>", "committedDate": "2020-09-18T21:01:03Z", "type": "commit"}]}