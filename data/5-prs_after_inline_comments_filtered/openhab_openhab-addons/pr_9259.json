{"pr_number": 9259, "pr_title": "[androiddebugbridge] initial contribution", "pr_createdAt": "2020-12-06T16:17:37Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9259", "timeline": [{"oid": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "url": "https://github.com/openhab/openhab-addons/commit/a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "message": "initial contribution\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-06T15:56:13Z", "type": "commit"}, {"oid": "a0b12d2b8096e71f24c281493069fe7b201c9848", "url": "https://github.com/openhab/openhab-addons/commit/a0b12d2b8096e71f24c281493069fe7b201c9848", "message": "fix start package on devices without keys\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-13T00:17:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NDM5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541984392", "bodyText": "Is this field package-private by intention by not specifying private or public?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                static AdbCrypto adbCrypto;\n          \n          \n            \n                static @Nullable AdbCrypto ADB_CRYPTO;", "author": "fwolter", "createdAt": "2020-12-13T19:04:28Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985546", "bodyText": "You could create these files in OH's userdata directory. There are constants available to get the path.", "author": "fwolter", "createdAt": "2020-12-13T19:11:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985640", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:11:43Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985849", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:12:42Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985975", "bodyText": "AndroidDebugBridgeDeviceException is never thrown.", "author": "fwolter", "createdAt": "2020-12-13T19:13:35Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541986294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n          \n          \n            \n                    String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", stream, \"--get\", \"|\",", "author": "fwolter", "createdAt": "2020-12-13T19:15:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwMTMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542501329", "bodyText": "Seems like I can't apply this change. runAdbShell expect this \"String... args\".", "author": "GiviMAD", "createdAt": "2020-12-14T16:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxMDc5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542510797", "bodyText": "You're right, that won't work.", "author": "fwolter", "createdAt": "2020-12-14T16:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541986383", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:15:53Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987175", "bodyText": "If you don't need to distinguish between the exception types, you could use the same type with a different message.", "author": "fwolter", "createdAt": "2020-12-13T19:20:09Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987476", "bodyText": "Please use Thing.PROPERTY_* where applicable.", "author": "fwolter", "createdAt": "2020-12-13T19:21:49Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip)\n+            throws AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException, InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, discoveryPort);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, discoveryPort);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, discoveryPort, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_SERIAL, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(PARAMETER_MODEL, model);\n+        properties.put(PARAMETER_BRAND, brand);\n+        properties.put(PARAMETER_ANDROID_VERSION, androidVersion);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987572", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .withProperties(properties).withLabel(String.format(\"%s(%s)\", model, serialNo)).build());\n          \n          \n            \n                            .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());", "author": "fwolter", "createdAt": "2020-12-13T19:22:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip)\n+            throws AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException, InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, discoveryPort);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, discoveryPort);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, discoveryPort, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_SERIAL, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(PARAMETER_MODEL, model);\n+        properties.put(PARAMETER_BRAND, brand);\n+        properties.put(PARAMETER_ANDROID_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(PARAMETER_SERIAL)\n+                .withProperties(properties).withLabel(String.format(\"%s(%s)\", model, serialNo)).build());", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987981", "bodyText": "How long can this take at maximum? dispose() is supposed to return fast.", "author": "fwolter", "createdAt": "2020-12-13T19:24:50Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxMjc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542712750", "bodyText": "I made some test and it takes less than 5 ms always.", "author": "GiviMAD", "createdAt": "2020-12-14T19:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMDYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561200600", "bodyText": "What if there is a network problem? Would disconnect still execute quickly?", "author": "cpmeister", "createdAt": "2021-01-20T18:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMxMTYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561311639", "bodyText": "I've never face that problem when I was testing the device disconnection and reconnection. Also I have reviewed the implementation and I don't see any reason why its execution could be blocked by a network problem.", "author": "GiviMAD", "createdAt": "2021-01-20T21:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988173", "bodyText": "Unchecked exceptions are handled by the framework. So, this could be removed.", "author": "fwolter", "createdAt": "2020-12-13T19:26:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)\n+                    updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            } else {\n+                if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    updateStatus(ThingStatus.OFFLINE);\n+                }\n+                try {\n+                    adbConnection.connect();\n+                } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                        | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException e) {\n+                    logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                    return;\n+                }\n+                if (adbConnection.isConnected()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    refreshStatus();\n+                }\n+            }\n+        } catch (Exception e) {\n+            // retry on unexpected errors", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988324", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "author": "fwolter", "createdAt": "2020-12-13T19:27:03Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)\n+public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n+    @Nullable\n+    private AndroidDebugBridgeDiscoveryService discoveryService;\n+    @Nullable\n+    private ServiceRegistration<?> discoveryServiceRegistration;\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        if (THING_TYPE_ANDROID_DEVICE.equals(thingTypeUID)) {\n+            return new AndroidDebugBridgeHandler(thing, new AndroidDebugBridgeDevice());\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void registerDiscoveryService(AndroidDebugBridgeBindingConfiguration config) {\n+        AndroidDebugBridgeDiscoveryService androidADBDiscoveryService = discoveryService;\n+        if (androidADBDiscoveryService != null) {\n+            androidADBDiscoveryService.updateConfig(config);\n+        } else {\n+            androidADBDiscoveryService = new AndroidDebugBridgeDiscoveryService();\n+            androidADBDiscoveryService.updateConfig(config);\n+            discoveryService = androidADBDiscoveryService;\n+            discoveryServiceRegistration = bundleContext.registerService(DiscoveryService.class.getName(),\n+                    androidADBDiscoveryService, null);\n+        }\n+    }\n+\n+    private void unregisterDiscoveryService() {\n+        var adbDiscoveryServiceRegistration = discoveryServiceRegistration;\n+        if (adbDiscoveryServiceRegistration != null) {\n+            adbDiscoveryServiceRegistration.unregister();\n+            discoveryServiceRegistration = null;\n+        }\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> config) {\n+        super.activate(componentContext);\n+        modified(config);\n+    }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY5NzAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542697016", "bodyText": "I was reviewing the documentation in the pr and seems like I need to create a bridge, right now I'm just passing the binding configurations to the discovery.\nIs there any other way to access to the binding configuration from the discovery service?\nOr should I create a bridge just to configure the service discovery?\nMaybe I'm missing something.\nThanks in advance.", "author": "GiviMAD", "createdAt": "2020-12-14T19:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MTQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543441409", "bodyText": "If your discovery implements ThingHandlerService you need to implement the interface method setThingHandler(ThingHandler handler). Then, you can retrieve the bridge's config from the handler: handler.getThing().getConfiguration()", "author": "fwolter", "createdAt": "2020-12-15T15:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3Mzc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543473751", "bodyText": "It doesn't seem to fit my case because I don't have any bridge implemented on the binding. I configure the discovery through the binding configuration.", "author": "GiviMAD", "createdAt": "2020-12-15T16:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxMTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543511346", "bodyText": "Now I get it. The binding configuration is stored as properties in the AndroidDebugBridgeHandlerFactory service. I never done this, but if you're keen, you could retrieve the config by injecting ConfigurationAdmin in the discovery class:\n    @Reference\n    void setConfigurationAdmin(ConfigurationAdmin admin) {\n        this.admin = admin;\n    }\n \n    public void ranking() throws IOException {\n        Configuration configOnline =\n            this.admin.getConfiguration(\n                \"org.fipro.ds.data.online.OnlineDataService\",\n                null);\n        Dictionary<String, Object> propsOnline = null;\n        if (configOnline != null\n                && configOnline.getProperties() != null) {\n            propsOnline = configOnline.getProperties();\n        }\n\nThe string argument to admin.getConfiguration() must be the PID of your factory: \"binding.androiddebugbridge\"\nThen, you should be able to obtain a config parameter by calling for example propsOnline.get(\"discoveryPort\"). I'm curious if this works.\nEDIT: I got the code frome here http://blog.vogella.com/2016/09/26/configuring-osgi-declarative-services/", "author": "fwolter", "createdAt": "2020-12-15T16:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4OTczMw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541989733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Refresh device {} status\", config.ip);\n          \n          \n            \n                        logger.debug(\"Refresh device {} status\", currentConfig.ip);", "author": "fwolter", "createdAt": "2020-12-13T19:35:01Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "034b86b1e5da198b5c627fd0ddc774820ee675db", "url": "https://github.com/openhab/openhab-addons/commit/034b86b1e5da198b5c627fd0ddc774820ee675db", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-14T18:00:20Z", "type": "commit"}, {"oid": "4d5a456df2ef9cb0f643af9703311e218ce97bc4", "url": "https://github.com/openhab/openhab-addons/commit/4d5a456df2ef9cb0f643af9703311e218ce97bc4", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-14T19:42:50Z", "type": "commit"}, {"oid": "bc7f05e731424a489b28055c07a99da45736ed60", "url": "https://github.com/openhab/openhab-addons/commit/bc7f05e731424a489b28055c07a99da45736ed60", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-15T22:41:42Z", "type": "commit"}, {"oid": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "url": "https://github.com/openhab/openhab-addons/commit/50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "message": "fix adb keys path\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T01:23:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2OTc5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544469793", "bodyText": "Great to see this works!\nYou could inject this via the constructor to get rid of the Nullable annotation.", "author": "fwolter", "createdAt": "2020-12-16T17:06:13Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private @Nullable ConfigurationAdmin admin;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip, int port)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, port);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, port);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, port, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(Thing.PROPERTY_MODEL_ID, model);\n+        properties.put(Thing.PROPERTY_VENDOR, brand);\n+        properties.put(Thing.PROPERTY_FIRMWARE_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER)\n+                .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());\n+    }\n+\n+    @Reference\n+    void setConfigurationAdmin(ConfigurationAdmin admin) {\n+        this.admin = admin;\n+    }", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3MDQ5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544470494", "bodyText": "Can you make \"binding.androiddebugbridge\" a constant?", "author": "fwolter", "createdAt": "2020-12-16T17:07:08Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private @Nullable ConfigurationAdmin admin;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip, int port)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, port);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, port);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, port, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(Thing.PROPERTY_MODEL_ID, model);\n+        properties.put(Thing.PROPERTY_VENDOR, brand);\n+        properties.put(Thing.PROPERTY_FIRMWARE_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER)\n+                .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());\n+    }\n+\n+    @Reference\n+    void setConfigurationAdmin(ConfigurationAdmin admin) {\n+        this.admin = admin;\n+    }\n+\n+    private @Nullable Dictionary<String, Object> getConfig() {\n+        var currentAdmin = admin;\n+        if (currentAdmin == null) {\n+            logger.warn(\"Configuration admin not ready\");\n+            return null;\n+        }\n+        try {\n+            Configuration configOnline = currentAdmin.getConfiguration(\"binding.androiddebugbridge\", null);", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3MjIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544472236", "bodyText": "I think you could use the constant here, too.", "author": "fwolter", "createdAt": "2020-12-16T17:09:37Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "url": "https://github.com/openhab/openhab-addons/commit/b2774c159d3dd1e130df482e59b7644f8ce5b636", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T19:49:50Z", "type": "commit"}, {"oid": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "url": "https://github.com/openhab/openhab-addons/commit/b2774c159d3dd1e130df482e59b7644f8ce5b636", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T19:49:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTc5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548345794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private Socket socket;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private AdbConnection connection;\n          \n          \n            \n                private @Nullable Socket socket;\n          \n          \n            \n                private @Nullable AdbConnection connection;", "author": "cpmeister", "createdAt": "2020-12-24T01:47:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346264", "bodyText": "Please do not perform sleep operations in the startScan method. Those are called from a UI thread and as such you should make sure that startScan returns quickly.", "author": "cpmeister", "createdAt": "2020-12-24T01:50:04Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346384", "bodyText": "super.dispose() should be called last.", "author": "cpmeister", "createdAt": "2020-12-24T01:50:52Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346725", "bodyText": "InterruptExceptions should cause an immediate return from the current method. You should not perform additional operations once an interrupt has been received since you would be delaying openhab from shutting down.", "author": "cpmeister", "createdAt": "2020-12-24T01:52:32Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        logger.debug(\"Refresh device {} status\", currentConfig.ip);\n+        if (adbConnection.isConnected()) {\n+            if (thing.getStatus() != ThingStatus.ONLINE)\n+                updateStatus(ThingStatus.ONLINE);\n+            refreshStatus();\n+        } else {\n+            if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+            try {\n+                adbConnection.connect();\n+            } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException e) {\n+                logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                return;\n+            }\n+            if (adbConnection.isConnected()) {\n+                updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            }\n+        }\n+    }\n+\n+    private void refreshStatus() {\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_VOLUME_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh media volume: {}\", e.getMessage());\n+        }\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_CONTROL_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh play status: {}\", e.getMessage());\n+        }\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh current package: {}\", e.getMessage());\n+        }", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346848", "bodyText": "Should such errors also cause the thing status to go offline?", "author": "cpmeister", "createdAt": "2020-12-24T01:53:10Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        logger.debug(\"Refresh device {} status\", currentConfig.ip);\n+        if (adbConnection.isConnected()) {\n+            if (thing.getStatus() != ThingStatus.ONLINE)\n+                updateStatus(ThingStatus.ONLINE);\n+            refreshStatus();\n+        } else {\n+            if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+            try {\n+                adbConnection.connect();\n+            } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException e) {\n+                logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                return;\n+            }\n+            if (adbConnection.isConnected()) {\n+                updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            }\n+        }\n+    }\n+\n+    private void refreshStatus() {\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_VOLUME_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh media volume: {}\", e.getMessage());", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc2ODc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548768758", "bodyText": "It will allow to detect that the device is offline sooner, so yes I'll change it", "author": "GiviMAD", "createdAt": "2020-12-25T00:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzNDE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551834158", "bodyText": "For my Fire TV Stick this warning is logged all the time. I think we should reduce logging level here. Otherwise it will be very annoying. Or I have to reduce logging to ERROR for this binding in my logging config.", "author": "cweitkamp", "createdAt": "2021-01-05T10:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NzI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347277", "bodyText": "Please don't use var for primitives, it just leads to possible confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            var retries = 0;\n          \n          \n            \n                                            int retries = 0;", "author": "cpmeister", "createdAt": "2020-12-24T01:55:16Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Nzc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347747", "bodyText": "Since these exceptions are used outside of this class, please move these exceptions to their own files.", "author": "cpmeister", "createdAt": "2020-12-24T01:57:06Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isPlayingMedia() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            adbConnection.connect();\n+        } catch (IOException | InterruptedException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+        connection = adbConnection;\n+        socket = sock;\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        synchronized (adb) {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;\n+            }\n+            return byteArrayOutputStream.toString(StandardCharsets.US_ASCII);\n+        }\n+    }\n+\n+    private static AdbBase64 getBase64Impl() {\n+        return bytes -> new String(Base64.getEncoder().encode(bytes));\n+    }\n+\n+    private static AdbCrypto loadKeyPair(String pubKeyFile, String privKeyFile)\n+            throws NoSuchAlgorithmException, IOException, InvalidKeySpecException {\n+        File pub = new File(pubKeyFile);\n+        File priv = new File(privKeyFile);\n+        AdbCrypto c = null;\n+        // load key pair\n+        if (pub.exists() && priv.exists()) {\n+            try {\n+                c = AdbCrypto.loadAdbKeyPair(getBase64Impl(), priv, pub);\n+            } catch (IOException ignored) {\n+                // Keys don't exits\n+            }\n+        }\n+        if (c == null) {\n+            // generate key pair\n+            c = AdbCrypto.generateAdbKeyPair(getBase64Impl());\n+            c.saveAdbKeyPair(priv, pub);\n+        }\n+        return c;\n+    }\n+\n+    public void disconnect() {\n+        var adb = connection;\n+        var sock = socket;\n+        if (adb != null) {\n+            try {\n+                adb.close();\n+            } catch (IOException ignored) {\n+            }\n+            connection = null;\n+        }\n+        if (sock != null) {\n+            try {\n+                sock.close();\n+            } catch (IOException ignored) {\n+            }\n+            socket = null;\n+        }\n+    }\n+\n+    static class AndroidDebugBridgeDeviceException extends Exception {\n+        public AndroidDebugBridgeDeviceException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    static class AndroidDebugBridgeDeviceReadException extends Exception {\n+        public AndroidDebugBridgeDeviceReadException(String message) {\n+            super(message);\n+        }\n+    }", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Nzg3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347874", "bodyText": "Please use brackets for every if statement.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!discoveryRunning)\n          \n          \n            \n                                    break;\n          \n          \n            \n                                if (!discoveryRunning) {\n          \n          \n            \n                                    break;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2020-12-24T01:57:55Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72083e308970c6f374ee9c086b2444f8305536d7", "url": "https://github.com/openhab/openhab-addons/commit/72083e308970c6f374ee9c086b2444f8305536d7", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-25T00:32:16Z", "type": "commit"}, {"oid": "1d82987a176827aa9a51aa11f790181a09d940ac", "url": "https://github.com/openhab/openhab-addons/commit/1d82987a176827aa9a51aa11f790181a09d940ac", "message": "upgrade adblib dependency\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-03T23:28:54Z", "type": "commit"}, {"oid": "1d82987a176827aa9a51aa11f790181a09d940ac", "url": "https://github.com/openhab/openhab-addons/commit/1d82987a176827aa9a51aa11f790181a09d940ac", "message": "upgrade adblib dependency\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-03T23:28:54Z", "type": "forcePushed"}, {"oid": "bee1864a2b3e97e7f260f83cb65fd8051c5dcb87", "url": "https://github.com/openhab/openhab-addons/commit/bee1864a2b3e97e7f260f83cb65fd8051c5dcb87", "message": "Merge branch 'main' of https://github.com/openhab/openhab-addons into androiddebugbridge", "committedDate": "2021-01-04T10:34:16Z", "type": "commit"}, {"oid": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "url": "https://github.com/openhab/openhab-addons/commit/8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "message": "update copyright message and version number\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-04T10:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NTcxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537695710", "bodyText": "Can we set the reason why the thing is offline? And I think we should do this only if the connect() fails e.g. in the catch block below.", "author": "cweitkamp", "createdAt": "2020-12-07T17:36:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)\n+                    updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            } else {\n+                if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    updateStatus(ThingStatus.OFFLINE);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5ODAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537698037", "bodyText": "Do not do this. The OHC framweork takes care of it.", "author": "cweitkamp", "createdAt": "2020-12-07T17:39:59Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537704403", "bodyText": "This is not clear enough. Even if we add the exception message to the ThingStatusDetails the user does not know what to do next. We should give a clear advice or at least add a debug log.", "author": "cweitkamp", "createdAt": "2020-12-07T17:48:56Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNDUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537704522", "bodyText": "This is not clear enough. Even if we add the exception message to the ThingStatusDetails the user does not know what to do next. We should give a clear advice or at least add a debug log.", "author": "cweitkamp", "createdAt": "2020-12-07T17:49:05Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            adbConnection.connect();\n+        } catch (IOException | InterruptedException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551830720", "bodyText": "I personally would check on \"media_sesssion\" first before \"audio\". At least for Android TV or Fire TV. Wdyt?\nIn general I am not very happy with the isPlaying() detection. E.g. My Fire TV Stick is playing all the time, event when I am on the home screen. Maybe we can add a configuration parameter to exclude specific, user-defined packages (e.g. \"com.amazon.tv.launcher\") for.\nIIRC I somewhere read about kind of \"state_detection_rules\" for Android TV:\nstate_detection_rules = {\n    'com.amazon.tv.launcher': ['idle'],\n    'com.netflix.ninja': ['media_session_state'],\n    'com.ellation.vrv': ['audio_state'],\n    'com.hulu.plus': [{'playing': {'wake_lock_size': 4}}, {'paused': {'wake_lock_size': 2}}],\n    'com.plexapp.android': [{'paused': {'media_session_state': 3,'wake_lock_size': 1}}, {'playing': {'media_session_state\u02d3': 3}}, 'idle']\n}\n\nVALID_STATES = ('idle', 'off', 'playing', 'paused', 'standby')", "author": "cweitkamp", "createdAt": "2021-01-05T10:01:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isPlayingMedia() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\");", "originalCommit": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MzkyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r552883924", "bodyText": "I wasn't taking in account the current app for the playing check, now it should work better.\nAlso I ended up implementing different ways of detect the player state, I have added the documentation. It's something similar to the solution implemented by HA. Basically you can configure a different detection mode by package name.", "author": "GiviMAD", "createdAt": "2021-01-06T18:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r554426991", "bodyText": "Did you test them? What is your personal feeling?", "author": "cweitkamp", "createdAt": "2021-01-09T13:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA=="}], "type": "inlineReview"}, {"oid": "df6d0c31577b6dab608946b51b061370b9e00731", "url": "https://github.com/openhab/openhab-addons/commit/df6d0c31577b6dab608946b51b061370b9e00731", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:05:18Z", "type": "forcePushed"}, {"oid": "373b1264e9511d102d6aa0aa7b84c9d252a40195", "url": "https://github.com/openhab/openhab-addons/commit/373b1264e9511d102d6aa0aa7b84c9d252a40195", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:47:29Z", "type": "commit"}, {"oid": "373b1264e9511d102d6aa0aa7b84c9d252a40195", "url": "https://github.com/openhab/openhab-addons/commit/373b1264e9511d102d6aa0aa7b84c9d252a40195", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:47:29Z", "type": "forcePushed"}, {"oid": "785e2da4b4858005d59048334aeb38ea00624be2", "url": "https://github.com/openhab/openhab-addons/commit/785e2da4b4858005d59048334aeb38ea00624be2", "message": "fix device reconnection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-09T17:50:06Z", "type": "commit"}, {"oid": "c6776489b88dfb2b3d441bf122e77366efcc2ad7", "url": "https://github.com/openhab/openhab-addons/commit/c6776489b88dfb2b3d441bf122e77366efcc2ad7", "message": "fix dispose errors\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T00:52:22Z", "type": "commit"}, {"oid": "ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "url": "https://github.com/openhab/openhab-addons/commit/ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "message": "minor fixes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T01:19:54Z", "type": "commit"}, {"oid": "ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "url": "https://github.com/openhab/openhab-addons/commit/ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "message": "minor fixes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T01:19:54Z", "type": "forcePushed"}, {"oid": "38017de65a87a9a8f582af1ce951add2acc4e111", "url": "https://github.com/openhab/openhab-addons/commit/38017de65a87a9a8f582af1ce951add2acc4e111", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-18T23:28:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA4MTY0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r560081646", "bodyText": "You can use a switch-statement instead of the if-else combination.\nswitch(channelId) {\n    case STOP_CURRENT_PACKAGE_CHANNEL:\n        ...\n        break;\n...\n}", "author": "cweitkamp", "createdAt": "2021-01-19T10:43:24Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -110,6 +110,10 @@ private void handleCommandInternal(ChannelUID channelUID, Command command)\n                     new StringType(command.toFullString()));\n         } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n             adbConnection.stopPackage(command.toFullString());\n+        } else if (STOP_CURRENT_PACKAGE_CHANNEL.equals(channelId)) {", "originalCommit": "38017de65a87a9a8f582af1ce951add2acc4e111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "770e2c4871110b709efd035278fd0922095179cc", "url": "https://github.com/openhab/openhab-addons/commit/770e2c4871110b709efd035278fd0922095179cc", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-19T13:49:10Z", "type": "commit"}, {"oid": "9674b9ab2953cb250954a6102baf08763faa6b3f", "url": "https://github.com/openhab/openhab-addons/commit/9674b9ab2953cb250954a6102baf08763faa6b3f", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-19T14:02:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4NzIxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561187219", "bodyText": "You should specify the Charset you are using here.", "author": "cpmeister", "createdAt": "2021-01-20T18:35:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;\n+            }\n+            return byteArrayOutputStream.toString(StandardCharsets.US_ASCII);\n+        });\n+        this.commandFuture = commandFuture;\n+        return commandFuture.get(timeoutSec, TimeUnit.SECONDS);\n+    }\n+\n+    private static AdbBase64 getBase64Impl() {\n+        return bytes -> new String(Base64.getEncoder().encode(bytes));", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4ODYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561188605", "bodyText": "The use of var here makes it hard to understand what the type at a glance.", "author": "cpmeister", "createdAt": "2021-01-20T18:37:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4OTExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561189111", "bodyText": "All if statements should have brackets.", "author": "cpmeister", "createdAt": "2021-01-20T18:38:34Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5MzkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561193929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!(inetAddress instanceof Inet4Address))\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                if (!(inetAddress instanceof Inet4Address) || inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP)) {\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2021-01-20T18:46:07Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        AndroidDebugBridgeBindingConfiguration configuration = getConfig();\n+        if (configuration == null) {\n+            return;\n+        }\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning) {\n+                        break;\n+                    }\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NTY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561195669", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean discoveryRunning = false;\n          \n          \n            \n                private ConfigurationAdmin admin;\n          \n          \n            \n                private final ConfigurationAdmin admin;\n          \n          \n            \n                private boolean discoveryRunning = false;", "author": "cpmeister", "createdAt": "2021-01-20T18:48:54Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NzQwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561197402", "bodyText": "Since you are trying against all the network interfaces, it is expected for most of them to fail. So I think logging warning here would unnecessarily fill the logs.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n          \n          \n            \n                                        logger.debug(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());", "author": "cpmeister", "createdAt": "2021-01-20T18:51:39Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        AndroidDebugBridgeBindingConfiguration configuration = getConfig();\n+        if (configuration == null) {\n+            return;\n+        }\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning) {\n+                        break;\n+                    }\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (int i = configuration.discoveryIpRangeMin; i <= configuration.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning) {\n+                            break;\n+                        }\n+                        ipParts[3] = Integer.toString(i);\n+                        String currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(configuration.discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                int retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, configuration.discoveryPort);\n+                                    } catch (AndroidDebugBridgeDeviceReadException | TimeoutException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDeviceException | AndroidDebugBridgeDeviceReadException\n+                                | TimeoutException | ExecutionException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5OTgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561199839", "bodyText": "You should check the cause of the ExecutionException since if it was caused by a cancellation then that would mean that the handler is getting shut down, thus you shouldn't be changing statuses or disconnecting the connection since the dispose would already be handling that.", "author": "cpmeister", "createdAt": "2021-01-20T18:55:36Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private final Gson gson;\n+    private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+        super(thing);\n+        this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null){\n+            return;\n+        }\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (InterruptedException ignored) {\n+        } catch (AndroidDebugBridgeDeviceException | ExecutionException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDeviceReadException e) {", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMDk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561200982", "bodyText": "You should include the exception message in the log.", "author": "cpmeister", "createdAt": "2021-01-20T18:57:24Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private final Gson gson;\n+    private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+        super(thing);\n+        this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null){\n+            return;\n+        }\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (InterruptedException ignored) {\n+        } catch (AndroidDebugBridgeDeviceException | ExecutionException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"{} - read error: {}\", currentConfig.ip, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.warn(\"{} - timeout error\", currentConfig.ip);\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException,\n+            TimeoutException, ExecutionException {\n+        if (!isLinked(channelUID)){\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case KEY_EVENT_CHANNEL:\n+                adbConnection.sendKeyEvent(command.toFullString());\n+                break;\n+            case TEXT_CHANNEL:\n+                adbConnection.sendText(command.toFullString());\n+                break;\n+            case MEDIA_VOLUME_CHANNEL:\n+                handleMediaVolume(channelUID, command);\n+                break;\n+            case MEDIA_CONTROL_CHANNEL:\n+                handleMediaControlCommand(channelUID, command);\n+                break;\n+            case START_PACKAGE_CHANNEL:\n+                adbConnection.startPackage(command.toFullString());\n+                updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                        new StringType(command.toFullString()));\n+                break;\n+            case STOP_PACKAGE_CHANNEL:\n+                adbConnection.stopPackage(command.toFullString());\n+                break;\n+            case STOP_CURRENT_PACKAGE_CHANNEL:\n+                if (OnOffType.from(command.toFullString()).equals(OnOffType.OFF)) {\n+                    adbConnection.stopPackage(adbConnection.getCurrentPackage());\n+                }\n+                break;\n+            case CURRENT_PACKAGE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    var packageName = adbConnection.getCurrentPackage();\n+                    updateState(channelUID, new StringType(packageName));\n+                }\n+                break;\n+            case WAKE_LOCK_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    int lock = adbConnection.getPowerWakeLock();\n+                    updateState(channelUID, new DecimalType(lock));\n+                }\n+                break;\n+            case SCREEN_STATE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    boolean screenState = adbConnection.isScreenOn();\n+                    updateState(channelUID, OnOffType.from(screenState));\n+                }\n+                break;\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceReadException, AndroidDebugBridgeDeviceException,\n+            TimeoutException, ExecutionException {\n+        if (command instanceof RefreshType) {\n+            var volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0){\n+                return; // We can not transform percentage\n+            }\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException,\n+            TimeoutException, ExecutionException {\n+        if (command instanceof RefreshType) {\n+            boolean playing;\n+            String currentPackage = adbConnection.getCurrentPackage();\n+            var currentPackageConfig = packageConfigs != null ? Arrays.stream(packageConfigs)\n+                    .filter(pc -> pc.name.equals(currentPackage)).findFirst().orElse(null) : null;\n+            if (currentPackageConfig != null) {\n+                logger.debug(\"media stream config found for {}, mode: {}\", currentPackage, currentPackageConfig.mode);\n+                switch (currentPackageConfig.mode) {\n+                    case \"idle\":\n+                        playing = false;\n+                        break;\n+                    case \"wake_lock\":\n+                        int wakeLockState = adbConnection.getPowerWakeLock();\n+                        playing = currentPackageConfig.wakeLockPlayStates.contains(wakeLockState);\n+                        break;\n+                    case \"media_state\":\n+                        playing = adbConnection.isPlayingMedia(currentPackage);\n+                        break;\n+                    case \"audio\":\n+                        playing = adbConnection.isPlayingAudio();\n+                        break;\n+                    default:\n+                        logger.warn(\"media state config: package {} unsupported mode\", currentPackage);\n+                        playing = false;\n+                }\n+            } else {\n+                logger.debug(\"media stream config not found for {}\", currentPackage);\n+                playing = adbConnection.isPlayingMedia(currentPackage);\n+            }\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        var mediaStateJSONConfig = currentConfig.mediaStateJSONConfig;\n+        if (mediaStateJSONConfig != null && !mediaStateJSONConfig.isEmpty()) {\n+            loadMediaStateConfig(mediaStateJSONConfig);\n+        }\n+        adbConnection.configure(currentConfig.ip, currentConfig.port, currentConfig.timeout);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    private void loadMediaStateConfig(String mediaStateJSONConfig) {\n+        try {\n+            this.packageConfigs = gson.fromJson(mediaStateJSONConfig,\n+                    AndroidDebugBridgeMediaStatePackageConfig[].class);\n+        } catch (JsonSyntaxException e) {\n+            logger.warn(\"unable to parse media state config\");", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMTcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561201720", "bodyText": "You can avoid making your configuration nullable by setting it to the default config initially.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable AndroidDebugBridgeConfiguration config;\n          \n          \n            \n                private AndroidDebugBridgeConfiguration config = new AndroidDebugBridgeConfiguration();", "author": "cpmeister", "createdAt": "2021-01-20T18:58:32Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwNDQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561204475", "bodyText": "Instead of defining this here, define it in the AndroidDebugBridgeHandler as a static final constant.", "author": "cpmeister", "createdAt": "2021-01-20T19:03:28Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = BINDING_CONFIGURATION_PID, service = ThingHandlerFactory.class)\n+public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n+    Gson gson = new Gson();", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "url": "https://github.com/openhab/openhab-addons/commit/d89cd4b00101df472b19eaaee4614ceb60ba5750", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-20T21:11:31Z", "type": "commit"}]}