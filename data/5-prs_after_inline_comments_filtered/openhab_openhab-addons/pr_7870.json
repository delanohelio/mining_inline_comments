{"pr_number": 7870, "pr_title": "[mpd]: Music Player Daemon initial contribution", "pr_createdAt": "2020-06-07T09:14:41Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7870", "timeline": [{"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "url": "https://github.com/openhab/openhab-addons/commit/7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "message": "[mpd]: reduce number of requests at startup\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-07-04T17:13:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTg2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451801861", "bodyText": "Are you aware of this bug openhab/openhab-core#1265?\nIf you want, you could add a workaround like this:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "author": "fwolter", "createdAt": "2020-07-08T20:19:10Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mpd.internal.handler.MPDHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link @MPDActions} defines rule actions for the Music Player Daemon binding. *\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@ThingActionsScope(name = \"mpd\")\n+@NonNullByDefault\n+public class MPDActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDActions.class);\n+\n+    private @Nullable MPDHandler handler = null;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof MPDHandler) {\n+            this.handler = (MPDHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command,\n+            @ActionInput(name = \"parameter\") @Nullable String parameter) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        if (handler != null) {\n+            handler.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        if (handler != null) {\n+            handler.sendCommand(command);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    public static void sendCommand(@Nullable ThingActions actions, @Nullable String command,", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003148", "bodyText": "I faced this bug during development - I have implemented the workaround and would appreciate if you could have a look.", "author": "stefanroellin", "createdAt": "2020-07-10T18:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzU0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451803547", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (uid == null || host == null || \"\".equals(host)) {\n          \n          \n            \n                    if (uid == null || host == null || host.isEmpty()) {", "author": "fwolter", "createdAt": "2020-07-08T20:22:29Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || \"\".equals(host)) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003195", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451803777", "bodyText": "Can you add a representation property?", "author": "fwolter", "createdAt": "2020-07-08T20:22:51Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || \"\".equals(host)) {\n+            return null;\n+        }\n+\n+        final Map<String, Object> properties = new HashMap<>(2);\n+        properties.put(MPDBindingConstants.PARAMETER_IPADDRESS, host);\n+        properties.put(MPDBindingConstants.PARAMETER_PORT, port);\n+\n+        String name = service.getName();\n+\n+        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(name)\n+                .build();", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzM1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003354", "bodyText": "Did not know of the representation property. I have added it.", "author": "stefanroellin", "createdAt": "2020-07-10T18:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTMxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451805319", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently). You might want to move it to the end of this method.", "author": "fwolter", "createdAt": "2020-07-08T20:25:52Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003957", "bodyText": "In theory, the thread could update the status before updateStatus from the main thread is called. Therefore I would prefer to leave it before the start of the thread.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTYxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451805614", "bodyText": "No harm in cancelling a task that is already cancelled. Same for below.", "author": "fwolter", "createdAt": "2020-07-08T20:26:25Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null && !future.isCancelled()) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003996", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNjM2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451806366", "bodyText": "Syntactical sugar. Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.futureUpdateCurrentSong = scheduler.schedule(() -> doUpdateCurrentSong(), 100, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        this.futureUpdateStatus = scheduler.schedule(this::doUpdateStatus, 100, TimeUnit.MILLISECONDS);", "author": "fwolter", "createdAt": "2020-07-08T20:27:56Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateStatus = scheduler.schedule(() -> doUpdateStatus(), 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateStatus() {\n+        connection.updateStatus();\n+    }\n+\n+    private synchronized void scheduleUpdateCurrentSong() {\n+        logger.debug(\"scheduleUpdateCurrentSong\");\n+        ScheduledFuture<?> future = this.futureUpdateCurrentSong;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateCurrentSong = scheduler.schedule(() -> doUpdateCurrentSong(), 100, TimeUnit.MILLISECONDS);", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453004070", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNjM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwOTU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451809540", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)", "author": "fwolter", "createdAt": "2020-07-08T20:34:22Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNDExOA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453004118", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwOTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMTYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451811637", "bodyText": "Thing.dispose() should return fast. Can't you just close the socket?", "author": "fwolter", "createdAt": "2020-07-08T20:38:38Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNDY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453004664", "bodyText": "You are right. I have tried before with closeSocket(), but that did not work, since it blocked somewhere. Now, the socket is closed.", "author": "stefanroellin", "createdAt": "2020-07-10T18:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMjc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451812740", "bodyText": "Do you ignore the exception by intention? Is it worth to log it?", "author": "fwolter", "createdAt": "2020-07-08T20:40:52Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));\n+            sendNoIdleIfInIdle();\n+            interrupt();\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNTAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453005008", "bodyText": "I have added a log, since it might fail.", "author": "stefanroellin", "createdAt": "2020-07-10T18:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMjc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451814387", "bodyText": "If I see correctly, you need to store InputStreamReader to close it, too.", "author": "fwolter", "createdAt": "2020-07-08T20:44:10Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));\n+            sendNoIdleIfInIdle();\n+            interrupt();\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", this.address, this.port);\n+        Socket socket = new Socket(this.address, this.port);\n+\n+        reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNTcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453005725", "bodyText": "From the documentation it is not clear, whether the InputStreamReader is automatically closed by the BufferedReader. Looking at the code, it is closed. Since it does not harm, I have added it.", "author": "stefanroellin", "createdAt": "2020-07-10T18:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNTkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451815931", "bodyText": "Is this expected to fail? Otherwise, you could log it.", "author": "fwolter", "createdAt": "2020-07-08T20:47:20Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for representing a song.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDSong {\n+    private final String filename;\n+    private final String album;\n+    private final String artist;\n+    private final String name;\n+    private final int song;\n+    private final int songId;\n+    private final String title;\n+    private final int track;\n+\n+    public MPDSong(MPDResponse response) {\n+        Map<String, String> values = MPDResponseParser.responseToMap(response);\n+        filename = values.getOrDefault(\"file\", \"\");\n+        album = values.getOrDefault(\"Album\", \"\");\n+        artist = values.getOrDefault(\"Artist\", \"\");\n+        name = values.getOrDefault(\"Name\", \"\");\n+        song = parseInteger(values.getOrDefault(\"Pos\", \"0\"), 0);\n+        songId = parseInteger(values.getOrDefault(\"Id\", \"0\"), 0);\n+        title = values.getOrDefault(\"Title\", \"\");\n+        track = parseInteger(values.getOrDefault(\"Track\", \"-1\"), -1);\n+    }\n+\n+    public String getFilename() {\n+        return filename;\n+    }\n+\n+    public String getAlbum() {\n+        return album;\n+    }\n+\n+    public String getArtist() {\n+        return artist;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getSong() {\n+        return song;\n+    }\n+\n+    public int getSongId() {\n+        return songId;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public int getTrack() {\n+        return track;\n+    }\n+\n+    private int parseInteger(String value, int aDefault) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453005975", "bodyText": "It should not fail, but I have added a log anyway.", "author": "stefanroellin", "createdAt": "2020-07-10T18:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNTkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNjUzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451816534", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-07-08T20:48:34Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for representing the status of a Music Player Daemon.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDStatus {\n+\n+    public enum State {\n+        PLAY,\n+        PAUSE,\n+        STOP\n+    }\n+\n+    private final State state;\n+    private final int volume;\n+\n+    public MPDStatus(MPDResponse response) {\n+        Map<String, String> values = MPDResponseParser.responseToMap(response);\n+        state = parseState(values.getOrDefault(\"state\", \"\"));\n+        volume = parseVolume(values.getOrDefault(\"volume\", \"0\"));\n+    }\n+\n+    public State getState() {\n+        return state;\n+    }\n+\n+    public int getVolume() {\n+        return volume;\n+    }\n+\n+    private State parseState(String value) {\n+        switch (value) {\n+            case \"play\":\n+                return State.PLAY;\n+            case \"pause\":\n+                return State.PAUSE;\n+            case \"stop\":\n+                return State.STOP;\n+        }\n+\n+        return State.STOP;\n+    }\n+\n+    private int parseVolume(String value) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNjAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453006021", "bodyText": "It should not fail, but I have added a log anyway.", "author": "stefanroellin", "createdAt": "2020-07-10T18:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768325", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new IllegalArgumentException(\"Actions is not an instance of EcobeeActions\");\n          \n          \n            \n                    throw new IllegalArgumentException(\"Actions is not an instance of MPDActions\");", "author": "fwolter", "createdAt": "2020-07-18T08:57:44Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.action;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mpd.internal.handler.MPDHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link @MPDActions} defines rule actions for the Music Player Daemon binding. *\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@ThingActionsScope(name = \"mpd\")\n+@NonNullByDefault\n+public class MPDActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDActions.class);\n+\n+    private @Nullable MPDHandler handler = null;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof MPDHandler) {\n+            this.handler = (MPDHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command,\n+            @ActionInput(name = \"parameter\") @Nullable String parameter) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        MPDHandler handler = this.handler;\n+        if (handler != null) {\n+            handler.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        MPDHandler handler = this.handler;\n+        if (handler != null) {\n+            handler.sendCommand(command);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    private static MPDActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(MPDActions.class.getName())) {\n+            if (actions instanceof MPDActions) {\n+                return (MPDActions) actions;\n+            } else {\n+                return (MPDActions) Proxy.newProxyInstance(MPDActions.class.getClassLoader(),\n+                        new Class[] { MPDActions.class }, (Object proxy, Method method, Object[] args) -> {\n+                            Method m = actions.getClass().getDeclaredMethod(method.getName(),\n+                                    method.getParameterTypes());\n+                            return m.invoke(actions, args);\n+                        });\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Actions is not an instance of EcobeeActions\");", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwNjIxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456806217", "bodyText": "Copy-Paste error. I also realized that my fix for bug openhab/openhab-core#1265 was not correct, which I have fixed now.", "author": "stefanroellin", "createdAt": "2020-07-18T16:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(2);\n          \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(3);", "author": "fwolter", "createdAt": "2020-07-18T08:58:29Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || host.isEmpty()) {\n+            return null;\n+        }\n+\n+        String uniquePropVal = String.format(\"%s-%d\", host, port);\n+\n+        final Map<String, Object> properties = new HashMap<>(2);", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODg0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768842", "bodyText": "You might want to add the timeout parameter to join() in case the thread blocks for some reason.", "author": "fwolter", "createdAt": "2020-07-18T09:03:27Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public MPDConnection(MPDEventListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * start the connection\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public void start(String address, Integer port, String password) {\n+        if (connectionThread == null) {\n+            connectionThread = new MPDConnectionThread(this, address, port, password);\n+            connectionThread.start();\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        final MPDConnectionThread connectionThread = this.connectionThread;\n+        if (connectionThread != null) {\n+            connectionThread.dispose();\n+            connectionThread.interrupt();\n+            try {\n+                connectionThread.join();", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768928", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2020-07-18T09:04:31Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456769129", "bodyText": "Named threads make debugging easier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n          \n          \n            \n                public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n          \n          \n            \n                    super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);", "author": "fwolter", "createdAt": "2020-07-18T09:06:56Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456769224", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } catch (IOException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            } catch (MPDException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n          \n          \n            \n                            }\n          \n          \n            \n                            } catch (IOException | MPDException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            }", "author": "fwolter", "createdAt": "2020-07-18T09:08:04Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwNDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456804566", "bodyText": "The first exception will update the thing status to ThingStatusDetail.COMMUNICATION_ERROR, whereas the second updates it to ThingStatusDetail.CONFIGURATION_ERROR\nTherefore, I would prefer not to combine those exceptions. Do you agree?", "author": "stefanroellin", "createdAt": "2020-07-18T16:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg3NDA0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456874046", "bodyText": "Sorry, I missed the fine difference.", "author": "fwolter", "createdAt": "2020-07-19T07:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNTUwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469115505", "bodyText": "nice!", "author": "martinvw", "createdAt": "2020-08-12T09:06:07Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        String uniquePropVal = String.format(\"%s-%d\", config.getIpAddress(), config.getPort());\n+        updateProperty(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNjUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469116530", "bodyText": "Remark: This method-name could be slightly confusing because this class also has updateStatus which updates the thing status.", "author": "martinvw", "createdAt": "2020-08-12T09:07:54Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        String uniquePropVal = String.format(\"%s-%d\", config.getIpAddress(), config.getPort());\n+        updateProperty(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateStatus = scheduler.schedule(this::doUpdateStatus, 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateStatus() {\n+        connection.updateStatus();\n+    }\n+\n+    private synchronized void scheduleUpdateCurrentSong() {\n+        logger.debug(\"scheduleUpdateCurrentSong\");\n+        ScheduledFuture<?> future = this.futureUpdateCurrentSong;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateCurrentSong = scheduler.schedule(this::doUpdateCurrentSong, 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateCurrentSong() {\n+        connection.updateCurrentSong();\n+    }\n+\n+    private void handlePlayerCommand(String channelId, Command command) {\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+                handleCommandControl(command);\n+                break;\n+            case CHANNEL_STOP:\n+                handleCommandStop(command);\n+                break;\n+            case CHANNEL_VOLUME:\n+                handleCommandVolume(command);\n+                break;\n+        }\n+    }\n+\n+    private void handleCommandControl(Command command) {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connection.play();\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connection.pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connection.playNext();\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connection.playPrevious();\n+            }\n+        } else {\n+            // Rewind and Fast Forward are currently not implemented by the binding\n+            logger.debug(\"Control command {} is not supported\", command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (command instanceof OnOffType) {\n+            if (command == OnOffType.ON) {\n+                connection.stop();\n+            } else if (command == OnOffType.OFF) {\n+                connection.play();\n+            }\n+        } else {\n+            logger.debug(\"Stop Command {} is not supported\", command);\n+            return;\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command) {\n+        int newValue = 0;\n+        if (command instanceof IncreaseDecreaseType) {\n+            if (command == IncreaseDecreaseType.INCREASE) {\n+                newValue = Math.min(100, volume + 1);\n+            } else if (command == IncreaseDecreaseType.DECREASE) {\n+                newValue = Math.max(0, volume - 1);\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (command == OnOffType.ON) {\n+                newValue = 100;\n+            } else if (command == OnOffType.OFF) {\n+                newValue = 0;\n+            }\n+        } else if (command instanceof DecimalType) {\n+            newValue = ((DecimalType) command).intValue();\n+        } else if (command instanceof PercentType) {\n+            newValue = ((PercentType) command).intValue();\n+        } else {\n+            logger.debug(\"Command {} is not supported to change volume\", command);\n+            return;\n+        }\n+\n+        connection.setVolume(newValue);\n+    }\n+\n+    private void updateChannel(String channelID, State state) {\n+        State previousState = stateMap.put(channelID, state);\n+        if (previousState == null || !previousState.equals(state)) {\n+            updateState(channelID, state);\n+        }\n+    }\n+\n+    @Override\n+    public void updateStatus(MPDStatus status) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzOTY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473239649", "bodyText": "I have renamed it to updateMPDStatus, as well as updateSong to updateMPDSong.", "author": "stefanroellin", "createdAt": "2020-08-19T18:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNzYzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469117636", "bodyText": "You could consider renaming e to ignore this makes the ignoring of the exception explicit and documented.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                    } catch (InterruptedException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:09:43Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExODIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469118205", "bodyText": "Both fields could be final, it makes it more explicit that this class is immutable and helps to guard that in the future.", "author": "martinvw", "createdAt": "2020-08-12T09:10:42Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for encapsulating an MPD command\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class MPDCommand {\n+\n+    private String command;", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExOTAwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469119001", "bodyText": "Consider marking this field final", "author": "martinvw", "createdAt": "2020-08-12T09:12:07Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private static final int DISPOSE_TIMEOUT_MS = 1000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExOTQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469119420", "bodyText": "Consider renaming to ignore\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                        } catch (InterruptedException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:12:48Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private static final int DISPOSE_TIMEOUT_MS = 1000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public MPDConnection(MPDEventListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * start the connection\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public void start(String address, Integer port, String password) {\n+        if (connectionThread == null) {\n+            connectionThread = new MPDConnectionThread(this, address, port, password);\n+            connectionThread.start();\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        final MPDConnectionThread connectionThread = this.connectionThread;\n+        if (connectionThread != null) {\n+            connectionThread.dispose();\n+            connectionThread.interrupt();\n+            try {\n+                connectionThread.join(DISPOSE_TIMEOUT_MS);\n+            } catch (InterruptedException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyMTAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469121027", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:15:25Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469125129", "bodyText": "It does not seem completely guaranteed to me that this is a configuration error, this could maybe just be a communication problem (daemon/host not running) however it is reported to the end-user as a configuration error with text \"could not connect\". Throwing it as an IOException could fix that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MPDException(\"could not connect\");\n          \n          \n            \n                        throw new IOException (\"Failed to connect to \" + this.address \":\" + this.port);", "author": "martinvw", "createdAt": "2020-08-12T09:22:25Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0MDQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473240477", "bodyText": "If the daemon or the host is not running, there is an IOException, when the socket is opened. Therefore I have left the MPDException, but I have changed the text.", "author": "stefanroellin", "createdAt": "2020-08-19T18:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNjExNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473936114", "bodyText": "\ud83d\udc4d", "author": "martinvw", "createdAt": "2020-08-20T12:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNzc2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469127769", "bodyText": "@Hilbrand recently suggested a more uniform naming of Threads, could you update the Thread-name, I'm really sorry that it conflicts a bit with @fwolter earlier comment:\n#8216", "author": "martinvw", "createdAt": "2020-08-12T09:26:51Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyODUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469128533", "bodyText": "Would it make sense to check to basic sanity of the configuration parameters before connecting? A malformed/empty host address or port is of course a configuration error.", "author": "martinvw", "createdAt": "2020-08-12T09:28:10Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0MDYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473240610", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-08-19T18:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyODUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyOTU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469129569", "bodyText": "This message is displayed to the end-user consider making it more user friendly for example by suggesting to validate the password.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new MPDException(\"could not authenticate\");\n          \n          \n            \n                            throw new MPDException(\"Could not authenticate, please validate your password\");", "author": "martinvw", "createdAt": "2020-08-12T09:29:55Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyOTc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469129774", "bodyText": "Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false. source: PMD", "author": "martinvw", "createdAt": "2020-08-12T09:30:15Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:30:39Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:30:51Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130784", "bodyText": "Do you really need to close all of them? Will closing some of them not take a long the rest. E.g closing both the reader and inputStreamReader is AFAIK not needed.\nA quick peak in the javadoc suggested that closing the socket will do all the work at one.", "author": "martinvw", "createdAt": "2020-08-12T09:32:01Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0NTcwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473245703", "bodyText": "I have realized that the writer (DataOutputStream) is not necessary, since one can use socket.getOutputStream() directly.\n@fwolter has suggested in #7870 (comment) to also close the InputStreamReader, which is in contrast to your suggestion. From the mentioned javadoc it is clear that the InputStream and the OutputStream will also be closed, when the socket is closed. I do not close these streams explicitly.\nHowever, I would at least close the BufferedReader. But it does not harm, if I also close the InputStreamReader. I prefer to close too much than too little. wdyt?", "author": "stefanroellin", "createdAt": "2020-08-19T18:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNzkwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473937904", "bodyText": "I'm okay with keeping it like this. But there is a reason they mention it. Sometimes closing twice could lead to errors/exceptions and when not explicitly documented I would rather not.", "author": "martinvw", "createdAt": "2020-08-20T12:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469132473", "bodyText": "asLine is now always performed consider depending on toString instead then the logging framework will only call to toString when the content is actually being logged. If you cannot you might consider wrapping it in logger.isTraceEnabled()", "author": "martinvw", "createdAt": "2020-08-12T09:34:46Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469132973", "bodyText": "This ends up in the UI if I read correctly what can the user do about this? Did it lose the connection. Please update the message.", "author": "martinvw", "createdAt": "2020-08-12T09:35:35Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());\n+        final DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            String line = command.asLine();\n+            byte[] bytes = line.getBytes(StandardCharsets.UTF_8);\n+            writer.write(bytes);\n+            writer.write('\\n');\n+        } else {\n+            throw new IOException(\"writer is null\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469134457", "bodyText": "Please validate other messages when. might end up in the UI because of the behaviour at https://github.com/openhab/openhab-addons/pull/7870/files#diff-eac6da5ab58546ad9466910baded0b5fR86", "author": "martinvw", "createdAt": "2020-08-12T09:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473939226", "bodyText": "Very minor:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MPDException(\"Invalid parameter port\");\n          \n          \n            \n                        throw new MPDException(\"Invalid port parameter\");\n          \n      \n    \n    \n  \n\nOtherwise, it might suggest that the parameter port is invalid and should not be supplied.", "author": "martinvw", "createdAt": "2020-08-20T12:41:28Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -147,38 +146,45 @@ private void sendNoIdleIfInIdle() {\n             try {\n                 sendCommand(new MPDCommand(\"noidle\"));\n             } catch (IOException e) {\n-                logger.debug(\"sendCommand(noidle) failed\");\n+                logger.debug(\"sendCommand(noidle) failed\", e);\n             }\n         }\n     }\n \n-    private void establishConnection() throws IOException, MPDException {\n+    private void establishConnection() throws UnknownHostException, IOException, MPDException {\n         openSocket();\n \n         MPDCommand currentCommand = new MPDCommand(\"connect\");\n         MPDResponse response = readResponse(currentCommand);\n \n         if (!response.isOk()) {\n-            throw new MPDException(\"could not connect\");\n+            throw new MPDException(\"Failed to connect to \" + this.address + \":\" + this.port);\n         }\n \n         if (!password.isEmpty()) {\n             currentCommand = new MPDCommand(\"password\", password);\n             sendCommand(currentCommand);\n             response = readResponse(currentCommand);\n             if (!response.isOk()) {\n-                throw new MPDException(\"could not authenticate\");\n+                throw new MPDException(\"Could not authenticate, please validate your password\");\n             }\n         }\n     }\n \n-    private void openSocket() throws IOException {\n+    private void openSocket() throws UnknownHostException, IOException, MPDException {\n         logger.debug(\"opening connection to {} port {}\", address, port);\n+\n+        if (address.isEmpty()) {\n+            throw new MPDException(\"Missing parameter ipAddress\");\n+        }\n+        if (port < 1 || port > 65335) {\n+            throw new MPDException(\"Invalid parameter port\");", "originalCommit": "7963e82e0e0ee8511713e62eb5783450349eb090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MTQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473941472", "bodyText": "@stefanroellin please let me know if you want to fix this tiny comment otherwise I'm fine merging as is, thanks for your work!", "author": "martinvw", "createdAt": "2020-08-20T12:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NTE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r474195175", "bodyText": "I will push a fix for it.", "author": "stefanroellin", "createdAt": "2020-08-20T18:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473940244", "bodyText": "It might make sense to fetch the socket.getOutputStream() here so that you don't have to fetch it twice or was there a specific reason to do it like this?", "author": "martinvw", "createdAt": "2020-08-20T12:43:21Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -223,40 +229,32 @@ private void closeSocket() {\n         if (inputStreamReader != null) {\n             try {\n                 inputStreamReader.close();\n-            } catch (IOException e) {\n+            } catch (IOException ignore) {\n             }\n             this.inputStreamReader = null;\n         }\n \n-        DataOutputStream writer = this.writer;\n-        if (writer != null) {\n-            try {\n-                writer.close();\n-            } catch (IOException e) {\n-            }\n-            this.writer = null;\n-        }\n-\n         Socket socket = this.socket;\n         if (socket != null) {\n             try {\n                 socket.close();\n-            } catch (IOException e) {\n+            } catch (IOException ignore) {\n             }\n             this.socket = null;\n         }\n     }\n \n     private void sendCommand(MPDCommand command) throws IOException {\n-        logger.trace(\"send command '{}'\", command.asLine());\n-        final DataOutputStream writer = this.writer;\n-        if (writer != null) {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"send command '{}'\", command.asLine());\n+        }\n+        final Socket socket = this.socket;", "originalCommit": "7963e82e0e0ee8511713e62eb5783450349eb090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473940831", "bodyText": "Or maybe socket can be nulled out and socket. getOutputStream not, sensible enough :-)", "author": "martinvw", "createdAt": "2020-08-20T12:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r474234978", "bodyText": "I thought of using a local variable for getOutputStream(), but I find the current code is easier to read and circumvents the problem you describe.", "author": "stefanroellin", "createdAt": "2020-08-20T19:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA=="}], "type": "inlineReview"}, {"oid": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "url": "https://github.com/openhab/openhab-addons/commit/cccf21d363f6f75e6115d92dbd03cdc227e1a329", "message": "[mpd]: Music Player Daemon initial contribution\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "309214dfa0796498ef8a11b827549d7bbeab24a3", "url": "https://github.com/openhab/openhab-addons/commit/309214dfa0796498ef8a11b827549d7bbeab24a3", "message": "[mpd]: increase version to 2.5.7-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "d0bcd9a6e3758c85df961f834b84ce95c2cf91d1", "url": "https://github.com/openhab/openhab-addons/commit/d0bcd9a6e3758c85df961f834b84ce95c2cf91d1", "message": "[mpd]: reduce number of requests at startup\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "url": "https://github.com/openhab/openhab-addons/commit/80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "message": "fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "d24cd4ce855321c69d347c9d1a1fbff6ce2e5388", "url": "https://github.com/openhab/openhab-addons/commit/d24cd4ce855321c69d347c9d1a1fbff6ce2e5388", "message": "fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "f90431733dca95340b791a4cf6c893d24bee9e91", "url": "https://github.com/openhab/openhab-addons/commit/f90431733dca95340b791a4cf6c893d24bee9e91", "message": "[mpd]: fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "0a85bbd6a3ee8a53156e8251efd06bf67bdfbda5", "url": "https://github.com/openhab/openhab-addons/commit/0a85bbd6a3ee8a53156e8251efd06bf67bdfbda5", "message": "[mpd]: increase version to 2.5.8-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "3a178c21ce913b0ce53656483a28a7d6a6f5be45", "url": "https://github.com/openhab/openhab-addons/commit/3a178c21ce913b0ce53656483a28a7d6a6f5be45", "message": "[mpd]: make exception text more understandable\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:29:34Z", "type": "commit"}, {"oid": "f320b217ef531c1d3a38452e93b12ff4c1205b74", "url": "https://github.com/openhab/openhab-addons/commit/f320b217ef531c1d3a38452e93b12ff4c1205b74", "message": "[mpd]: do not write password to log file\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T19:38:53Z", "type": "commit"}, {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6", "url": "https://github.com/openhab/openhab-addons/commit/b257f624d1319c3f8a9360b5353a34bde75514c6", "message": "[mpd]: set thing to offline, if there is a permission problem\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T19:39:37Z", "type": "commit"}, {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6", "url": "https://github.com/openhab/openhab-addons/commit/b257f624d1319c3f8a9360b5353a34bde75514c6", "message": "[mpd]: set thing to offline, if there is a permission problem\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T19:39:37Z", "type": "forcePushed"}]}