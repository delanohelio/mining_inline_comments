{"pr_number": 7371, "pr_title": "[monopriceaudio] Monoprice Whole House Amplifier Binding - initial contribution", "pr_createdAt": "2020-04-14T15:26:48Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7371", "timeline": [{"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-13T19:56:53Z", "type": "commit"}, {"oid": "bcb0a5701d08151c606b3a6bca2bd68741183040", "url": "https://github.com/openhab/openhab-addons/commit/bcb0a5701d08151c606b3a6bca2bd68741183040", "message": "MonopriceAudio Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-14T02:29:25Z", "type": "commit"}, {"oid": "2254bbe8e988dd6b130b00aef8225e3b79c7a94c", "url": "https://github.com/openhab/openhab-addons/commit/2254bbe8e988dd6b130b00aef8225e3b79c7a94c", "message": "fix documentation issues\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-14T15:10:55Z", "type": "commit"}, {"oid": "b13b1f303241948a7647014b7adc5a14ee35dc48", "url": "https://github.com/openhab/openhab-addons/commit/b13b1f303241948a7647014b7adc5a14ee35dc48", "message": "Add logic set offline status if the controller is not responding\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T18:37:15Z", "type": "commit"}, {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-19T18:41:08Z", "type": "commit"}, {"oid": "7cc33e62f6c1dab46457526dda876750ff613a1d", "url": "https://github.com/openhab/openhab-addons/commit/7cc33e62f6c1dab46457526dda876750ff613a1d", "message": "fix merge conflict in pom.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T18:44:19Z", "type": "commit"}, {"oid": "3f077b3e504cbe95b4b0b0676ed034b87476f25c", "url": "https://github.com/openhab/openhab-addons/commit/3f077b3e504cbe95b4b0b0676ed034b87476f25c", "message": "update pom version to 2.5.5\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T20:08:28Z", "type": "commit"}, {"oid": "546783b7ac100c45270e008dd7b55e0d5c781e37", "url": "https://github.com/openhab/openhab-addons/commit/546783b7ac100c45270e008dd7b55e0d5c781e37", "message": "Removed advanced from treble, bass and balance in channels.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-01T22:24:37Z", "type": "commit"}, {"oid": "8485fa9668467a03627b328488f892594e0ca8d3", "url": "https://github.com/openhab/openhab-addons/commit/8485fa9668467a03627b328488f892594e0ca8d3", "message": "Cleanup before review\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T16:09:05Z", "type": "commit"}, {"oid": "99430f8919968fda476e81cb27e1bd44b1a19752", "url": "https://github.com/openhab/openhab-addons/commit/99430f8919968fda476e81cb27e1bd44b1a19752", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-23T04:53:31Z", "type": "commit"}, {"oid": "399741ecdd8a650362929167b0227e70a9885b4c", "url": "https://github.com/openhab/openhab-addons/commit/399741ecdd8a650362929167b0227e70a9885b4c", "message": "refactored to minimize unnecessary channel updates\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-25T22:05:28Z", "type": "commit"}, {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-05-27T03:57:29Z", "type": "commit"}, {"oid": "7643886a75fe02b8479e92b71bc7f63a799739ae", "url": "https://github.com/openhab/openhab-addons/commit/7643886a75fe02b8479e92b71bc7f63a799739ae", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-05-27T04:27:37Z", "type": "commit"}, {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515", "url": "https://github.com/openhab/openhab-addons/commit/70cd561d206e45925692019f6199bcaa2a5d8515", "message": "more cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T05:03:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827287", "bodyText": "Is there a reason for Nullable?", "author": "fwolter", "createdAt": "2020-05-30T09:43:16Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+\n+    QUERY(\"?\"),\n+    BEGIN_CMD(\"<\"),\n+    END_CMD(\"\\r\"),\n+\n+    POWER_ON(\"PR01\"),\n+    POWER_OFF(\"PR00\"),\n+    SOURCE(\"CH\"),\n+    VOLUME(\"VO\"),\n+    MUTE_ON(\"MU01\"),\n+    MUTE_OFF(\"MU00\"),\n+    TREBLE(\"TR\"),\n+    BASS(\"BS\"),\n+    BALANCE(\"BL\"),\n+    DND_ON(\"DT01\"),\n+    DND_OFF(\"DT00\");\n+\n+    private @Nullable String value;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNzU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433007590", "bodyText": "NM, fixed.", "author": "mlobstein", "createdAt": "2020-06-01T01:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827513", "bodyText": "What is expected to throw a InterruptedIOException?", "author": "fwolter", "createdAt": "2020-05-30T09:47:02Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNzk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433007978", "bodyText": "Not sure, it was there in rotel.", "author": "mlobstein", "createdAt": "2020-06-01T01:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwNTgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433405814", "bodyText": "Since it is a checked exception, you can remove the declaration without any risk.", "author": "fwolter", "createdAt": "2020-06-01T18:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433454204", "bodyText": "removed", "author": "mlobstein", "createdAt": "2020-06-01T19:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827582", "bodyText": "This exception is logged here and in MonopriceAudioReaderThread.", "author": "fwolter", "createdAt": "2020-05-30T09:48:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwOTA3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433009072", "bodyText": "removed.", "author": "mlobstein", "createdAt": "2020-06-01T01:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    byte[] message = new byte[0];\n          \n          \n            \n                    byte[] message;", "author": "fwolter", "createdAt": "2020-05-30T09:51:36Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827974", "bodyText": "Is this message necessary? The content is logged again below.", "author": "fwolter", "createdAt": "2020-05-30T09:54:38Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxMDA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433010093", "bodyText": "I removed one.", "author": "mlobstein", "createdAt": "2020-06-01T01:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828167", "bodyText": "If you log exceptions where they are eventually catched, you don't have to take care if the same error is logged multiple times. This exception is logged here and at least at MonopriceAudioHandler:400.", "author": "fwolter", "createdAt": "2020-05-30T09:57:22Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAzNjExOA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433036118", "bodyText": "yeah I see now rotel was very verbose in this regard.", "author": "mlobstein", "createdAt": "2020-06-01T04:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828280", "bodyText": "Better specify the encoding you expect.", "author": "fwolter", "createdAt": "2020-05-30T09:59:23Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODU3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828578", "bodyText": "It's bad practice to catch unchecked exceptions. Can you evaluate the return value of find()?", "author": "fwolter", "createdAt": "2020-05-30T10:03:18Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (READ_ERROR.equals(message)) {\n+            dispatchKeyValue(KEY_ERROR, MSG_VALUE_ON);\n+            return;\n+        }\n+\n+        // Amp controller sends status string: #>1200010000130809100601\n+        Pattern p = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+        try {\n+            Matcher matcher = p.matcher(message);\n+            matcher.find();\n+            // pull out just the digits and send them as an event\n+            dispatchKeyValue(KEY_ZONE_UPDATE, matcher.group(1));\n+        } catch (IllegalStateException e) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxMjY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433012640", "bodyText": "I will fix all of these!", "author": "mlobstein", "createdAt": "2020-06-01T01:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828694", "bodyText": "Syntactical sugar:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        listeners.get(i).onNewMessageEvent(event);\n          \n          \n            \n                    }\n          \n          \n            \n                    listeners.forEach(l -> l.onNewMessageEvent(event));", "author": "fwolter", "createdAt": "2020-05-30T10:05:23Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (READ_ERROR.equals(message)) {\n+            dispatchKeyValue(KEY_ERROR, MSG_VALUE_ON);\n+            return;\n+        }\n+\n+        // Amp controller sends status string: #>1200010000130809100601\n+        Pattern p = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+        try {\n+            Matcher matcher = p.matcher(message);\n+            matcher.find();\n+            // pull out just the digits and send them as an event\n+            dispatchKeyValue(KEY_ZONE_UPDATE, matcher.group(1));\n+        } catch (IllegalStateException e) {\n+            logger.debug(\"no match on message: {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Dispatch an event (key, value) to the event listeners\n+     *\n+     * @param key the key\n+     * @param value the value\n+     */\n+    private void dispatchKeyValue(String key, String value) {\n+        MonopriceAudioMessageEvent event = new MonopriceAudioMessageEvent(this, key, value);\n+        for (int i = 0; i < listeners.size(); i++) {\n+            listeners.get(i).onNewMessageEvent(event);\n+        }", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829087", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T10:11:41Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(String address, Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.clientSocket = clientSocket;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"IP connection opened\");\n+        } catch (IOException | SecurityException | IllegalArgumentException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening IP connection failed: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NTY4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433455688", "bodyText": "should be good now", "author": "mlobstein", "createdAt": "2020-06-01T19:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829259", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T10:14:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(String address, Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.clientSocket = clientSocket;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"IP connection opened\");\n+        } catch (IOException | SecurityException | IllegalArgumentException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening IP connection failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"Opening IP connection failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+        logger.debug(\"Closing IP connection\");\n+        super.cleanup();\n+        Socket clientSocket = this.clientSocket;\n+        if (clientSocket != null) {\n+            try {\n+                clientSocket.close();\n+            } catch (IOException e) {\n+            }\n+            this.clientSocket = null;\n+        }\n+        setConnected(false);\n+        logger.debug(\"IP connection closed\");\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     * In case of socket timeout, the returned value is 0.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    @Override\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (SocketTimeoutException e) {\n+            return 0;\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTkzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829937", "bodyText": "This could be made a static field.", "author": "fwolter", "createdAt": "2020-05-30T10:24:41Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.InterruptedIOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Data listener started\");\n+\n+        final int size = 64;\n+        byte[] readDataBuffer = new byte[READ_BUFFER_SIZE];\n+        byte[] dataBuffer = new byte[size];\n+        int index = 0;\n+        final char terminatingChar = '\\r';", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830027", "bodyText": "This could be made a static field.", "author": "fwolter", "createdAt": "2020-05-30T10:25:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.InterruptedIOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Data listener started\");\n+\n+        final int size = 64;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830296", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T10:30:18Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjA5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433456091", "bodyText": "fixed.", "author": "mlobstein", "createdAt": "2020-06-01T19:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830394", "bodyText": "See above (each catch)", "author": "fwolter", "createdAt": "2020-05-30T10:31:34Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);\n+                throw new MonopriceAudioException(\"Opening serial connection failed: No Such Port\");\n+            }\n+\n+            SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000);\n+\n+            commPort.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(100);\n+            commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\n+\n+            InputStream dataIn = commPort.getInputStream();\n+            OutputStream dataOut = commPort.getOutputStream();\n+\n+            if (dataOut != null) {\n+                dataOut.flush();\n+            }\n+            if (dataIn != null && dataIn.markSupported()) {\n+                try {\n+                    dataIn.reset();\n+                } catch (IOException e) {\n+                }\n+            }\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.serialPort = commPort;\n+            this.dataIn = dataIn;\n+            this.dataOut = dataOut;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"Serial connection opened\");\n+        } catch (PortInUseException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening serial connection failed: Port in Use Exception: {}\", e.getMessage(), e);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433456236", "bodyText": "yep done.", "author": "mlobstein", "createdAt": "2020-06-01T19:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830984", "bodyText": "You could use valueOf() to get rid of the Maps in the MonopriceAudioZone Enum.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n          \n          \n            \n                                                        connector.sendCommand(MonopriceAudioZone.valueOf(\"ZONE\" + zoneId),", "author": "fwolter", "createdAt": "2020-05-30T10:40:46Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNTMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433015324", "bodyText": "That is a great idea. ZONE_MAP removed!", "author": "mlobstein", "createdAt": "2020-06-01T02:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832025", "bodyText": "Can you make these Nullable? You could combine the config validation in the handler with the != null checks to not blowing up your code.", "author": "fwolter", "createdAt": "2020-05-30T10:58:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+\n+    public @NonNullByDefault({}) Integer numZones;\n+    public @NonNullByDefault({}) Integer pollingInterval;\n+    public @NonNullByDefault({}) String serialPort;\n+    public @NonNullByDefault({}) String host;\n+    public @NonNullByDefault({}) Integer port;\n+    public @NonNullByDefault({}) String ignoreZones;\n+    public @NonNullByDefault({}) Integer initialAllVolume;\n+    public @NonNullByDefault({}) String inputLabel1;\n+    public @NonNullByDefault({}) String inputLabel2;\n+    public @NonNullByDefault({}) String inputLabel3;\n+    public @NonNullByDefault({}) String inputLabel4;\n+    public @NonNullByDefault({}) String inputLabel5;\n+    public @NonNullByDefault({}) String inputLabel6;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832104", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<String>();\n          \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<>();", "author": "fwolter", "createdAt": "2020-05-30T10:59:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjE4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832186", "bodyText": "Better use primitive types where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Long lastPollingUpdate = System.currentTimeMillis();\n          \n          \n            \n                private long lastPollingUpdate = System.currentTimeMillis();", "author": "fwolter", "createdAt": "2020-05-30T11:00:56Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832231", "bodyText": "Can this message be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T11:02:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNjc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433016753", "bodyText": "removed", "author": "mlobstein", "createdAt": "2020-06-01T02:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjYzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832630", "bodyText": "You could have had some fun with streams here. Next time...", "author": "fwolter", "createdAt": "2020-05-30T11:09:29Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832911", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n          \n          \n            \n                                    ZONE + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);", "author": "fwolter", "createdAt": "2020-05-30T11:13:57Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n          \n          \n            \n                                if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)))) {", "author": "fwolter", "createdAt": "2020-05-30T11:16:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833188", "bodyText": "Can these log messages be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T11:18:07Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433017845", "bodyText": "ok", "author": "mlobstein", "createdAt": "2020-06-01T02:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833239", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:19:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833504", "bodyText": "There are lots of NonNull warnings for connector. You can reference connector with a local variable and check it for nullness. Then, these warnings will disappear.", "author": "fwolter", "createdAt": "2020-05-30T11:22:35Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r434129340", "bodyText": "Why not just null check connector directly in a few strategic places?\nIn the code above it would look like this:\nif (connector !=null && !connector.isConnected()) {....", "author": "mlobstein", "createdAt": "2020-06-02T19:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MjAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r434192022", "bodyText": "This code won't be thread-safe. connector could be set to null between the null check and invocation of isConnected(). The compiler would still complain.", "author": "fwolter", "createdAt": "2020-06-02T21:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3ODM5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r434878399", "bodyText": "In the rotel binding (which this is based off of), they leave the connector variable as non-nullable and then new up the connector with a 'simulated' Impl class when the handler class is instantiated (thus is has a default value and is never null). Then they re-assign it to the desired real Impl (Serial, IP, etc.) during initialize(). Would that be acceptable here?", "author": "mlobstein", "createdAt": "2020-06-03T21:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzOTc3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435439779", "bodyText": "I like this approach with simple classes like ScheduledFutures. Be careful when using it with more complex ones when it comes to returning processing results of 'simulated' implementations when actually no processing has have happened.", "author": "fwolter", "createdAt": "2020-06-04T17:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435569465", "bodyText": "@fwolter... The PR is ready for another look. I cleared up almost all of the warnings. There are a few pesky ones with the config that remain even though config is a local variable that can't be null and the fields are null checked explicitly :(", "author": "mlobstein", "createdAt": "2020-06-04T21:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833588", "bodyText": "Better use primitives int.", "author": "fwolter", "createdAt": "2020-05-30T11:24:02Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzY5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833699", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:25:27Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzcyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833721", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:25:42Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzc2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833763", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:26:14Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833951", "bodyText": "30ms are not enough to guarentee that the JVM will execute the following code in a different time slice, hence the sleep could be ignored. You should be safe with 100ms.", "author": "fwolter", "createdAt": "2020-05-30T11:29:57Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834122", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T11:32:30Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834154", "bodyText": "See above. Please check the other occurrences down below.", "author": "fwolter", "createdAt": "2020-05-30T11:32:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxOTAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433019026", "bodyText": "got it", "author": "mlobstein", "createdAt": "2020-06-01T02:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834170", "bodyText": "See above. Please check the other occurrences down below.", "author": "fwolter", "createdAt": "2020-05-30T11:33:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834419", "bodyText": "Can this be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T11:37:54Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834490", "bodyText": "Should this be warn or can be completly removed?", "author": "fwolter", "createdAt": "2020-05-30T11:39:12Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834501", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T11:39:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834525", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:39:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433020195", "bodyText": "NM", "author": "mlobstein", "createdAt": "2020-06-01T02:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834650", "bodyText": "You can use == when using primitive types. Would < or > be more adequate here?", "author": "fwolter", "createdAt": "2020-05-30T11:41:42Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDI4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433020286", "bodyText": "I suppose so", "author": "mlobstein", "createdAt": "2020-06-01T02:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834748", "bodyText": "No harm in cancelling an already canceled job.", "author": "fwolter", "createdAt": "2020-05-30T11:43:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834790", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:43:44Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834793", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:43:49Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834817", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:44:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835148", "bodyText": "You could make that a static field to save resources.", "author": "fwolter", "createdAt": "2020-05-30T11:48:58Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneData zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = new DecimalType(zoneData.isPageActive() ? 1 : 0);\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = new DecimalType(zoneData.isKeypadActive() ? 1 : 0);\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneData zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601\n+            Pattern p = Pattern.compile(\n+                    \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835173", "bodyText": "Better evaluate the return value of find(), instead of catching the unchecked exception.", "author": "fwolter", "createdAt": "2020-05-30T11:49:26Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneData zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = new DecimalType(zoneData.isPageActive() ? 1 : 0);\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = new DecimalType(zoneData.isKeypadActive() ? 1 : 0);\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneData zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601\n+            Pattern p = Pattern.compile(\n+                    \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+            try {\n+                Matcher matcher = p.matcher(newZoneData);\n+                matcher.find();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835625", "bodyText": "You should handle the case, the user enters an invalid zone number. E.g. check for get() returning null or make the generic type of ignoreZones Nullable.", "author": "fwolter", "createdAt": "2020-05-30T11:56:19Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDMyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433024320", "bodyText": "got catch, can't trust the user here!", "author": "mlobstein", "createdAt": "2020-06-01T03:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTYyNQ=="}], "type": "inlineReview"}, {"oid": "2f59993883de521456437c5b3471a0bb4844169e", "url": "https://github.com/openhab/openhab-addons/commit/2f59993883de521456437c5b3471a0bb4844169e", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T04:31:32Z", "type": "commit"}, {"oid": "646c6f39247be8ce22cf96ae97b863f3a1f72bc8", "url": "https://github.com/openhab/openhab-addons/commit/646c6f39247be8ce22cf96ae97b863f3a1f72bc8", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T05:20:31Z", "type": "commit"}, {"oid": "a9d29a8ea5ab145757680c602e69f784d66e52e3", "url": "https://github.com/openhab/openhab-addons/commit/a9d29a8ea5ab145757680c602e69f784d66e52e3", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T05:28:52Z", "type": "commit"}, {"oid": "16a523a0de2ce99db1a460a000bfdb0b1af2259c", "url": "https://github.com/openhab/openhab-addons/commit/16a523a0de2ce99db1a460a000bfdb0b1af2259c", "message": "implement code review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T18:05:10Z", "type": "commit"}, {"oid": "d7c5ee5eb1e4a3bf8f23533fc5b372268697b8bf", "url": "https://github.com/openhab/openhab-addons/commit/d7c5ee5eb1e4a3bf8f23533fc5b372268697b8bf", "message": "Removed InterruptedIOException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T20:00:47Z", "type": "commit"}, {"oid": "db01c93a26ef33d48f2827a7f313f87c35d55017", "url": "https://github.com/openhab/openhab-addons/commit/db01c93a26ef33d48f2827a7f313f87c35d55017", "message": "Use Contact instead of Number\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T21:31:09Z", "type": "commit"}, {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-04T21:19:29Z", "type": "commit"}, {"oid": "c677c0596be4b15330ed2f20c98e1a98a90a906a", "url": "https://github.com/openhab/openhab-addons/commit/c677c0596be4b15330ed2f20c98e1a98a90a906a", "message": "changes to fix null pointer warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-04T21:20:39Z", "type": "commit"}, {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "url": "https://github.com/openhab/openhab-addons/commit/a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "message": "fix CODEOWNERS conflicts\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-04T21:23:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5ODgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435998805", "bodyText": "Use named threads.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;", "author": "fwolter", "createdAt": "2020-06-05T15:31:09Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMzIyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436003223", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final ArrayList<String> VALID_ZONES = new ArrayList<String>(\n          \n          \n            \n                        Arrays.asList(ZONE1.getZoneId(), ZONE2.getZoneId(), ZONE3.getZoneId(), ZONE4.getZoneId(), ZONE5.getZoneId(),\n          \n          \n            \n                                ZONE6.getZoneId(), ZONE7.getZoneId(), ZONE8.getZoneId(), ZONE9.getZoneId(), ZONE10.getZoneId(),\n          \n          \n            \n                                ZONE11.getZoneId(), ZONE12.getZoneId(), ZONE13.getZoneId(), ZONE14.getZoneId(), ZONE15.getZoneId(),\n          \n          \n            \n                                ZONE16.getZoneId(), ZONE17.getZoneId(), ZONE18.getZoneId()));\n          \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.getZoneId())\n          \n          \n            \n                        .collect(Collectors.toList());", "author": "fwolter", "createdAt": "2020-06-05T15:37:34Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone ids\n+    public static final ArrayList<String> VALID_ZONES = new ArrayList<String>(\n+            Arrays.asList(ZONE1.getZoneId(), ZONE2.getZoneId(), ZONE3.getZoneId(), ZONE4.getZoneId(), ZONE5.getZoneId(),\n+                    ZONE6.getZoneId(), ZONE7.getZoneId(), ZONE8.getZoneId(), ZONE9.getZoneId(), ZONE10.getZoneId(),\n+                    ZONE11.getZoneId(), ZONE12.getZoneId(), ZONE13.getZoneId(), ZONE14.getZoneId(), ZONE15.getZoneId(),\n+                    ZONE16.getZoneId(), ZONE17.getZoneId(), ZONE18.getZoneId()));", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2MTg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436161891", "bodyText": "nice!", "author": "mlobstein", "createdAt": "2020-06-05T20:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436006183", "bodyText": "Why is the null annotation disabled?", "author": "fwolter", "createdAt": "2020-06-05T15:42:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+    public Integer numZones = 1;\n+    public Integer pollingInterval = 15;\n+    public @NonNullByDefault({}) String serialPort;", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1ODM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436158346", "bodyText": "Because SerialPortManager.getIdentifier(String name) takes a NonNullByDefault argument.", "author": "mlobstein", "createdAt": "2020-06-05T20:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzMwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857301", "bodyText": "You already do all null checks to be able to make this Nullable. Why not go for it?", "author": "fwolter", "createdAt": "2020-06-14T18:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436006543", "bodyText": "Can be removed", "author": "fwolter", "createdAt": "2020-06-05T15:43:17Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.dto;\n+\n+/**\n+ * Represents the data elements of a single zone of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class MonopriceAudioZoneDTO {\n+\n+    private String zone;\n+    private String page;\n+    private String power;\n+    private String mute;\n+    private String dnd;\n+    private String volume;\n+    private String treble;\n+    private String bass;\n+    private String balance;\n+    private String source;\n+    private String keypad;\n+\n+    public MonopriceAudioZoneDTO() {\n+    }", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNzY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436007684", "bodyText": "You could replace this by a stream operation, too. See above.", "author": "fwolter", "createdAt": "2020-06-05T15:45:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2MjE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436162188", "bodyText": "done.", "author": "mlobstein", "createdAt": "2020-06-05T21:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwODk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436008952", "bodyText": "Since there shouldn't be any concurrency issues with the configuration, you could annotate this method with @SuppressWarnings(\"null\"), to prevent the compiler warnings.", "author": "fwolter", "createdAt": "2020-06-05T15:47:36Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzg5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857890", "bodyText": "When I read this again, I think other reviewers won't be happy about this. You could initialize the config parameters with default values in your configuration class, to be able to remove the Nullables from the fields. Then, this suppression isn't necessary at all.", "author": "fwolter", "createdAt": "2020-06-14T18:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwODk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwOTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436009502", "bodyText": "These comments have no benefit and can be removed.", "author": "fwolter", "createdAt": "2020-06-05T15:48:30Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMTgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436011830", "bodyText": "You might want to log a warning or throw an exception if the zone is out of range.", "author": "fwolter", "createdAt": "2020-06-05T15:52:37Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2Mzg4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436163883", "bodyText": "A warning will be enough I think.", "author": "mlobstein", "createdAt": "2020-06-05T21:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMTgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMzEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436013101", "bodyText": "The method of the base class has no implementation, therefore this could be remoeved.", "author": "fwolter", "createdAt": "2020-06-05T15:54:48Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436018990", "bodyText": "A timeout of 150ms seem a bit short. Are you sure is is enough under all circumstances?", "author": "fwolter", "createdAt": "2020-06-05T16:05:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.valueOf(ZONE + zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2ODc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436168764", "bodyText": "Yes 150 should be more than enough here. Actually I will change it to use the constant.", "author": "mlobstein", "createdAt": "2020-06-05T21:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDQyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436024429", "bodyText": "Are you sure this synchronization is sufficent? If I see correctly scheduleReconnectJob() can be called from different threads. openConnection() itself is synchronized but what if multiple threads call it one after another at this location? Should the sequenceLock monitor start at the beginning of this scheduler job? Same for the polling job.", "author": "fwolter", "createdAt": "2020-06-05T16:15:04Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.valueOf(ZONE + zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDE5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436170199", "bodyText": "I will change both to be sure.", "author": "mlobstein", "createdAt": "2020-06-05T21:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDQyOQ=="}], "type": "inlineReview"}, {"oid": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "url": "https://github.com/openhab/openhab-addons/commit/2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-05T21:38:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MzczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436253735", "bodyText": "One compiler warning left.", "author": "fwolter", "createdAt": "2020-06-06T09:23:44Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private @Nullable String address;\n+    private @Nullable Integer port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(@Nullable String address, @Nullable Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);", "originalCommit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r437108768", "bodyText": "fixed.", "author": "mlobstein", "createdAt": "2020-06-09T02:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MzczNQ=="}], "type": "inlineReview"}, {"oid": "62e417b47937cdba6807f3e58194132edc4b3a92", "url": "https://github.com/openhab/openhab-addons/commit/62e417b47937cdba6807f3e58194132edc4b3a92", "message": "fix compilier warning\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-09T02:50:52Z", "type": "commit"}, {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "url": "https://github.com/openhab/openhab-addons/commit/f763e8586c14bb653986e8468b816a61a3f3a1a6", "message": "fix sychronized placement around openConnection()\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-10T20:46:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439855846", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));\n          \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);", "author": "fwolter", "createdAt": "2020-06-14T18:28:10Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NjA5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439856095", "bodyText": "You could put the SerialPortManager as an argument here, too. Then, you can remove the @NonNullByDefault({}) from both fields.", "author": "fwolter", "createdAt": "2020-06-14T18:31:17Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    @Activate\n+    public MonopriceAudioHandlerFactory(final @Reference MonopriceAudioStateDescriptionOptionProvider provider) {", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NjQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439856450", "bodyText": "Isn't 00 appended if valueis 0?", "author": "fwolter", "createdAt": "2020-06-14T18:35:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message;\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzYyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n          \n          \n            \n                            ignore.forEach(zone -> {\n          \n          \n            \n                            Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {", "author": "fwolter", "createdAt": "2020-06-14T18:51:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857940", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n          \n          \n            \n                        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());", "author": "fwolter", "createdAt": "2020-06-14T18:55:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439858565", "bodyText": "Are you aware that multiple handleCommand()s can be invoked at the same time from different threads? This rate limit might not work, then.", "author": "fwolter", "createdAt": "2020-06-14T19:03:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzOTQzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439939434", "bodyText": "Yes but hopefully the All* commands will be used sparingly by the user. The idea is to give some advanced functionality to the user so they can affect all zones with one command and avoid having to write rules that loop over all zones. For example, the 'All Off' command can be triggered by a rule that runs when arming the security system to away mode to turn off the music when leaving. And the 'All Volume' & 'All Source' provide party mode functionality that is native to more advanced WHA systems. So ideally two different users would never be adjusting the All Volume at the same time.", "author": "mlobstein", "createdAt": "2020-06-15T05:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r440364860", "bodyText": "Ok, but then you can remove the second Thread.sleep() in every case, because they have no effect.", "author": "fwolter", "createdAt": "2020-06-15T18:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwMjI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441202296", "bodyText": "I removed all the sleeps and the device controller seems to be coping with this ok.", "author": "mlobstein", "createdAt": "2020-06-16T23:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ=="}], "type": "inlineReview"}, {"oid": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "url": "https://github.com/openhab/openhab-addons/commit/e09ceb96d7b73cffdaf3a77707711cd741719f88", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-15T05:40:02Z", "type": "commit"}, {"oid": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "url": "https://github.com/openhab/openhab-addons/commit/0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "message": "remove sleep and fix a few bugs\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-16T23:44:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441680116", "bodyText": "The code begs for streams :) If you like, try findAny().orElseThrow(...", "author": "fwolter", "createdAt": "2020-06-17T16:39:25Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -48,10 +49,23 @@\n \n     private String zoneId;\n \n-    // make a list of all valid zone ids\n-    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.getZoneId())\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n             .collect(Collectors.toList());\n \n+    // make a list of all valid zone ids\n+    public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(z -> z.getZoneId()).collect(Collectors.toList());\n+\n+    public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n+        for (MonopriceAudioZone z : MonopriceAudioZone.values()) {\n+            if (z.zoneId.equalsIgnoreCase(zoneId)) {\n+                return z;\n+            }\n+        }\n+        throw new MonopriceAudioException(\"Invalid zoneId specified: \" + zoneId);", "originalCommit": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441796220", "bodyText": "got it!", "author": "mlobstein", "createdAt": "2020-06-17T19:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441680870", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        ignoreZones.add(ZONE + String.valueOf(zoneInt));\n          \n          \n            \n                                        ignoreZones.add(ZONE + zoneInt);", "author": "fwolter", "createdAt": "2020-06-17T16:40:31Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -164,7 +163,7 @@ public void initialize() {\n                     try {\n                         int zoneInt = Integer.parseInt(zone);\n                         if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n-                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                            ignoreZones.add(ZONE + String.valueOf(zoneInt));", "originalCommit": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NTk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441795958", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-06-17T19:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDg3MA=="}], "type": "inlineReview"}, {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40", "url": "https://github.com/openhab/openhab-addons/commit/e0e166958454b6492345b317ee9ec96ef70a7a40", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-17T19:51:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2OTU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441869565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n            \n          \n          \n            \n                private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n          \n          \n            \n                private final SerialPortManager serialPortManager;\n          \n          \n            \n            \n          \n          \n            \n                private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;", "author": "cpmeister", "createdAt": "2020-06-17T22:31:33Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441871310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Opening serial connection on port {}\", serialPortName);\n          \n          \n            \n                    logger.debug(\"Opening serial connection on port {}\", serialPortName);", "author": "cpmeister", "createdAt": "2020-06-17T22:36:37Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441874713", "bodyText": "What if the user has multiple amplifiers?\nThis map shouldn't be static. Please make the name lowercase accordingly as well.", "author": "cpmeister", "createdAt": "2020-06-17T22:47:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNTg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441915881", "bodyText": "Up to three can be connected together as one unit and accordingly up to 18 zones can be specified in the configuration. If they have more than 18 zones, they can always add another thing instance.", "author": "mlobstein", "createdAt": "2020-06-18T01:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NTUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442595538", "bodyText": "If they add another thing instance then its handler would still be using this same static map. It should be a single map per handler right?", "author": "cpmeister", "createdAt": "2020-06-19T02:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNDQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442604417", "bodyText": "If they add another thing instance then its handler would still be using this same static map. It should be a single map per handler right?\n\nYeah, each instance of the handler should have its own map so I will remove static, but it can still be final.", "author": "mlobstein", "createdAt": "2020-06-19T02:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTc5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441875795", "bodyText": "Just return early here so you can get rid of the \"else\" statement and indentations.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-06-17T22:51:14Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NjAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441876026", "bodyText": "Please remove this.", "author": "cpmeister", "createdAt": "2020-06-17T22:51:59Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3ODQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441878438", "bodyText": "The main benefit of streams and lambdas is how concise they can make code. But sometimes they aren't as concise as a regular loop...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n          \n          \n            \n                            for (String zone : config.ignoreZones.split(\",\")) {", "author": "cpmeister", "createdAt": "2020-06-17T22:59:35Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4MDc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441880770", "bodyText": "Might as well save later code from having to call it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n          \n          \n            \n                        Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);", "author": "cpmeister", "createdAt": "2020-06-17T23:07:18Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NDU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441884596", "bodyText": "I feel like all these on/off command handlers could be simplified to a single function.\nprivate void handleOnOff(Command command, MonopriceAudioZone zone, MonopriceAudioCommand onCommand, MonopriceAudioCommand offCommand, BiConsumer<MonopriceAudioZoneDTO, String> adjuster){\n    if( command == OnOffType.ON){\n        connector.sendCommand(zone, onCommand);\n        adjuster.accept(ZONE_DATA_MAP.get(zone.getZoneId()), ON);\n    } else if (command == OnOffType.OFF){\n        connector.sendCommand(zone, offCommand);\n        adjuster.accept(ZONE_DATA_MAP.get(zone.getZoneId()), OFF);\n    }\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (command instanceof OnOffType && command == OnOffType.ON) {\n          \n          \n            \n                                        connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n          \n          \n            \n                                        ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n          \n          \n            \n                                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n          \n          \n            \n                                        connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n          \n          \n            \n                                        ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    handleOnOff(command, zone, MonopriceAudioCommand.MUTE_ON, MonopriceAudioCommand.MUTE_OFF, MonopriceAudioZone::setMute);", "author": "cpmeister", "createdAt": "2020-06-17T23:19:48Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MzIwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445263206", "bodyText": "I condensed them all with a ternary.", "author": "mlobstein", "createdAt": "2020-06-25T01:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441887496", "bodyText": "might as well break early instead of having to perform another null check.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cmd = null;\n          \n          \n            \n                                    }\n          \n          \n            \n            \n          \n          \n            \n                                    if (cmd != null) {\n          \n          \n            \n                                        break;\n          \n          \n            \n                                    }", "author": "cpmeister", "createdAt": "2020-06-17T23:29:10Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzU3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441887574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (command instanceof OnOffType && command == OnOffType.ON) {\n          \n          \n            \n                                        cmd = MonopriceAudioCommand.MUTE_ON;\n          \n          \n            \n                                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n          \n          \n            \n                                    if (command == OnOffType.ON) {\n          \n          \n            \n                                        cmd = MonopriceAudioCommand.MUTE_ON;\n          \n          \n            \n                                    } else if (command == OnOffType.OFF) {", "author": "cpmeister", "createdAt": "2020-06-17T23:29:28Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1ODM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441958348", "bodyText": "I made some changes. Please take another look.", "author": "mlobstein", "createdAt": "2020-06-18T04:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MDAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441890013", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event);\n          \n          \n            \n                public void onNewMessageEvent(MonopriceAudioMessageEvent event);", "author": "cpmeister", "createdAt": "2020-06-17T23:37:34Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * MonopriceAudio Event Listener interface. Handles incoming MonopriceAudio message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface MonopriceAudioMessageEventListener extends EventListener {\n+\n+    /**\n+     * Event handler method for incoming MonopriceAudio message events\n+     *\n+     * @param event the event object\n+     */\n+    public void onNewMessageEvent(EventObject event);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MTExMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441891112", "bodyText": "This is more of an external issue rather than one that a user can address, so just make this log debug instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Invalid zone update message: {}\", newZoneData);\n          \n          \n            \n                            logger.debug(\"Invalid zone update message: {}\", newZoneData);", "author": "cpmeister", "createdAt": "2020-06-17T23:41:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n+                        } catch (MonopriceAudioException e) {\n+                            logger.warn(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = zoneData.isPageActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = zoneData.isKeypadActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneDTO zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601, matcher pattern from above:\n+            // \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\"\n+            Matcher matcher = PATTERN.matcher(newZoneData);\n+            if (matcher.find()) {\n+                zoneData.setZone(matcher.group(1));\n+\n+                if (!matcher.group(2).equals(zoneData.getPage())) {\n+                    zoneData.setPage(matcher.group(2));\n+                    updateChannelState(zone, CHANNEL_TYPE_PAGE, zoneData);\n+                }\n+\n+                if (!matcher.group(3).equals(zoneData.getPower())) {\n+                    zoneData.setPower(matcher.group(3));\n+                    updateChannelState(zone, CHANNEL_TYPE_POWER, zoneData);\n+                }\n+\n+                if (!matcher.group(4).equals(zoneData.getMute())) {\n+                    zoneData.setMute(matcher.group(4));\n+                    updateChannelState(zone, CHANNEL_TYPE_MUTE, zoneData);\n+                }\n+\n+                if (!matcher.group(5).equals(zoneData.getDnd())) {\n+                    zoneData.setDnd(matcher.group(5));\n+                    updateChannelState(zone, CHANNEL_TYPE_DND, zoneData);\n+                }\n+\n+                if (!matcher.group(6).equals(zoneData.getVolume())) {\n+                    zoneData.setVolume(matcher.group(6));\n+                    updateChannelState(zone, CHANNEL_TYPE_VOLUME, zoneData);\n+                }\n+\n+                if (!matcher.group(7).equals(zoneData.getTreble())) {\n+                    zoneData.setTreble(matcher.group(7));\n+                    updateChannelState(zone, CHANNEL_TYPE_TREBLE, zoneData);\n+                }\n+\n+                if (!matcher.group(8).equals(zoneData.getBass())) {\n+                    zoneData.setBass(matcher.group(8));\n+                    updateChannelState(zone, CHANNEL_TYPE_BASS, zoneData);\n+                }\n+\n+                if (!matcher.group(9).equals(zoneData.getBalance())) {\n+                    zoneData.setBalance(matcher.group(9));\n+                    updateChannelState(zone, CHANNEL_TYPE_BALANCE, zoneData);\n+                }\n+\n+                if (!matcher.group(10).equals(zoneData.getSource())) {\n+                    zoneData.setSource(matcher.group(10));\n+                    updateChannelState(zone, CHANNEL_TYPE_SOURCE, zoneData);\n+                }\n+\n+                if (!matcher.group(11).equals(zoneData.getKeypad())) {\n+                    zoneData.setKeypad(matcher.group(11));\n+                    updateChannelState(zone, CHANNEL_TYPE_KEYPAD, zoneData);\n+                }\n+            } else {\n+                logger.warn(\"Invalid zone update message: {}\", newZoneData);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MTk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441891967", "bodyText": "The TimeUnit.SECONDS.toSeconds doesn't do anything here so you can omit it. If you are trying to make your assignment more declarative then I suggest you add a _SEC suffix to your constant name instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n          \n          \n            \n                private static final long RECON_POLLING_INTERVAL_SEC = 60;", "author": "cpmeister", "createdAt": "2020-06-17T23:44:15Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjAwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892000", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-06-17T23:44:22Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjIwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892201", "bodyText": "Since order doesn't matter and you are only performing lookups on it, use a Set instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<>();\n          \n          \n            \n                private final Set<String> ignoreZones = new HasSet<>();", "author": "cpmeister", "createdAt": "2020-06-17T23:45:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjI0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892245", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "author": "cpmeister", "createdAt": "2020-06-17T23:45:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5Mjk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892957", "bodyText": "You should also clear your ignoreZones here.", "author": "cpmeister", "createdAt": "2020-06-17T23:47:50Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MzA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441893040", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n          \n          \n            \n                        pollingInterval = config.pollingInterval;", "author": "cpmeister", "createdAt": "2020-06-17T23:48:07Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5Mzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441893773", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n          \n          \n            \n            \n          \n          \n            \n                                // poll each zone up to the number of zones specified in the configuration\n          \n          \n            \n                                zoneStream.limit(numZones).forEach((zoneName) -> {\n          \n          \n            \n                                // poll each zone up to the number of zones specified in the configuration\n          \n          \n            \n                                MonopriceAudioZone.VALID_ZONES.stream().limit(numZones).forEach((zoneName) -> {", "author": "cpmeister", "createdAt": "2020-06-17T23:50:57Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441894896", "bodyText": "Is there any change that zoneData.getTreble() wouldn't return a parsable number? If so then you should catch the exception, if not then I suggest changing the datatype from a String to an int.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n          \n          \n            \n                            state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));", "author": "cpmeister", "createdAt": "2020-06-17T23:54:54Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n+                        } catch (MonopriceAudioException e) {\n+                            logger.warn(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyNTc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441925772", "bodyText": "The regex ensures that only digits will make it into the dto. It just a question of whether to parse the string when going into the dto or coming out of the dto. I could overload the getters in the dto to parse/return an integer but that is just moving the ugliness somewhere else IMO.", "author": "mlobstein", "createdAt": "2020-06-18T01:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MjY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442442675", "bodyText": "Well it would be a better practice to make the DTO reflect the actual datatypes involved.", "author": "cpmeister", "createdAt": "2020-06-18T19:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng=="}], "type": "inlineReview"}, {"oid": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "url": "https://github.com/openhab/openhab-addons/commit/9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-18T04:12:41Z", "type": "commit"}, {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7", "url": "https://github.com/openhab/openhab-addons/commit/0d3e3569c0dd490c3db64e018e702235b09969c7", "message": "make ZONE_DATA_MAP not static\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-19T02:59:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MjMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442982330", "bodyText": "Why are BEGIN_CMD AND END_CMD in this list of enums? They are never used as discrete commands and are just used as part of command construction. I don't think they belong here.", "author": "cpmeister", "createdAt": "2020-06-19T18:14:04Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+    QUERY(\"?\"),\n+    BEGIN_CMD(\"<\"),\n+    END_CMD(\"\\r\"),", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442983126", "bodyText": "Make sure that any created threads are daemon.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                }\n          \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                    setDaemon(true);\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-19T18:15:56Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID);\n+        this.connector = connector;\n+    }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NDY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442984693", "bodyText": "Since more than one of these threads can exist, you want to make sure they don't have the same name. Add additional information to the name such as either the thingUID or the address this thread is reading from.", "author": "cpmeister", "createdAt": "2020-06-19T18:19:55Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID);", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442986175", "bodyText": "If the thread is in the middle of blocking for IO it may not respond to interrupt requests. To make sure that it is kicked awake you should make sure to close the input and output streams before you try joining the thread.", "author": "cpmeister", "createdAt": "2020-06-19T18:23:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MjE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r443092161", "bodyText": "I will move it.", "author": "mlobstein", "createdAt": "2020-06-20T02:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987086", "bodyText": "you should still log this exception", "author": "cpmeister", "createdAt": "2020-06-19T18:25:44Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987145", "bodyText": "this one too", "author": "cpmeister", "createdAt": "2020-06-19T18:25:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987496", "bodyText": "It is dangerous to wait indefinitely for the join, so add a reasonable timeout and log a warning if that timeout is exceeded.", "author": "cpmeister", "createdAt": "2020-06-19T18:26:48Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442988678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n          \n          \n            \n                private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n          \n      \n    \n    \n  \n\nAlso move this field above the non-final fields.", "author": "cpmeister", "createdAt": "2020-06-19T18:29:49Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MzQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445263498", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-06-25T01:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442988921", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashSet<String> ignoreZones = new HashSet<>();\n          \n          \n            \n                private Set<String> ignoreZones = new HashSet<>();", "author": "cpmeister", "createdAt": "2020-06-19T18:30:25Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442989671", "bodyText": "You should try to handle the RefreshType command for all of these channels.", "author": "cpmeister", "createdAt": "2020-06-19T18:32:19Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new MonopriceAudioIpConnector(config.host, config.port);\n+        }\n+\n+        pollingInterval = config.pollingInterval;\n+        numZones = config.numZones;\n+        initialAllVolume = config.initialAllVolume;\n+\n+        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+        // zone ids to get the controller's internal zone ids and save those to a list\n+        if (config.ignoreZones != null) {\n+            for (String zone : config.ignoreZones.split(\",\")) {\n+                try {\n+                    int zoneInt = Integer.parseInt(zone);\n+                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                        ignoreZones.add(ZONE + zoneInt);\n+                    } else {\n+                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                MAX_ZONES);\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                }\n+            }\n+        }\n+\n+        // Build a state option list for the source labels\n+        List<StateOption> sourcesLabels = new ArrayList<>();\n+        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+        // Put the source labels on all active zones\n+        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+        stateDescriptionProvider.setStateOptions(\n+                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+        activeZones.forEach(zoneNum -> {\n+            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+        });\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        // initialize the all volume state\n+        allVolume = initialAllVolume;\n+        long allVolumePct = Math\n+                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        ignoreZones.clear();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MTY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442991683", "bodyText": "If you can't query the channel data, then you should at least used cached values.", "author": "cpmeister", "createdAt": "2020-06-19T18:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5NDEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r443094102", "bodyText": "Done and pushed.", "author": "mlobstein", "createdAt": "2020-06-20T02:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MDEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442990109", "bodyText": "Success is expected, so I think you can change the logging level to trace.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n          \n          \n            \n                                logger.trace(\"Command {} from channel {} succeeded\", command, channel);", "author": "cpmeister", "createdAt": "2020-06-19T18:33:27Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new MonopriceAudioIpConnector(config.host, config.port);\n+        }\n+\n+        pollingInterval = config.pollingInterval;\n+        numZones = config.numZones;\n+        initialAllVolume = config.initialAllVolume;\n+\n+        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+        // zone ids to get the controller's internal zone ids and save those to a list\n+        if (config.ignoreZones != null) {\n+            for (String zone : config.ignoreZones.split(\",\")) {\n+                try {\n+                    int zoneInt = Integer.parseInt(zone);\n+                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                        ignoreZones.add(ZONE + zoneInt);\n+                    } else {\n+                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                MAX_ZONES);\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                }\n+            }\n+        }\n+\n+        // Build a state option list for the source labels\n+        List<StateOption> sourcesLabels = new ArrayList<>();\n+        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+        // Put the source labels on all active zones\n+        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+        stateDescriptionProvider.setStateOptions(\n+                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+        activeZones.forEach(zoneNum -> {\n+            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+        });\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        // initialize the all volume state\n+        allVolume = initialAllVolume;\n+        long allVolumePct = Math\n+                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        ignoreZones.clear();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        if (command instanceof OnOffType) {\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.POWER, 1);\n+                                        // reset the volume of each zone to allVolume\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, allVolume);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                    }\n+                                }\n+\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        if (command instanceof OnOffType) {\n+                            // set allVolume back to initial volume\n+                            allVolume = initialAllVolume;\n+                            long allVolumePct = Math.round(\n+                                    (double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                            zoneStream.forEach((zoneName) -> {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER, 0);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                                }\n+\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        if (command instanceof OnOffType) {\n+                            int cmd = command == OnOffType.ON ? 1 : 0;\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.MUTE, cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "url": "https://github.com/openhab/openhab-addons/commit/592e16adf7d9cb184385738bae937c6ad6ecdaf0", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-20T02:36:29Z", "type": "commit"}, {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-24T13:47:17Z", "type": "commit"}, {"oid": "3aa4b61b3250c1c64d6f3eac110c3e1ccbe8fb2d", "url": "https://github.com/openhab/openhab-addons/commit/3aa4b61b3250c1c64d6f3eac110c3e1ccbe8fb2d", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-06-24T14:12:08Z", "type": "commit"}, {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "url": "https://github.com/openhab/openhab-addons/commit/fd64d16a198b55e5c4792b8c88394ded00eeb042", "message": "Update pom version and format README\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-24T14:23:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188024", "bodyText": "You should include the cause exception in your MonopriceAudioException.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n          \n          \n            \n                        throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-06-24T21:41:43Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());", "originalCommit": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MzgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445263819", "bodyText": "done for all", "author": "mlobstein", "createdAt": "2020-06-25T01:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODE2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n          \n          \n            \n                        throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-06-24T21:42:00Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = \"\";\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            messageStr = BEGIN_CMD + zone.getZoneId() + cmd.getValue() + String.format(\"%02d\", value);\n+        } else {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: passed in value is null\");\n+        }\n+        messageStr += END_CMD;\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(messageStr.getBytes(StandardCharsets.US_ASCII));\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());", "originalCommit": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188437", "bodyText": "You should make another constructor that takes a String and a Throwable as an argument. To allow the passing of cause exceptions.", "author": "cpmeister", "createdAt": "2020-06-24T21:42:31Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link MonopriceAudioException} class is used for any exception thrown by the binding\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioException extends Exception {", "originalCommit": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "url": "https://github.com/openhab/openhab-addons/commit/5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-25T02:26:43Z", "type": "commit"}, {"oid": "c34c6d62ac3b72976a0dd5bca563325e8208adb7", "url": "https://github.com/openhab/openhab-addons/commit/c34c6d62ac3b72976a0dd5bca563325e8208adb7", "message": "commit change that was missed\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-25T03:56:52Z", "type": "commit"}, {"oid": "f4fd3ae79696e47991c8543f02061493c80e2a32", "url": "https://github.com/openhab/openhab-addons/commit/f4fd3ae79696e47991c8543f02061493c80e2a32", "message": "fix variable name for pmd report\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-06T02:33:08Z", "type": "commit"}, {"oid": "d2c03db0cb30ac223ec1a99a5958701afbd36ddd", "url": "https://github.com/openhab/openhab-addons/commit/d2c03db0cb30ac223ec1a99a5958701afbd36ddd", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-08T22:22:45Z", "type": "commit"}, {"oid": "5cbdb3ad598334b0c5d111a3091f064a8add1601", "url": "https://github.com/openhab/openhab-addons/commit/5cbdb3ad598334b0c5d111a3091f064a8add1601", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-08T22:24:51Z", "type": "commit"}, {"oid": "cac938edc2d3677c63ba1d34cf36b0f5844e5353", "url": "https://github.com/openhab/openhab-addons/commit/cac938edc2d3677c63ba1d34cf36b0f5844e5353", "message": "fix order of updateStatus() call\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-09T01:13:36Z", "type": "commit"}, {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-16T21:38:23Z", "type": "commit"}, {"oid": "9b579193ad576302dc462c6574b4890746be2025", "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-25T03:38:33Z", "type": "commit"}, {"oid": "78f69778930aba426a203feec98c17aee188a536", "url": "https://github.com/openhab/openhab-addons/commit/78f69778930aba426a203feec98c17aee188a536", "message": "Merge pull request #8 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-28T15:24:48Z", "type": "commit"}, {"oid": "d0cd7f937d1a5508ec45839ed56eae456a63791d", "url": "https://github.com/openhab/openhab-addons/commit/d0cd7f937d1a5508ec45839ed56eae456a63791d", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-07-28T15:26:15Z", "type": "commit"}, {"oid": "b244b79e0d2a08ac3072306017f3c5576824f6c7", "url": "https://github.com/openhab/openhab-addons/commit/b244b79e0d2a08ac3072306017f3c5576824f6c7", "message": "update version and fix remaining warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-28T15:55:47Z", "type": "commit"}, {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857", "url": "https://github.com/openhab/openhab-addons/commit/7f0a56bf418fed52b7ad2773f493a849942f4857", "message": "documentation fixes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-14T18:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NTExNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474675117", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String value;\n          \n          \n            \n                private final String value;", "author": "Hilbrand", "createdAt": "2020-08-21T12:48:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+    QUERY(\"?\"),\n+    POWER(\"PR\"),\n+    SOURCE(\"CH\"),\n+    VOLUME(\"VO\"),\n+    MUTE(\"MU\"),\n+    TREBLE(\"TR\"),\n+    BASS(\"BS\"),\n+    BALANCE(\"BL\"),\n+    DND(\"DT\");\n+\n+    private String value;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NTQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474675463", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n          \n          \n            \n                private final List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();", "author": "Hilbrand", "createdAt": "2020-08-21T12:49:24Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NjEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676121", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n          \n          \n            \n                    super(\"OH-binding-\" + MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);", "author": "Hilbrand", "createdAt": "2020-08-21T12:50:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     * @param uid unique identifier from the connector\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector, String uid) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NjQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676450", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String serialPortName;\n          \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final String serialPortName;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "author": "Hilbrand", "createdAt": "2020-08-21T12:51:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3Njk0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n          \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(MonopriceAudioZone::name)", "author": "Hilbrand", "createdAt": "2020-08-21T12:52:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NzA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474677063", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .map(z -> z.getZoneId()).collect(Collectors.toList());\n          \n          \n            \n                        .map(MonopriceAudioZone::getZoneId).collect(Collectors.toList());", "author": "Hilbrand", "createdAt": "2020-08-21T12:52:39Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n+            .collect(Collectors.toList());\n+\n+    // make a list of all valid zone ids\n+    public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(z -> z.getZoneId()).collect(Collectors.toList());", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3ODU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474678589", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String zoneId;\n          \n          \n            \n                private final String zoneId;", "author": "Hilbrand", "createdAt": "2020-08-21T12:55:41Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474704516", "bodyText": "The openHAB serial port handler supports rfc2217? Is there a reason not to use it and instead of having implemented a separate ip connector and configuration options?", "author": "Hilbrand", "createdAt": "2020-08-21T13:40:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,703 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private Set<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+        String ignoreZonesConfig = config.ignoreZones;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAyNzcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r475027706", "bodyText": "same comment as on pr #7651", "author": "mlobstein", "createdAt": "2020-08-22T01:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474704848", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String key;\n          \n          \n            \n                private String value;\n          \n          \n            \n                private final String key;\n          \n          \n            \n                private final String value;", "author": "Hilbrand", "createdAt": "2020-08-21T13:41:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * MonopriceAudio event used to notify changes coming from messages received from the MonopriceAudio device\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioMessageEvent extends EventObject {\n+\n+    private static final long serialVersionUID = 1L;\n+    private String key;\n+    private String value;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "url": "https://github.com/openhab/openhab-addons/commit/4c109203efcc0bcb3112baf832ad75ecd2481a0a", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-22T01:04:44Z", "type": "commit"}, {"oid": "f49106bbf897956459a88243323fc5d64a4b3223", "url": "https://github.com/openhab/openhab-addons/commit/f49106bbf897956459a88243323fc5d64a4b3223", "message": "Merge pull request #9 from openhab/2.5.x\n\nUpdate fork", "committedDate": "2020-08-22T01:32:17Z", "type": "commit"}, {"oid": "746cf624b417b4b9df1e3ca4a8066f931485ef87", "url": "https://github.com/openhab/openhab-addons/commit/746cf624b417b4b9df1e3ca4a8066f931485ef87", "message": "merge pom.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-22T01:35:22Z", "type": "commit"}, {"oid": "1b3468619f66ee3714b476681f761a0c92dff658", "url": "https://github.com/openhab/openhab-addons/commit/1b3468619f66ee3714b476681f761a0c92dff658", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T13:25:14Z", "type": "commit"}, {"oid": "ce6b1b83511266993e7e74b54122b54654265a79", "url": "https://github.com/openhab/openhab-addons/commit/ce6b1b83511266993e7e74b54122b54654265a79", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T15:39:12Z", "type": "commit"}, {"oid": "ca3481541399089a8850bdc845723806ad92a28d", "url": "https://github.com/openhab/openhab-addons/commit/ca3481541399089a8850bdc845723806ad92a28d", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-08-26T16:57:47Z", "type": "commit"}, {"oid": "9d1ac35725796cf41e0cd1cdd497c899ab06930c", "url": "https://github.com/openhab/openhab-addons/commit/9d1ac35725796cf41e0cd1cdd497c899ab06930c", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T17:09:42Z", "type": "commit"}, {"oid": "31227c502d4697366429850b34557b7cebf44831", "url": "https://github.com/openhab/openhab-addons/commit/31227c502d4697366429850b34557b7cebf44831", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T20:01:12Z", "type": "commit"}, {"oid": "67bb699dd5d433cc3428720005b61e6726193933", "url": "https://github.com/openhab/openhab-addons/commit/67bb699dd5d433cc3428720005b61e6726193933", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-08-26T20:03:28Z", "type": "commit"}, {"oid": "86a5327cb44c5f0ed3f4640a439df62954d8ab33", "url": "https://github.com/openhab/openhab-addons/commit/86a5327cb44c5f0ed3f4640a439df62954d8ab33", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x", "committedDate": "2020-09-03T00:24:02Z", "type": "commit"}, {"oid": "ad2731c230b2c87628de459b77f03082da06b656", "url": "https://github.com/openhab/openhab-addons/commit/ad2731c230b2c87628de459b77f03082da06b656", "message": "fix merge conflicts\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-09-03T00:36:59Z", "type": "commit"}]}