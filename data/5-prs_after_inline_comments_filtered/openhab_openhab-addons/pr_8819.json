{"pr_number": 8819, "pr_title": "[bluetooth.bluez] Complete Bluez rewrite", "pr_createdAt": "2020-10-21T07:02:45Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8819", "timeline": [{"oid": "a9d4752ec5b864653a8151f23ca23fdf286c16cc", "url": "https://github.com/openhab/openhab-addons/commit/a9d4752ec5b864653a8151f23ca23fdf286c16cc", "message": "removed duplicate channel RSSI\n\nSigned-off-by: Benjamin Lafois <benjamin.lafois@gmail.com>", "committedDate": "2020-10-13T12:28:10Z", "type": "commit"}, {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "url": "https://github.com/openhab/openhab-addons/commit/1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "message": "replacement of old dbus binding by blueZ one, adapted to OH3\n\nSigned-off-by: Benjamin Lafois <benjamin.lafois@gmail.com>", "committedDate": "2020-10-20T18:39:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzOTIyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509439225", "bodyText": "This should be kept as is.", "author": "cpmeister", "createdAt": "2020-10-21T16:42:18Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZHandlerFactory.java", "diffHunk": "@@ -30,33 +30,47 @@\n import org.openhab.core.thing.binding.ThingHandler;\n import org.openhab.core.thing.binding.ThingHandlerFactory;\n import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link BlueZHandlerFactory} is responsible for creating things and thing\n  * handlers.\n  *\n- * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Initial contribution and API", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzOTYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509439626", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-10-21T16:42:55Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MDE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509440148", "bodyText": "I forgot to remove this earlier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DeviceManagerFactory.class, immediate = true)\n          \n          \n            \n            @Component(service = DeviceManagerFactory.class)", "author": "cpmeister", "createdAt": "2020-10-21T16:43:46Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class, immediate = true)", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NDY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509464682", "bodyText": "This shouldn't be changed", "author": "cpmeister", "createdAt": "2020-10-21T17:17:09Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConfiguration.java", "diffHunk": "@@ -10,14 +10,14 @@\n  *\n  * SPDX-License-Identifier: EPL-2.0\n  */\n-package org.openhab.binding.bluetooth.bluez.handler;\n+package org.openhab.binding.bluetooth.bluez.internal;\n \n import org.openhab.binding.bluetooth.BaseBluetoothBridgeHandlerConfiguration;\n \n /**\n- * Configuration properties class.\n+ * Configuration properties for a bridge.\n  *\n- * @author Hilbrand Bouwkamp - Initial contribution\n+ * @author Benjamin Lafois - Initial contribution", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NjA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509466092", "bodyText": "This can be removed", "author": "cpmeister", "createdAt": "2020-10-21T17:18:32Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,501 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            // logger.debug(\"Objects representing the BT device {} has not changed. Exiting function.\", address);", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NjI5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509466292", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.error(\"error occured while trying to connect\", e);\n          \n          \n            \n                                logger.warn(\"error occured while trying to connect\", e);", "author": "cpmeister", "createdAt": "2020-10-21T17:18:48Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,501 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            // logger.debug(\"Objects representing the BT device {} has not changed. Exiting function.\", address);\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.error(\"error occured while trying to connect\", e);", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NzEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509467103", "bodyText": "This can be removed", "author": "cpmeister", "createdAt": "2020-10-21T17:19:37Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    // private final ReentrantLock lockDiscoveryJob = new ReentrantLock();", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509467605", "bodyText": "This can be removed", "author": "cpmeister", "createdAt": "2020-10-21T17:20:07Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    // private final ReentrantLock lockDiscoveryJob = new ReentrantLock();\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        if (configuration.address != null) {\n+            this.adapterAddress = new BluetoothAddress(configuration.address.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        if (this.adapter != null) {\n+            ((@NonNull BluetoothAdapter) this.adapter).stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static @Nullable BluetoothAdapter findAdapter(DeviceManager deviceManager, String address) {\n+        List<BluetoothAdapter> adapters = deviceManager.getAdapters();\n+        if (adapters != null) {\n+            for (BluetoothAdapter btAdapter : adapters) {\n+                if (btAdapter.getAddress() != null && btAdapter.getAddress().equalsIgnoreCase(address)) {\n+                    return btAdapter;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean validateAdapter(DeviceManager deviceManager) {\n+\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            if (adapterAddress != null) {\n+                localAdapter = adapter = findAdapter(deviceManager,\n+                        ((@NonNull BluetoothAddress) adapterAddress).toString());\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return false;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return false;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return false;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManager deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            if (!validateAdapter(deviceManager)) {\n+                return;\n+            }\n+\n+            // as we have already validated the adapteraddress in {@link #validateAdapter(DeviceAdapter)}, we can safely\n+            // assume that adapterAddress is not null.\n+            @NonNull\n+            BluetoothAddress adapterAddress = (@NonNull BluetoothAddress) this.adapterAddress;\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapterAddress.toString(), true);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);\n+                if (bluezDevice.getAddress() == null) {\n+                    // For some reasons, sometimes the address is null..\n+                    continue;\n+                }\n+                BlueZBluetoothDevice device = getDevice(new BluetoothAddress(bluezDevice.getAddress()));\n+                device.updateBlueZDevice(bluezDevice);\n+                deviceDiscovered(device);\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (Exception ex) {\n+            // don't know what kind of exception the bluez library might throw at us so lets catch them here so our\n+            // scheduler loop doesn't get terminated\n+            logger.warn(\"Unknown exception\", ex);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable BluetoothAddress getAddress() {\n+        return adapterAddress;\n+    }\n+\n+    @Override\n+    protected BlueZBluetoothDevice createDevice(BluetoothAddress address) {\n+        logger.debug(\"createDevice {}\", address);\n+        BlueZBluetoothDevice device = new BlueZBluetoothDevice(this, address);\n+        return device;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+\n+        BluetoothAdapter localAdapter = this.adapter;\n+        String adapterName = event.getAdapterName();\n+        if (adapterName == null || localAdapter == null) {\n+            // We cannot be sure that this event concerns this adapter.. So ignore message\n+            return;\n+        }\n+        String localName = localAdapter.getDeviceName();\n+\n+        // logger.debug(\"Received event {}. Adapter={}. AdapterBridge={}\", event.getClass().getSimpleName(),\n+        // adapterName,\n+        // localName);", "originalCommit": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "url": "https://github.com/openhab/openhab-addons/commit/bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "message": "PR Review by @cpmeister #1\n\nSigned-off-by: Benjamin Lafois <benjamin.lafois@gmail.com>", "committedDate": "2020-10-21T17:59:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MDE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509560157", "bodyText": "This shouldn't be changed", "author": "cpmeister", "createdAt": "2020-10-21T18:33:54Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConstants.java", "diffHunk": "@@ -20,7 +20,7 @@\n  * The {@link BlueZAdapterConstants} class defines common constants, which are\n  * used across the whole binding.\n  *\n- * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Initial contribution and API", "originalCommit": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MTgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509561808", "bodyText": "This should already be inherited from the BaseBluetoothDevice, so remove this field.", "author": "cpmeister", "createdAt": "2020-10-21T18:35:26Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();", "originalCommit": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2Mzc1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509563756", "bodyText": "We should keep the authoring tags.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * @author Benjamin Lafois - Initial contribution and API\n          \n          \n            \n             * @author Kai Kreuzer - Initial contribution and API\n          \n          \n            \n             * @author Benjamin Lafois - Reimplemented using Dbus instead of tinyB", "author": "cpmeister", "createdAt": "2020-10-21T18:37:36Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API", "originalCommit": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2NTA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509565077", "bodyText": "Are these null annotations required?", "author": "cpmeister", "createdAt": "2020-10-21T18:39:03Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        if (configuration.address != null) {\n+            this.adapterAddress = new BluetoothAddress(configuration.address.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        if (this.adapter != null) {\n+            ((@NonNull BluetoothAdapter) this.adapter).stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static @Nullable BluetoothAdapter findAdapter(DeviceManager deviceManager, String address) {\n+        List<BluetoothAdapter> adapters = deviceManager.getAdapters();\n+        if (adapters != null) {\n+            for (BluetoothAdapter btAdapter : adapters) {\n+                if (btAdapter.getAddress() != null && btAdapter.getAddress().equalsIgnoreCase(address)) {\n+                    return btAdapter;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean validateAdapter(DeviceManager deviceManager) {\n+\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            if (adapterAddress != null) {\n+                localAdapter = adapter = findAdapter(deviceManager,\n+                        ((@NonNull BluetoothAddress) adapterAddress).toString());\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return false;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return false;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return false;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManager deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            if (!validateAdapter(deviceManager)) {\n+                return;\n+            }\n+\n+            // as we have already validated the adapteraddress in {@link #validateAdapter(DeviceAdapter)}, we can safely\n+            // assume that adapterAddress is not null.\n+            @NonNull\n+            BluetoothAddress adapterAddress = (@NonNull BluetoothAddress) this.adapterAddress;", "originalCommit": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b8887e0f99f78f8884b8e8850c6e5bdc68bb727", "url": "https://github.com/openhab/openhab-addons/commit/4b8887e0f99f78f8884b8e8850c6e5bdc68bb727", "message": "Fix osgi dependencies\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-21T21:47:26Z", "type": "commit"}, {"oid": "f668e2a4c133e778d4035428f244d9cae5255feb", "url": "https://github.com/openhab/openhab-addons/commit/f668e2a4c133e778d4035428f244d9cae5255feb", "message": "Added DeviceManagerWrapper for threadsafety along with other PR cleanup\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-21T23:17:19Z", "type": "commit"}, {"oid": "1770c18c8383541c88c342d9cd3d9f97fcd6cc54", "url": "https://github.com/openhab/openhab-addons/commit/1770c18c8383541c88c342d9cd3d9f97fcd6cc54", "message": "Improved performance of dbus path parsing\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-21T23:30:21Z", "type": "commit"}, {"oid": "d88709cfa46c168fedbf6372fc405093b2090f93", "url": "https://github.com/openhab/openhab-addons/commit/d88709cfa46c168fedbf6372fc405093b2090f93", "message": "Change BlueZEvent to use visitor pattern\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-22T00:30:36Z", "type": "commit"}, {"oid": "9003c1c04beb787e21e9106379105f5584e89f48", "url": "https://github.com/openhab/openhab-addons/commit/9003c1c04beb787e21e9106379105f5584e89f48", "message": "Fill in essential javadocs\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-22T00:52:43Z", "type": "commit"}, {"oid": "ac05fedaa480569b6c45f79aae2d68d1a5b674d8", "url": "https://github.com/openhab/openhab-addons/commit/ac05fedaa480569b6c45f79aae2d68d1a5b674d8", "message": "Revert changes in daikin madoka\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-22T01:01:05Z", "type": "commit"}, {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5", "url": "https://github.com/openhab/openhab-addons/commit/00d70430420d1037e3a206a0b1c83549f7d151b5", "message": "Reduce build warnings\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-22T06:37:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510386953", "bodyText": "Looking at this code I have an impression that it could be simplified with basic:\nif (deviceManager != null) deviceManager.closeConnection();\ndeviceManager = null\n\nIs there a concurrency issue that forces you to assign field to local variable?", "author": "splatch", "createdAt": "2020-10-22T18:56:07Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ * This service handles the lifecycle of the {@link DeviceManager} singleton instance.\n+ * In addition, this class is responsible for managing the BlueZPropertiesChangedHandler instance\n+ * used by the binding for listening and dispatching dbus events from the DeviceManager.\n+ *\n+ * Creation of the DeviceManager is asynchronous and thus attempts to retrieve the DeviceManager\n+ * through 'getDeviceManager' may initially fail.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class)\n+public class DeviceManagerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DeviceManagerFactory.class);\n+    private final BlueZPropertiesChangedHandler changeHandler = new BlueZPropertiesChangedHandler();\n+\n+    private @Nullable ScheduledExecutorService scheduler;\n+    private @Nullable DeviceManager deviceManager;\n+    private @Nullable CompletableFuture<DeviceManagerWrapper> deviceManagerFuture;\n+\n+    public BlueZPropertiesChangedHandler getPropertiesChangedHandler() {\n+        return changeHandler;\n+    }\n+\n+    public @Nullable DeviceManagerWrapper getDeviceManager() {\n+        // we can cheat the null checker with casting here\n+        var future = (CompletableFuture<@Nullable DeviceManagerWrapper>) this.deviceManagerFuture;\n+        if (future != null) {\n+            return future.getNow(null);\n+        }\n+        return null;\n+    }\n+\n+    @Activate\n+    public void initialize() {\n+        logger.debug(\"initializing DeviceManagerFactory\");\n+        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth.bluez-init\", true));\n+\n+        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+        scheduler.setRemoveOnCancelPolicy(true);\n+\n+        this.scheduler = scheduler;\n+\n+        this.deviceManagerFuture = callAsync(() -> {\n+            try {\n+                // if this is the first call to the library, this call\n+                // should throw an exception (that we are catching)\n+                return DeviceManager.getInstance();\n+                // Experimental - seems reuse does not work\n+            } catch (IllegalStateException e) {\n+                // Exception caused by first call to the library\n+                return DeviceManager.createInstance(false);\n+            }\n+        }, scheduler)//\n+                .thenApply(devManager -> {\n+                    this.deviceManager = devManager;\n+                    return devManager;\n+                }).thenCompose(devManager -> registerPropertyHandler(devManager, scheduler))//\n+                .thenApply(DeviceManagerWrapper::new)//\n+                .whenComplete((devManager, th) -> {\n+                    if (th != null) {\n+                        logger.warn(\"Failed to initialize DeviceManager: {}\", th.getMessage());\n+                    }\n+                });\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        DeviceManager manager = deviceManager;", "originalCommit": "00d70430420d1037e3a206a0b1c83549f7d151b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5NDc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510394742", "bodyText": "Is there a concurrency issue that forces you to assign field to local variable?\n\nBingo, we use a pretty strict NPE prevention tool that will ignore null checks for @Nullablee fields.", "author": "cpmeister", "createdAt": "2020-10-22T19:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5OTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510399727", "bodyText": "Are you kidding me? Does the tool is blind to non null condition or imply multi thread access based on code in other places?\nAnyhow - maybe it is avoidable with AtomicReference.getAndUpdate which should be consider safer?\nLooking at code and use of CompletableFuture you might be still better with direct access over future which should retain computed value unless disposed..", "author": "splatch", "createdAt": "2020-10-22T19:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxNTk0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510415946", "bodyText": "Are you kidding me? Does the tool is blind to non null condition or imply multi thread access based on code in other places?\n\nI think the tool is taking the heavy-handed assumption that any nullable field could be changed to null by another thread at any time. Overzealous and inappropriate in a vast majority of situations but if you hate NPE enough the tradeoff can be worth it.\n\nAnyhow - maybe it is avoidable with AtomicReference.getAndUpdate which should be consider safer?\nLooking at code and use of CompletableFuture you might be still better with direct access over future which should retain computed value unless disposed..\n\nMy use of completable future was to prevent access to the deviceManager before the BlueZPropertiesChangedHandler was registered. Making sure that BlueZPropertiesChangedHandler successfully registered is a rather good litmus test for whether the deviceManager is in a state usable by the rest of the application.\nI suppose I could add more fields to keep track of registration state but I think adding more state fields might make the code less maintainable.", "author": "cpmeister", "createdAt": "2020-10-22T19:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Nzk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510387947", "bodyText": "I believe that making key.toLowerCase() might be more reliable in case of future updates in bluez and eventual changes in property names.", "author": "splatch", "createdAt": "2020-10-22T18:57:54Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is the PropertiesChangedHandler subclass used by the binding to handle/dispatch property change events\n+ * from bluez.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ * @author Connor Petty - Code cleanup\n+ */\n+@NonNullByDefault\n+public class BlueZPropertiesChangedHandler extends AbstractPropertiesChangedHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZPropertiesChangedHandler.class);\n+\n+    private final Set<BlueZEventListener> listeners = new CopyOnWriteArraySet<>();\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    public void addListener(BlueZEventListener listener) {\n+        this.listeners.add(listener);\n+    }\n+\n+    public void removeListener(BlueZEventListener listener) {\n+        this.listeners.remove(listener);\n+    }\n+\n+    private void notifyListeners(BlueZEvent event) {\n+        for (BlueZEventListener listener : this.listeners) {\n+            event.dispatch(listener);\n+        }\n+    }\n+\n+    @Override\n+    public void handle(@Nullable PropertiesChanged properties) {\n+        if (properties == null || properties.getPropertiesChanged() == null) {\n+            logger.debug(\"Null properties. Skipping.\");\n+            return;\n+        }\n+        Map<@Nullable String, @Nullable Variant<?>> changedProperties = properties.getPropertiesChanged();\n+        if (changedProperties == null) {\n+            logger.debug(\"Null properties changed. Skipping.\");\n+            return;\n+        }\n+\n+        // do this asynchronously so that we don't slow things down for the dbus event dispatcher\n+        scheduler.execute(() -> {\n+\n+            String dbusPath = properties.getPath();\n+            changedProperties.forEach((key, variant) -> {\n+                if (key == null || variant == null) {\n+                    return;\n+                }\n+                switch (key) {", "originalCommit": "00d70430420d1037e3a206a0b1c83549f7d151b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxNjE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510416178", "bodyText": "good idea!", "author": "cpmeister", "createdAt": "2020-10-22T19:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Nzk0Nw=="}], "type": "inlineReview"}, {"oid": "322c500d36ee0ca9e3c19258023ab6f6371adeab", "url": "https://github.com/openhab/openhab-addons/commit/322c500d36ee0ca9e3c19258023ab6f6371adeab", "message": "Address review comments and improve threadsafety\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-22T22:13:38Z", "type": "commit"}, {"oid": "4fede3bb2adf35fdf1b55c8a46e79712a553d812", "url": "https://github.com/openhab/openhab-addons/commit/4fede3bb2adf35fdf1b55c8a46e79712a553d812", "message": "minor code cleanup\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-23T04:27:16Z", "type": "commit"}, {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "url": "https://github.com/openhab/openhab-addons/commit/9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "message": "Fix javadocs\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-23T04:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511168571", "bodyText": "What is this info telling to the user? Either he can ignore it, then debug should suffice or it is a problem in the configuration/device, then it should rather be a warning with more details.", "author": "kaikreuzer", "createdAt": "2020-10-23T21:43:44Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5MzY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511193694", "bodyText": "The situation is unusual, and might indicate a problem. But the issue doesn't require intervention so I'll change to debug.", "author": "cpmeister", "createdAt": "2020-10-23T23:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511168897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Has notified that a characteristic has been updated\");\n          \n          \n            \n                        logger.debug(\"Notified that a characteristic has been updated\");", "author": "kaikreuzer", "createdAt": "2020-10-23T21:44:38Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5Mzk3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511193972", "bodyText": "Actually, this log isn't really needed anyway since I'll get a log from the BlueZPropertyChangedHandler anyway.\nRemoving.", "author": "cpmeister", "createdAt": "2020-10-23T23:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTAxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169018", "bodyText": "Suggested change", "author": "kaikreuzer", "createdAt": "2020-10-23T21:44:56Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NDIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511194205", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-23T23:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169079", "bodyText": "Suggested change", "author": "kaikreuzer", "createdAt": "2020-10-23T21:45:05Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwNDE4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511204180", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-24T00:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTE0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169149", "bodyText": "Suggested change", "author": "kaikreuzer", "createdAt": "2020-10-23T21:45:15Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+\n+                addService(service);\n+            }\n+", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NDI2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511194268", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-23T23:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169257", "bodyText": "Suggested change", "author": "kaikreuzer", "createdAt": "2020-10-23T21:45:33Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwNDIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511204233", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-24T00:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169522", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n          \n          \n            \n            \n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n          \n          \n            \n            \n          \n          \n            \n                    deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n          \n          \n            \n            \n          \n          \n            \n                    discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n          \n          \n            \n                    logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN);\n          \n          \n            \n                    deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n          \n          \n            \n                    discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);", "author": "kaikreuzer", "createdAt": "2020-10-23T21:46:18Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511170234", "bodyText": "As far as I know, there isn't such a thing as duty cycle for BT - that's only a regulation on 868/900MHz. Better put detail to NONE.", "author": "kaikreuzer", "createdAt": "2020-10-23T21:48:36Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwNDA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511204062", "bodyText": "changed to NONE", "author": "cpmeister", "createdAt": "2020-10-24T00:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMjcxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511332719", "bodyText": "@kaikreuzer it is not because of regulation, but with testing, what I've realized is that when you power on the device, if you immediately start the discovery, it might fail, so you need to give the adapter a little time to start up. But yes the \"DUTY_CYCLE\" is not the right reason.", "author": "blafois", "createdAt": "2020-10-24T07:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511171227", "bodyText": "Why OFFLINE? If you can start discovery on it, it seems to be available, i.e. ONLINE?", "author": "kaikreuzer", "createdAt": "2020-10-23T21:51:41Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NTg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511195898", "bodyText": "After looking at how startDiscovery was implemented, it looks like it already checks isDiscovering as part of it.\nI'll go ahead and simplify this logic then.", "author": "cpmeister", "createdAt": "2020-10-23T23:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMjk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511332957", "bodyText": "I implemented this months ago - but if my memory is good - if you turn it ONLINE immediately, the various things depending on it will immediately try to connect, which will fail because the devices needs to be discovered before it's possible to connect. But I might be wrong, and I'll retest it when we will be done if all changes !", "author": "blafois", "createdAt": "2020-10-24T07:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511171314", "bodyText": "can this line be removed?", "author": "kaikreuzer", "createdAt": "2020-10-23T21:51:56Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return null;\n+        }\n+        return localAdapter;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManagerWrapper deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            BluetoothAdapter adapter = prepareAdapter(deviceManager);\n+            if (adapter == null) {\n+                // adapter isn't prepared yet\n+                return;\n+            }\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapter);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NjEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511196130", "bodyText": "indeed it can", "author": "cpmeister", "createdAt": "2020-10-23T23:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511172438", "bodyText": "Could you please add a one line JavaDoc description here and in all the classes below with the same empty JavaDoc header?", "author": "kaikreuzer", "createdAt": "2020-10-23T21:55:10Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/events/CharacteristicUpdateEvent.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal.events;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *", "originalCommit": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMzM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511203387", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-24T00:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjQzOA=="}], "type": "inlineReview"}, {"oid": "8fd4da231bd4cef02f17b811d0226b3dcf6d54fc", "url": "https://github.com/openhab/openhab-addons/commit/8fd4da231bd4cef02f17b811d0226b3dcf6d54fc", "message": "Address review comments\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-24T00:05:53Z", "type": "commit"}, {"oid": "aecda9ccb8b030a0133f717c528a429cbe8ee5d0", "url": "https://github.com/openhab/openhab-addons/commit/aecda9ccb8b030a0133f717c528a429cbe8ee5d0", "message": "fix comment\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-24T00:31:19Z", "type": "commit"}, {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9", "url": "https://github.com/openhab/openhab-addons/commit/00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9", "message": "Fix library version in NOTICE\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-24T01:43:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511335910", "bodyText": "It seems you had missed this change - CONFIGURATION_PENDING is not a valid status detail here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");", "author": "kaikreuzer", "createdAt": "2020-10-24T08:14:31Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");", "originalCommit": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4OTk5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511489992", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-24T16:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511336472", "bodyText": "I'm still not clear why it is OFFLINE here.\nThe message \"starting discovery\" seems to suggest that we are still initializing, so I would simply stay in UNKNOWN status that moment (until we know if the outcome is successful or not).\nIf I misunderstand the message and the comment above (\"make sure that discovery is turned on\") is actually correct by saying that we have discovered a situation where we expect discovery being enabled, while it isn't and we consider this a \"permanent\" issue with the adapter, then OFFLINE is indeed the right choice.\nCould you help me understand which one is right here?", "author": "kaikreuzer", "createdAt": "2020-10-24T08:20:58Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "originalCommit": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4OTQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511489412", "bodyText": "Sometimes bluez will turn off discovery as part of it's own error recovery system when it encounters strange bluetooth situations it doesn't know how to handle. (i.e. an advertisement packet that has incorrect length values, or a low level hardware error). Bluez won't turn discovery back on automatically so we just make sure we keep it on by starting it if it is turned off.\nNow turning on discovery might not work if the underlying hardware is not ready, in which case trying again later might prove effective, but there might be something wrong with the hardware as well in which case the OFFLINE seems appropriate. Since I can't tell whether a discovery failure is going to be temporary or permanent I think it would be safer just make the bridge OFFLINE until we can confirm that discovery is properly active.\nWDYT?", "author": "cpmeister", "createdAt": "2020-10-24T16:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5ODY4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511498687", "bodyText": "@cpmeister is right that BlueZ for some reason stops discovering sometimes. sometimes, restarting discovery is not even sufficient which is the reason why I coded some adapter recycling. INITIALIZING would make sense if this piece of code would only be called upon binding startup, but if we look closely, the prepareAdapter method is also called on each \"refreshdevice\" iteration.\nWe could as such observe situation ONLINE->INITIALIZING->ONLINE. Otherwise it is ONLINE->OFFLINE->ONLINE\nIn any case, I'm fine with both solutions, as I don't think there is an impact ?", "author": "blafois", "createdAt": "2020-10-24T18:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxMTk5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511511995", "bodyText": "Ok, thanks for your explanation! So how about adapting the message to:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Trying to start discovery\");", "author": "kaikreuzer", "createdAt": "2020-10-24T20:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUzMDQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511530439", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-10-25T00:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}], "type": "inlineReview"}, {"oid": "ca8cdab74d811957bb81481cd138616390db35ad", "url": "https://github.com/openhab/openhab-addons/commit/ca8cdab74d811957bb81481cd138616390db35ad", "message": "More review suggestions\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-24T16:31:38Z", "type": "commit"}, {"oid": "4f31cba23c2929aa6c027e4af335058a9b64f8c5", "url": "https://github.com/openhab/openhab-addons/commit/4f31cba23c2929aa6c027e4af335058a9b64f8c5", "message": "Review changes\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-10-25T00:43:50Z", "type": "commit"}]}