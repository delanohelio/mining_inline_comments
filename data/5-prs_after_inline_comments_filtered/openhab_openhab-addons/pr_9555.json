{"pr_number": 9555, "pr_title": "[WebThing] Initial contribution", "pr_createdAt": "2020-12-28T07:07:19Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9555", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQzODc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r550438753", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (Exception illegalURIException) {\n          \n          \n            \n                        } catch (IllegalArgumentException illegalURIException) {", "author": "fwolter", "createdAt": "2020-12-31T09:25:23Z", "path": "bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/WebThingHandler.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.webthing.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.openhab.binding.webthing.internal.channel.Channels;\n+import org.openhab.binding.webthing.internal.client.*;\n+import org.openhab.binding.webthing.internal.link.ChannelToPropertyLink;\n+import org.openhab.binding.webthing.internal.link.PropertyToChannelLink;\n+import org.openhab.binding.webthing.internal.link.UnknownPropertyException;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WebThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Gregor Roth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WebThingHandler extends BaseThingHandler implements ChannelHandler {\n+    private static final Duration RECONNECT_PERIOD = Duration.ofHours(23);\n+    private static final Duration HEALTH_CHECK_PERIOD = Duration.ofSeconds(70);\n+    private static final ItemChangedListener EMPTY_ITEM_CHANGED_LISTENER = (channelUID, stateCommand) -> {\n+    };\n+\n+    private final Logger logger = LoggerFactory.getLogger(WebThingHandler.class);\n+    private final HttpClient httpClient;\n+    private final WebSocketClient webSocketClient;\n+    private final AtomicBoolean isActivated = new AtomicBoolean(true);\n+    private final Map<ChannelUID, ItemChangedListener> itemChangedListenerMap = new ConcurrentHashMap<>();\n+    private final AtomicReference<Optional<ConsumedThing>> webThingConnectionRef = new AtomicReference<>(\n+            Optional.empty());\n+    private final AtomicReference<Instant> lastReconnect = new AtomicReference<>(Instant.now());\n+    private final AtomicReference<Optional<ScheduledFuture<?>>> watchdogHandle = new AtomicReference<>(\n+            Optional.empty());\n+    private @Nullable URI webThingURI = null;\n+\n+    public WebThingHandler(Thing thing, HttpClient httpClient, WebSocketClient webSocketClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.webSocketClient = webSocketClient;\n+    }\n+\n+    private boolean isOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    private boolean isDisconnected() {\n+        return (getThing().getStatus() == ThingStatus.OFFLINE) || (getThing().getStatus() == ThingStatus.UNKNOWN);\n+    }\n+\n+    private boolean isAlive() {\n+        return webThingConnectionRef.get().map(ConsumedThing::isAlive).orElse(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        isActivated.set(true); // set with true, even though the connect may fail. In this case retries will be\n+                               // triggered\n+\n+        // perform connect in background\n+        scheduler.execute(() -> {\n+            // WebThing URI present?\n+            this.webThingURI = readWebThingURI();\n+            if (webThingURI != null) {\n+                logger.debug(\"try to connect WebThing {}\", webThingURI);\n+                var connected = tryReconnect(webThingURI);\n+                if (connected) {\n+                    logger.debug(\"WebThing {} connected\", getWebThingLabel());\n+                }\n+            } else {\n+                logger.warn(\"could not initialize WebThing. URI is not set or invalid. {}\", this.webThingURI);\n+            }\n+        });\n+\n+        // starting watchdog that checks the healthiness of the WebThing connection, periodically\n+        watchdogHandle\n+                .getAndSet(Optional.of(scheduler.scheduleWithFixedDelay(this::checkWebThingConnection,\n+                        HEALTH_CHECK_PERIOD.getSeconds(), HEALTH_CHECK_PERIOD.getSeconds(), TimeUnit.SECONDS)))\n+                .ifPresent(future -> future.cancel(true));\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        try {\n+            isActivated.set(false); // set to false to avoid reconnecting\n+\n+            // terminate WebThing connection as well as the alive watchdog\n+            webThingConnectionRef.getAndSet(Optional.empty()).ifPresent(ConsumedThing::close);\n+            watchdogHandle.getAndSet(Optional.empty()).ifPresent(future -> future.cancel(true));\n+        } finally {\n+            super.dispose();\n+        }\n+    }\n+\n+    private boolean tryReconnect(@Nullable URI uri) {\n+        if (isActivated.get()) { // will try reconnect only, if activated\n+            try {\n+                // create the client-side WebThing representation\n+                if (uri != null) {\n+                    var webThing = ConsumedThingFactory.instance().create(webSocketClient, httpClient, uri, scheduler,\n+                            this::onError);\n+                    this.webThingConnectionRef.getAndSet(Optional.of(webThing)).ifPresent(ConsumedThing::close);\n+\n+                    // update the Thing structure based on the WebThing description\n+                    thingStructureChanged(webThing);\n+\n+                    // link the Thing's channels with the WebThing properties to forward properties/item updates\n+                    establishWebThingChannelLinks(webThing);\n+\n+                    lastReconnect.set(Instant.now());\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                var msg = e.getMessage();\n+                if (msg == null) {\n+                    msg = \"\";\n+                }\n+                onError(msg);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void onError(String reason) {\n+        var wasConnectedBefore = isOnline();\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, reason);\n+\n+        // close the WebThing connection. If the handler is still active, the WebThing connection\n+        // will be re-established within the periodically watchdog task\n+        webThingConnectionRef.getAndSet(Optional.empty()).ifPresent(ConsumedThing::close);\n+\n+        if (wasConnectedBefore) { // to reduce log messages, just log in case of connection state changed\n+            logger.debug(\"WebThing {} disconnected {}. Try reconnect (each {} sec)\", getWebThingLabel(), reason,\n+                    HEALTH_CHECK_PERIOD.getSeconds());\n+        } else {\n+            logger.debug(\"WebThing {} is offline {}. Try reconnect (each {} sec)\", getWebThingLabel(), reason,\n+                    HEALTH_CHECK_PERIOD.getSeconds());\n+        }\n+    }\n+\n+    private @Nullable URI readWebThingURI() {\n+        var webThingConfiguration = getConfigAs(WebThingConfiguration.class);\n+        var webThingUriString = webThingConfiguration.webThingURI;\n+        if (webThingUriString == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"webThing uri has not been set\");\n+        } else {\n+            try {\n+                return URI.create(webThingUriString);\n+            } catch (Exception illegalURIException) {", "originalCommit": "53b5a86f72abf1c38e6115f647ede4689fe00f57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0MTgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r550441814", "bodyText": "When is this exception raised? If I see correctly it is not cought anywhere. That means your binding will crash if it is raised.", "author": "fwolter", "createdAt": "2020-12-31T09:40:30Z", "path": "bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/client/ConsumedThingImpl.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.webthing.internal.client;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.openhab.binding.webthing.internal.client.dto.Property;\n+import org.openhab.binding.webthing.internal.client.dto.WebThingDescription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The implementation of the client-side Webthing representation. This is based on HTTP. Bindings to alternative\n+ * application protocols such as CoAP may be defined in the future (which may be implemented by a another class)\n+ *\n+ * @author Gregor Roth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConsumedThingImpl implements ConsumedThing {\n+    private static final Duration DEFAULT_PING_PERIOD = Duration.ofSeconds(80);\n+    private final Logger logger = LoggerFactory.getLogger(ConsumedThingImpl.class);\n+    private final URI webThingURI;\n+    private final Gson gson = new Gson();\n+    private final HttpClient httpClient;\n+    private final Consumer<String> errorHandler;\n+    private final WebThingDescription description;\n+    private final WebSocketConnection websocketDownstream;\n+    private final AtomicBoolean isOpen = new AtomicBoolean(true);\n+\n+    /**\n+     * constructor\n+     *\n+     * @param webSocketClient the web socket client to use\n+     * @param httpClient the http client to use\n+     * @param webThingURI the identifier of a WebThing resource\n+     * @param executor executor to use\n+     * @param errorHandler the error handler\n+     * @throws IOException it the WebThing can not be connected\n+     */\n+    ConsumedThingImpl(WebSocketClient webSocketClient, HttpClient httpClient, URI webThingURI,\n+            ScheduledExecutorService executor, Consumer<String> errorHandler) throws IOException {\n+        this(httpClient, webThingURI, executor, errorHandler, WebSocketConnectionFactory.instance(webSocketClient));\n+    }\n+\n+    /**\n+     * constructor\n+     *\n+     * @param httpClient the http client to use\n+     * @param webthingUrl the identifier of a WebThing resource\n+     * @param executor executor to use\n+     * @param errorHandler the error handler\n+     * @param webSocketConnectionFactory the Websocket connectino fctory to be used\n+     * @throws IOException if the WebThing can not be connected\n+     */\n+    ConsumedThingImpl(HttpClient httpClient, URI webthingUrl, ScheduledExecutorService executor,\n+            Consumer<String> errorHandler, WebSocketConnectionFactory webSocketConnectionFactory) throws IOException {\n+        this(httpClient, webthingUrl, executor, errorHandler, webSocketConnectionFactory, DEFAULT_PING_PERIOD);\n+    }\n+\n+    /**\n+     * constructor\n+     *\n+     * @param httpClient the http client to use\n+     * @param webthingUrl the identifier of a WebThing resource\n+     * @param executor executor to use\n+     * @param errorHandler the error handler\n+     * @param webSocketConnectionFactory the Websocket connectino fctory to be used\n+     * @param pingPeriod the ping period tothe the healthiness of the connection\n+     * @throws IOException if the WebThing can not be connected\n+     */\n+    ConsumedThingImpl(HttpClient httpClient, URI webthingUrl, ScheduledExecutorService executor,\n+            Consumer<String> errorHandler, WebSocketConnectionFactory webSocketConnectionFactory, Duration pingPeriod)\n+            throws IOException {\n+        this.webThingURI = webthingUrl;\n+        this.httpClient = httpClient;\n+        this.errorHandler = errorHandler;\n+        this.description = new DescriptionLoader(httpClient).loadWebthingDescription(webThingURI,\n+                Duration.ofSeconds(20));\n+\n+        // opens a websocket downstream to be notified if a property value will be changed\n+        this.websocketDownstream = webSocketConnectionFactory.create(this.getEventStreamUri(), executor, this::onError,\n+                pingPeriod);\n+    }\n+\n+    private Optional<URI> getPropertyUri(String propertyName) {\n+        var optionalProperty = description.getProperty(propertyName);\n+        if (optionalProperty.isPresent()) {\n+            var propertyDescription = optionalProperty.get();\n+            for (var link : propertyDescription.links) {\n+                if ((link.rel != null) && (link.href != null) && link.rel.equals(\"property\")) {\n+                    return Optional.of(webThingURI.resolve(link.href));\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private URI getEventStreamUri() {\n+        for (var link : this.description.links) {\n+            var href = link.href;\n+            if (href != null) {\n+                var rel = Optional.ofNullable(link.rel).orElse(\"<undefined>\");\n+                if (rel.equals(\"alternate\")) {\n+                    return URI.create(href);\n+                }\n+            }\n+        }\n+        throw new IllegalStateException(\"WebThing \" + webThingURI\n+                + \" does not support websocket uri. WebThing description: \" + this.description);", "originalCommit": "53b5a86f72abf1c38e6115f647ede4689fe00f57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MTE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r550461178", "bodyText": "The exception will be thrown if the webthing does not support a web socket uri (which should). I have changed the exception type to IOException which will be handled inside the WebThingHandler class. Thanks for the hint", "author": "grro", "createdAt": "2020-12-31T11:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0MTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0MjUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r550442522", "bodyText": "Syntactical sugar.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(() -> scan(isBackground), 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.submit(() -> scan(isBackground));", "author": "fwolter", "createdAt": "2020-12-31T09:43:51Z", "path": "bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/discovery/WebthingDiscoveryService.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.webthing.internal.discovery;\n+\n+import static org.openhab.binding.webthing.internal.WebThingBindingConstants.MDNS_SERVICE_TYPE;\n+import static org.openhab.binding.webthing.internal.WebThingBindingConstants.THING_TYPE_UID;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+import javax.jmdns.ServiceEvent;\n+import javax.jmdns.ServiceInfo;\n+import javax.jmdns.ServiceListener;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.webthing.internal.client.DescriptionLoader;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.transport.mdns.MDNSClient;\n+import org.openhab.core.scheduler.Scheduler;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * WebThing discovery service based on mDNS. Refer https://iot.mozilla.org/wot/#web-thing-discovery\n+ *\n+ * @author Gregor Roth - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"webthingdiscovery.mdns\")\n+public class WebthingDiscoveryService extends AbstractDiscoveryService implements ServiceListener {\n+    private static final Duration FOREGROUND_SCAN_TIMEOUT = Duration.ofMillis(200);\n+    public static final String ID = \"id\";\n+    public static final String SCHEMAS = \"schemas\";\n+    public static final String WEB_THING_URI = \"webThingURI\";\n+    private final Logger logger = LoggerFactory.getLogger(WebthingDiscoveryService.class);\n+    private final DescriptionLoader descriptionLoader;\n+    private final MDNSClient mdnsClient;\n+    private final List<Future<Set<DiscoveryResult>>> runningDiscoveryTasks = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configProperties the config props\n+     * @param mdnsClient the underlying mDNS client\n+     */\n+    @Activate\n+    public WebthingDiscoveryService(@Nullable Map<String, Object> configProperties, @Reference MDNSClient mdnsClient,\n+            @Reference Scheduler executor, @Reference HttpClientFactory httpClientFactory) {\n+        super(30);\n+        this.mdnsClient = mdnsClient;\n+        this.descriptionLoader = new DescriptionLoader(httpClientFactory.getCommonHttpClient());\n+        super.activate(configProperties);\n+        if (isBackgroundDiscoveryEnabled()) {\n+            mdnsClient.addServiceListener(MDNS_SERVICE_TYPE, this);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return Set.of(THING_TYPE_UID);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    protected void deactivate() {\n+        super.deactivate();\n+        mdnsClient.removeServiceListener(MDNS_SERVICE_TYPE, this);\n+    }\n+\n+    @Override\n+    public void serviceAdded(@NonNullByDefault({}) ServiceEvent serviceEvent) {\n+        considerService(serviceEvent);\n+    }\n+\n+    @Override\n+    public void serviceResolved(@NonNullByDefault({}) ServiceEvent serviceEvent) {\n+        considerService(serviceEvent);\n+    }\n+\n+    @Override\n+    public void serviceRemoved(@NonNullByDefault({}) ServiceEvent serviceEvent) {\n+        for (var discoveryResult : discoverWebThing(serviceEvent.getInfo())) {\n+            thingRemoved(discoveryResult.getThingUID());\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        mdnsClient.addServiceListener(MDNS_SERVICE_TYPE, this);\n+        startScan(true);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        mdnsClient.removeServiceListener(MDNS_SERVICE_TYPE, this);\n+    }\n+\n+    private void startScan(boolean isBackground) {\n+        scheduler.schedule(() -> scan(isBackground), 0, TimeUnit.SECONDS);", "originalCommit": "53b5a86f72abf1c38e6115f647ede4689fe00f57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0MzE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r550443141", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new HashMap<>(1);\n          \n          \n            \n                        Map<String, Object> properties = new HashMap<>(2);", "author": "fwolter", "createdAt": "2020-12-31T09:46:42Z", "path": "bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/discovery/WebthingDiscoveryService.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.webthing.internal.discovery;\n+\n+import static org.openhab.binding.webthing.internal.WebThingBindingConstants.MDNS_SERVICE_TYPE;\n+import static org.openhab.binding.webthing.internal.WebThingBindingConstants.THING_TYPE_UID;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+import javax.jmdns.ServiceEvent;\n+import javax.jmdns.ServiceInfo;\n+import javax.jmdns.ServiceListener;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.webthing.internal.client.DescriptionLoader;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.transport.mdns.MDNSClient;\n+import org.openhab.core.scheduler.Scheduler;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * WebThing discovery service based on mDNS. Refer https://iot.mozilla.org/wot/#web-thing-discovery\n+ *\n+ * @author Gregor Roth - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"webthingdiscovery.mdns\")\n+public class WebthingDiscoveryService extends AbstractDiscoveryService implements ServiceListener {\n+    private static final Duration FOREGROUND_SCAN_TIMEOUT = Duration.ofMillis(200);\n+    public static final String ID = \"id\";\n+    public static final String SCHEMAS = \"schemas\";\n+    public static final String WEB_THING_URI = \"webThingURI\";\n+    private final Logger logger = LoggerFactory.getLogger(WebthingDiscoveryService.class);\n+    private final DescriptionLoader descriptionLoader;\n+    private final MDNSClient mdnsClient;\n+    private final List<Future<Set<DiscoveryResult>>> runningDiscoveryTasks = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configProperties the config props\n+     * @param mdnsClient the underlying mDNS client\n+     */\n+    @Activate\n+    public WebthingDiscoveryService(@Nullable Map<String, Object> configProperties, @Reference MDNSClient mdnsClient,\n+            @Reference Scheduler executor, @Reference HttpClientFactory httpClientFactory) {\n+        super(30);\n+        this.mdnsClient = mdnsClient;\n+        this.descriptionLoader = new DescriptionLoader(httpClientFactory.getCommonHttpClient());\n+        super.activate(configProperties);\n+        if (isBackgroundDiscoveryEnabled()) {\n+            mdnsClient.addServiceListener(MDNS_SERVICE_TYPE, this);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return Set.of(THING_TYPE_UID);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    protected void deactivate() {\n+        super.deactivate();\n+        mdnsClient.removeServiceListener(MDNS_SERVICE_TYPE, this);\n+    }\n+\n+    @Override\n+    public void serviceAdded(@NonNullByDefault({}) ServiceEvent serviceEvent) {\n+        considerService(serviceEvent);\n+    }\n+\n+    @Override\n+    public void serviceResolved(@NonNullByDefault({}) ServiceEvent serviceEvent) {\n+        considerService(serviceEvent);\n+    }\n+\n+    @Override\n+    public void serviceRemoved(@NonNullByDefault({}) ServiceEvent serviceEvent) {\n+        for (var discoveryResult : discoverWebThing(serviceEvent.getInfo())) {\n+            thingRemoved(discoveryResult.getThingUID());\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        mdnsClient.addServiceListener(MDNS_SERVICE_TYPE, this);\n+        startScan(true);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        mdnsClient.removeServiceListener(MDNS_SERVICE_TYPE, this);\n+    }\n+\n+    private void startScan(boolean isBackground) {\n+        scheduler.schedule(() -> scan(isBackground), 0, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        startScan(false);\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        removeOlderResults(Instant.now().minus(Duration.ofMinutes(10)).toEpochMilli());\n+\n+        // stop running discovery tasks\n+        for (var future : runningDiscoveryTasks) {\n+            future.cancel(true);\n+            runningDiscoveryTasks.remove(future);\n+        }\n+        super.stopScan();\n+    }\n+\n+    /**\n+     * scans the network via mDNS\n+     *\n+     * @param isBackground true, if is background task\n+     */\n+    private void scan(boolean isBackground) {\n+        var serviceInfos = isBackground ? mdnsClient.list(MDNS_SERVICE_TYPE)\n+                : mdnsClient.list(MDNS_SERVICE_TYPE, FOREGROUND_SCAN_TIMEOUT);\n+        logger.debug(\"got {} mDNS entries\", serviceInfos.length);\n+\n+        // create discovery task for each detected service and process these in parallel to increase total\n+        // discovery speed\n+        for (var serviceInfo : serviceInfos) {\n+            var future = scheduler.submit(new DiscoveryTask(serviceInfo));\n+            runningDiscoveryTasks.add(future);\n+        }\n+\n+        // wait until all tasks are completed\n+        for (var future : runningDiscoveryTasks) {\n+            try {\n+                future.get(5, TimeUnit.MINUTES);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                logger.warn(\"discovering task {} terminated\", future);\n+            }\n+            runningDiscoveryTasks.remove(future);\n+        }\n+    }\n+\n+    private class DiscoveryTask implements Callable<Set<DiscoveryResult>> {\n+        private final ServiceInfo serviceInfo;\n+\n+        DiscoveryTask(ServiceInfo serviceInfo) {\n+            this.serviceInfo = serviceInfo;\n+        }\n+\n+        @Override\n+        public Set<DiscoveryResult> call() {\n+            var results = new HashSet<DiscoveryResult>();\n+            for (var discoveryResult : discoverWebThing(serviceInfo)) {\n+                results.add(discoveryResult);\n+                thingDiscovered(discoveryResult);\n+                logger.debug(\"WebThing '{}' (uri: {}, id: {}, schemas: {}) discovered\", discoveryResult.getLabel(),\n+                        discoveryResult.getProperties().get(WEB_THING_URI), discoveryResult.getProperties().get(ID),\n+                        discoveryResult.getProperties().get(SCHEMAS));\n+            }\n+            return results;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"DiscoveryTask{\" + \"serviceInfo=\" + serviceInfo + '}';\n+        }\n+    }\n+\n+    /**\n+     * convert the serviceInfo result of the mDNS scan to discovery results\n+     *\n+     * @param serviceInfo the service info\n+     * @return the associated discovery result\n+     */\n+    private Set<DiscoveryResult> discoverWebThing(ServiceInfo serviceInfo) {\n+        var discoveryResults = new HashSet<DiscoveryResult>();\n+\n+        if (serviceInfo.getHostAddresses().length > 0) {\n+            var host = serviceInfo.getHostAddresses()[0];\n+            var port = serviceInfo.getPort();\n+            var path = \"/\";\n+            if (Collections.list(serviceInfo.getPropertyNames()).contains(\"path\")) {\n+                path = serviceInfo.getPropertyString(\"path\");\n+                if (!path.endsWith(\"/\")) {\n+                    path = path + \"/\";\n+                }\n+            }\n+\n+            // There are two kinds of WebThing endpoints: Endpoints supporting a single WebThing as well as\n+            // endpoints supporting multiple WebThings.\n+            //\n+            // In the routine below the enpoint will be checked for single WebThings first, than for multiple\n+            // WebThings if a ingle WebTHing has not been found.\n+            // Furthermore, first it will be tried to connect the endpoint using https. If this fails, as fallback\n+            // plain http is used.\n+\n+            // check single WebThing path via https (e.g. https://192.168.0.23:8433/)\n+            var optionalDiscoveryResult = discoverWebThing(toURI(host, port, path, true));\n+            if (optionalDiscoveryResult.isPresent()) {\n+                discoveryResults.add(optionalDiscoveryResult.get());\n+            } else {\n+                // check single WebThing path via plain http (e.g. http://192.168.0.23:8433/)\n+                optionalDiscoveryResult = discoverWebThing(toURI(host, port, path, false));\n+                if (optionalDiscoveryResult.isPresent()) {\n+                    discoveryResults.add(optionalDiscoveryResult.get());\n+                } else {\n+                    // check multiple WebThing path via https (e.g. https://192.168.0.23:8433/0,\n+                    // https://192.168.0.23:8433/1,...)\n+                    outer: for (int i = 0; i < 50; i++) { // search 50 entries at maximum\n+                        optionalDiscoveryResult = discoverWebThing(toURI(host, port, path + i + \"/\", true));\n+                        if (optionalDiscoveryResult.isPresent()) {\n+                            discoveryResults.add(optionalDiscoveryResult.get());\n+                        } else if (i == 0) {\n+                            // check multiple WebThing path via plain http (e.g. http://192.168.0.23:8433/0,\n+                            // http://192.168.0.23:8433/1,...)\n+                            for (int j = 0; j < 50; j++) { // search 50 entries at maximum\n+                                optionalDiscoveryResult = discoverWebThing(toURI(host, port, path + j + \"/\", false));\n+                                if (optionalDiscoveryResult.isPresent()) {\n+                                    discoveryResults.add(optionalDiscoveryResult.get());\n+                                } else {\n+                                    break outer;\n+                                }\n+                            }\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return discoveryResults;\n+    }\n+\n+    private Optional<DiscoveryResult> discoverWebThing(URI uri) {\n+        try {\n+            var description = descriptionLoader.loadWebthingDescription(uri, Duration.ofSeconds(5));\n+\n+            var id = uri.getHost().replaceAll(\"\\\\W\", \"_\") + \"_\" + uri.getPort();\n+            if (uri.getPath().length() > 1) {\n+                id = id + \"_\" + uri.getPath().replaceAll(\"\\\\W\", \"\");\n+            }\n+\n+            var thingUID = new ThingUID(THING_TYPE_UID, id);\n+            Map<String, Object> properties = new HashMap<>(1);", "originalCommit": "53b5a86f72abf1c38e6115f647ede4689fe00f57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b11ceabd5639dac4584639320e7eb43ed6240f1", "url": "https://github.com/openhab/openhab-addons/commit/0b11ceabd5639dac4584639320e7eb43ed6240f1", "message": "Update bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/discovery/WebthingDiscoveryService.java\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2020-12-31T11:00:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MjA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r551582051", "bodyText": "You can run mvn license:format to update the year.", "author": "fwolter", "createdAt": "2021-01-04T21:35:06Z", "path": "bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/ChannelHandler.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project", "originalCommit": "28cc2419648fca4f49d2df2a2ab8709bb5912dd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcyNzk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9555#discussion_r551727957", "bodyText": "done", "author": "grro", "createdAt": "2021-01-05T05:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MjA1MQ=="}], "type": "inlineReview"}, {"oid": "8d2a1bcbb09b7465d7dcb358f927c5fb45c79699", "url": "https://github.com/openhab/openhab-addons/commit/8d2a1bcbb09b7465d7dcb358f927c5fb45c79699", "message": "initial check-in\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:52Z", "type": "commit"}, {"oid": "2508d0c1c97ec7cbe847cdf1d89bae2634dff017", "url": "https://github.com/openhab/openhab-addons/commit/2508d0c1c97ec7cbe847cdf1d89bae2634dff017", "message": "Update bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/WebThingHandler.java\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:53Z", "type": "commit"}, {"oid": "b7c362b0e4bcf2c882bd44a669131fb8f2068b3b", "url": "https://github.com/openhab/openhab-addons/commit/b7c362b0e4bcf2c882bd44a669131fb8f2068b3b", "message": "Update bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/discovery/WebthingDiscoveryService.java\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:53Z", "type": "commit"}, {"oid": "a275120602e048fcd129328a18ade779a6d9f9dd", "url": "https://github.com/openhab/openhab-addons/commit/a275120602e048fcd129328a18ade779a6d9f9dd", "message": "Update bundles/org.openhab.binding.webthing/src/main/java/org/openhab/binding/webthing/internal/discovery/WebthingDiscoveryService.java\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:54Z", "type": "commit"}, {"oid": "35f574a2393ee3705ff84f5ba2c550c15d9d1bf4", "url": "https://github.com/openhab/openhab-addons/commit/35f574a2393ee3705ff84f5ba2c550c15d9d1bf4", "message": "IllegalStateException replaced by IOException\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:54Z", "type": "commit"}, {"oid": "3ef77cf26deee8d0ad3f97177288361c5f78f44d", "url": "https://github.com/openhab/openhab-addons/commit/3ef77cf26deee8d0ad3f97177288361c5f78f44d", "message": "consider checkstyle findings\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:54Z", "type": "commit"}, {"oid": "3cf82d9126038c805b5f8ea1bc88cd90895369ad", "url": "https://github.com/openhab/openhab-addons/commit/3cf82d9126038c805b5f8ea1bc88cd90895369ad", "message": "consider checkstyle findings\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:55Z", "type": "commit"}, {"oid": "bc71376c441b21c9c31bf0331449828ae5bea1de", "url": "https://github.com/openhab/openhab-addons/commit/bc71376c441b21c9c31bf0331449828ae5bea1de", "message": "tailing spaces removed\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:55Z", "type": "commit"}, {"oid": "456a2d7f34b4cff00228cd2e2672639e034e3bcc", "url": "https://github.com/openhab/openhab-addons/commit/456a2d7f34b4cff00228cd2e2672639e034e3bcc", "message": "license header removed\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:56Z", "type": "commit"}, {"oid": "66519eb29553827b82daa28fd72e7619e4bc5b03", "url": "https://github.com/openhab/openhab-addons/commit/66519eb29553827b82daa28fd72e7619e4bc5b03", "message": "license header updated (year)\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:56Z", "type": "commit"}, {"oid": "7c26075adf4f882d984bed25fdcaa3f54dc16de5", "url": "https://github.com/openhab/openhab-addons/commit/7c26075adf4f882d984bed25fdcaa3f54dc16de5", "message": "Bugfix selecting the proper link in case of several \"alternate\" links. E.g. there may non-WebSocket \"alternate\" links such as links of mediaType text/html\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:57Z", "type": "commit"}, {"oid": "58812682ef5432c3cfa7a7316c1159844dbf649c", "url": "https://github.com/openhab/openhab-addons/commit/58812682ef5432c3cfa7a7316c1159844dbf649c", "message": "Bugfix support DecimaleType for Dimmer\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:57Z", "type": "commit"}, {"oid": "348100bf3fda20a76c9af2c22739e7fda60e2599", "url": "https://github.com/openhab/openhab-addons/commit/348100bf3fda20a76c9af2c22739e7fda60e2599", "message": "Bugfix: content type header is not set by performing PUT requests. It turned out that there are WebThing implementations that requires this header\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:57Z", "type": "commit"}, {"oid": "7330ab634cc990d9319cea862255e1fe9901035f", "url": "https://github.com/openhab/openhab-addons/commit/7330ab634cc990d9319cea862255e1fe9901035f", "message": "copyright header fixed\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:58Z", "type": "commit"}, {"oid": "7330ab634cc990d9319cea862255e1fe9901035f", "url": "https://github.com/openhab/openhab-addons/commit/7330ab634cc990d9319cea862255e1fe9901035f", "message": "copyright header fixed\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-14T10:51:58Z", "type": "forcePushed"}, {"oid": "813cc81a387fd57e808948adace7949a6fb5453d", "url": "https://github.com/openhab/openhab-addons/commit/813cc81a387fd57e808948adace7949a6fb5453d", "message": "json accept type header added. Some WebThing implementations seems to return html if accept type json is not set\n\nSigned-off-by: Gregor Roth <gregor.roth@web.de>", "committedDate": "2021-01-26T10:36:30Z", "type": "commit"}, {"oid": "4641f0960e6bfa99b3b9f0ed5a946cfee58c7462", "url": "https://github.com/openhab/openhab-addons/commit/4641f0960e6bfa99b3b9f0ed5a946cfee58c7462", "message": "Fix NonNull annotation import; add missing Jetty methods\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2021-04-11T17:37:30Z", "type": "commit"}]}