{"pr_number": 7189, "pr_title": "[alarmdecoder] Initial contribution", "pr_createdAt": "2020-03-18T16:16:21Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7189", "timeline": [{"oid": "bda7f27ac9e06c3232ed06a4d4623d0e06e49975", "url": "https://github.com/openhab/openhab-addons/commit/bda7f27ac9e06c3232ed06a4d4623d0e06e49975", "message": "[alarmdecoder] Initial commit of OH2 version\n\nSigned-off-by: Bob Adair <bob.github@att.net>\nAlso-by: Bill Forsyth (github: billfor)", "committedDate": "2020-03-25T20:07:13Z", "type": "commit"}, {"oid": "526f16ff6353858040787e3b376fa6d5cd20c2ca", "url": "https://github.com/openhab/openhab-addons/commit/526f16ff6353858040787e3b376fa6d5cd20c2ca", "message": "[alarmdecoder] Update pom.xml files\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-25T20:07:13Z", "type": "commit"}, {"oid": "bd2338a2a253257adeb8764a478430959d53cd16", "url": "https://github.com/openhab/openhab-addons/commit/bd2338a2a253257adeb8764a478430959d53cd16", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-25T20:07:13Z", "type": "commit"}, {"oid": "bd2338a2a253257adeb8764a478430959d53cd16", "url": "https://github.com/openhab/openhab-addons/commit/bd2338a2a253257adeb8764a478430959d53cd16", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-25T20:07:13Z", "type": "forcePushed"}, {"oid": "c0e92a4a86be44bdc06a397c9057f3d3d7983f8b", "url": "https://github.com/openhab/openhab-addons/commit/c0e92a4a86be44bdc06a397c9057f3d3d7983f8b", "message": "[alarmdecoder] Update to LRR msg parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-29T17:29:08Z", "type": "commit"}, {"oid": "c376c907d7f913bebbeb0d14d1574c6928bc9337", "url": "https://github.com/openhab/openhab-addons/commit/c376c907d7f913bebbeb0d14d1574c6928bc9337", "message": "[alarmdecoder] Update to KP msg parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-31T20:08:28Z", "type": "commit"}, {"oid": "f97e80b5dcb7e7977ca7f9e3a4f6cf0517b333a7", "url": "https://github.com/openhab/openhab-addons/commit/f97e80b5dcb7e7977ca7f9e3a4f6cf0517b333a7", "message": "[alarmdecoder] Don't update keypad channels on repeated messages\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-04T22:13:44Z", "type": "commit"}, {"oid": "1d72a334168728bd56c07aa1e928e58fa4d6c493", "url": "https://github.com/openhab/openhab-addons/commit/1d72a334168728bd56c07aa1e928e58fa4d6c493", "message": "[alarmdecoder] Update to README and thing-type.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-08T02:15:56Z", "type": "commit"}, {"oid": "7e9b18163906e36ac88e1caea8ce58e9933bd904", "url": "https://github.com/openhab/openhab-addons/commit/7e9b18163906e36ac88e1caea8ce58e9933bd904", "message": "[alarmdecoder] Minor clean-up\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-09T15:33:30Z", "type": "commit"}, {"oid": "99c6bb2b3edce8a2534d0d694d6c44daece8a175", "url": "https://github.com/openhab/openhab-addons/commit/99c6bb2b3edce8a2534d0d694d6c44daece8a175", "message": "[alarmdecoder] Move off of gnu.io for serial bridge\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-09T16:00:26Z", "type": "commit"}, {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "url": "https://github.com/openhab/openhab-addons/commit/79bce4d41c750de5b53188bb8694c9a7dfd3af25", "message": "[alarmdecoder] Flag write exceptions\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-10T18:21:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022327", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n          \n          \n            \n                protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);", "author": "cpmeister", "createdAt": "2020-04-11T05:50:24Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022338", "bodyText": "use it or lose it", "author": "cpmeister", "createdAt": "2020-04-11T05:50:38Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+\n+    public ADThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected abstract void initDeviceState();\n+\n+    public abstract void initChannelState();\n+\n+    /**\n+     * Notify handler that panel is in ready state so that any un-updated contact channels can be set to default\n+     * (closed).\n+     */\n+    public abstract void notifyPanelReady();\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} for AD handler\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE\n+                && getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.BRIDGE_OFFLINE) {\n+            initDeviceState();\n+\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            // thingOfflineNotify();", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4NjY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407086682", "bodyText": "Lost it. :-)", "author": "bobadair", "createdAt": "2020-04-11T17:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022543", "bodyText": "Why do you need these fields if you can just pull them from the config instance?", "author": "cpmeister", "createdAt": "2020-04-11T05:52:57Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    /** hostname for the alarmdecoder process */\n+    private @Nullable String tcpHostName = null;\n+    /** port for the alarmdecoder process */\n+    private int tcpPort;", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njc0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407086741", "bodyText": "Those were an artifact from the V1 code. Removed.", "author": "bobadair", "createdAt": "2020-04-11T17:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzA0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023046", "bodyText": "Why not just put this logic on line 92 so you can do away with the connectionSuccess variable?", "author": "cpmeister", "createdAt": "2020-04-11T05:59:25Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    /** hostname for the alarmdecoder process */\n+    private @Nullable String tcpHostName = null;\n+    /** port for the alarmdecoder process */\n+    private int tcpPort;\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            return;\n+        }\n+        tcpHostName = config.hostname;\n+        tcpPort = config.tcpPort;\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        boolean connectionSuccess = false;\n+\n+        try {\n+            disconnect(); // make sure we are disconnected\n+            writeException = false;\n+            if (tcpHostName != null && tcpPort > 0 && tcpPort < 65536) {\n+                socket = new Socket(tcpHostName, tcpPort);\n+                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n+                logger.debug(\"connected to {}:{}\", tcpHostName, tcpPort);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);\n+                connectionSuccess = true;\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"invalid hostname/tcpPort configured\");\n+            }\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", tcpHostName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", tcpHostName, tcpPort, e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(config.reconnect); // Possibly a retryable error. Try again later.\n+        }\n+\n+        // Start connection check job\n+        if (connectionSuccess) {\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407086767", "bodyText": "Good point. Done.", "author": "bobadair", "createdAt": "2020-04-11T17:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzIyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023225", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n          \n          \n            \n                private static final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "author": "cpmeister", "createdAt": "2020-04-11T06:01:55Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.KeypadConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.IntCommandMap;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KeypadHandler} is responsible for handling keypad messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(KeypadHandler.class);\n+\n+    private @NonNullByDefault({}) KeypadConfig config;\n+    private boolean singleAddress;\n+    private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023775", "bodyText": "You still need to handle a RefreshType command if possible.", "author": "cpmeister", "createdAt": "2020-04-11T06:09:16Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.LRRConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LRRHandler} is responsible for handling long range radio (LRR) messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(LRRHandler.class);\n+\n+    private @NonNullByDefault({}) LRRConfig config;\n+\n+    public LRRHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the supplied partition.\n+     * This is true is this handler's partition is 0 (all), the supplied partition is 0 (all), or if this handler's\n+     * partition matches the supplied partition.\n+     */\n+    public Boolean responsibleFor(final int partition) {\n+        return (config.partition == partition || config.partition == 0 || partition == 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(LRRConfig.class);\n+\n+        if (config.partition < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"LRR handler initializing for partition {}\", config.partition);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"LRR handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for RLL partition {}\", config.partition);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            initChannelState();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    @Override\n+    public void initChannelState() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // All channels are read-only, so ignore all commands.", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4OTg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407089881", "bodyText": "I thought about this, but the AD device mainly just passively listens on the panel's serial bus and passes along the messages it sees. There is no way to query it for state, as I would want to do when receiving a RefreshType command. So I thought it best to just ignore RefreshType along with all other commands.", "author": "bobadair", "createdAt": "2020-04-11T17:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MDM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407150353", "bodyText": "If there is no way to handle a RefreshType then I guess you can just ignore it.", "author": "cpmeister", "createdAt": "2020-04-12T05:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI0MDA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407240077", "bodyText": "Ok. Thanks. I'm open to suggestions, but I can't really thing of an appropriate REFRESH action that the AD would support.", "author": "bobadair", "createdAt": "2020-04-12T19:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024142", "bodyText": "you can remove this annotation, it serves no purpose here", "author": "cpmeister", "createdAt": "2020-04-11T06:13:56Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.osgi.service.component.annotations.Activate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    @Activate", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024196", "bodyText": "not even a refresh command?", "author": "cpmeister", "createdAt": "2020-04-11T06:14:33Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.RFZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RFZoneHandler} is responsible for handling wired zones (i.e. RFX messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RFZoneHandler.class);\n+\n+    private @NonNullByDefault({}) RFZoneConfig config;\n+\n+    public RFZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public Boolean responsibleFor(final int serial) {\n+        return (config.serial != null && config.serial.equals(serial));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RFZoneConfig.class);\n+\n+        if (config.serial == null || config.serial < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"RF Zone handler initializing for serial {}\", config.serial);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"RF Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for RF Zone {}\", config.serial);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            firstUpdateReceived.set(false);\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Set contact channel states to \"UNDEF\" at init time. The real states will be set either when the first message\n+     * arrives for the zone, or they will be set to \"CLOSED\" the first time the panel goes into the \"READY\" state.\n+     */\n+    @Override\n+    public void initChannelState() {\n+        UnDefType state = UnDefType.UNDEF;\n+        updateState(CHANNEL_RF_LOWBAT, state);\n+        updateState(CHANNEL_RF_SUPERVISION, state);\n+        updateState(CHANNEL_RF_LOOP1, state);\n+        updateState(CHANNEL_RF_LOOP2, state);\n+        updateState(CHANNEL_RF_LOOP3, state);\n+        updateState(CHANNEL_RF_LOOP4, state);\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        logger.trace(\"RF Zone handler for {} received panel ready notification.\", config.serial);\n+        if (firstUpdateReceived.compareAndSet(false, true)) {\n+            updateState(CHANNEL_RF_LOOP1, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP2, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP3, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP4, OpenClosedType.CLOSED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Does not accept any commands", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4OTg4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407089888", "bodyText": "Same as above.", "author": "bobadair", "createdAt": "2020-04-11T17:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024236", "bodyText": "remove", "author": "cpmeister", "createdAt": "2020-04-11T06:15:07Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.osgi.service.component.annotations.Activate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    @Activate\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // serialPort.disableReceiveFraming();\n+                // serialPort.disableReceiveThreshold();\n+\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                logger.debug(\"connected to serial port: {}\", serialDeviceName);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Serial device name not configured\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"port name not configured\");\n+            }\n+        } catch (PortInUseException e) {\n+            logger.debug(\"Cannot open serial port: {}, it is already in use\", serialDeviceName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Serial port already in use\");\n+        } catch (UnsupportedCommOperationException | IOException | IllegalStateException e) {\n+            logger.debug(\"Error connecting to serial port: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void disconnect() {\n+        logger.trace(\"Disconnecting\");\n+        if (serialPort != null) {\n+            logger.trace(\"Closing serial port\");\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        stopMsgReader();\n+\n+        if (reader != null) {\n+            logger.trace(\"Closing reader\");\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.info(\"IO Exception closing reader: {}\", e.getMessage());\n+            } finally {\n+                reader = null;\n+            }\n+        }\n+        if (writer != null) {\n+            logger.trace(\"Closing writer\");\n+            try {\n+                // writer.flush();", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024516", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(command);\n          \n          \n            \n                    return command;", "author": "cpmeister", "createdAt": "2020-04-11T06:18:57Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link ADCCommand} class represents an alarm decoder command, and contains the static methods and definitions\n+ * used to construct one. Not all supported AD commands are necessarily used by the current binding.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class ADCommand {\n+\n+    public static final String SPECIAL_KEY_1 = \"\\u0001\\u0001\\u0001\";\n+    public static final String SPECIAL_KEY_2 = \"\\u0002\\u0002\\u0002\";\n+    public static final String SPECIAL_KEY_3 = \"\\u0003\\u0003\\u0003\";\n+    public static final String SPECIAL_KEY_4 = \"\\u0004\\u0004\\u0004\";\n+    public static final String SPECIAL_KEY_5 = \"\\u0005\\u0005\\u0005\";\n+    public static final String SPECIAL_KEY_6 = \"\\u0006\\u0006\\u0006\";\n+    public static final String SPECIAL_KEY_7 = \"\\u0007\\u0007\\u0007\";\n+    public static final String SPECIAL_KEY_8 = \"\\u0008\\u0008\\u0008\";\n+\n+    // public static final String KEYPAD_COMMAND_CHARACTERS = \"0123456789*#<>\";\n+    public static final String KEYPAD_COMMAND_REGEX = \"^[0-9A-H*#<>]+$\";\n+\n+    private static final String TERM = \"\\r\\n\";\n+\n+    private static final String COMMAND_REBOOT = \"=\";\n+    private static final String COMMAND_CONFIG = \"C\";\n+    private static final String COMMAND_ZONE = \"L\";\n+    private static final String COMMAND_ERROR = \"E\";\n+    private static final String COMMAND_VERSION = \"V\";\n+    private static final String COMMAND_ADDRMSG = \"K\";\n+    private static final String COMMAND_ACKCRC = \"R\";\n+\n+    public final String command;\n+\n+    public ADCommand(String command) {\n+        this.command = command + TERM;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(command);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDYwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024606", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(message);\n          \n          \n            \n                    return message;", "author": "cpmeister", "createdAt": "2020-04-11T06:20:05Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Superclass for all Alarm Decoder protocol message types.\n+ * Includes code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADMessage {\n+\n+    protected static final Pattern SPLIT_REGEX = Pattern.compile(\"[^\\\\,\\\"]+|\\\"[^\\\"]*\\\"\");\n+\n+    /** string containing the original unparsed message */\n+    public final String message;\n+\n+    public ADMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(message);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:22:46Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link EXPMessage} class represents a parsed zone (EXP or REL) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class EXPMessage extends ADMessage {\n+\n+    // Example: !EXP:07,01,01\n+    // Example: !REL:12,01,01\n+\n+    /** Address number */\n+    public final int address;\n+\n+    /** Channel number */\n+    public final int channel;\n+\n+    /** Message data */\n+    public final int data;\n+\n+    public EXPMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"Multiple colons found in EXP message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        if (parts.size() != 3) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in EXP message\");\n+        }\n+\n+        try {\n+            address = Integer.parseInt(parts.get(0));\n+            channel = Integer.parseInt(parts.get(1));\n+            data = Integer.parseInt(parts.get(2));\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024817", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new IllegalArgumentException(\"Unable to parse integer in mapping\");\n          \n          \n            \n                            throw new IllegalArgumentException(\"Unable to parse integer in mapping\", e);", "author": "cpmeister", "createdAt": "2020-04-11T06:23:05Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    public IntCommandMap(String mappingString) throws IllegalArgumentException {\n+        commandMap = new HashMap<Integer, String>();\n+\n+        String mstring = mappingString.replace(\"POUND\", \"#\");\n+        String[] elements = mstring.split(\",\");\n+        for (String element : elements) {\n+            String[] kvPair = element.split(\"=\");\n+            if (kvPair.length != 2) {\n+                throw new IllegalArgumentException(\"Invalid key-value pair format\");\n+            }\n+\n+            Matcher matcher = validCommandPattern.matcher(kvPair[1]);\n+            if (!matcher.matches()) {\n+                throw new IllegalArgumentException(\"Invalid command characters in mapping\");\n+            }\n+\n+            try {\n+                commandMap.put(Integer.parseInt(kvPair[0]), kvPair[1]);\n+            } catch (NumberFormatException e) {\n+                throw new IllegalArgumentException(\"Unable to parse integer in mapping\");", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n          \n          \n            \n                private static final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "author": "cpmeister", "createdAt": "2020-04-11T06:23:21Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDk0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:24:08Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNTAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407025035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:25:28Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+\n+        if (parts.size() == 4) {\n+            reportCode = parts.get(3);\n+        } else {\n+            reportCode = \"\";\n+        }\n+\n+        try {\n+            int p = 0;\n+            try {\n+                p = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                p = Integer.parseInt(parts.get(1), 16);\n+            }\n+            partition = p;\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407025074", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:26:02Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link RFXMessage} class represents a parsed RF zone (RFX) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFXMessage extends ADMessage {\n+\n+    // Example: !RFX:0180036,80\n+\n+    public static final int BIT_LOWBAT = 0x02;\n+    public static final int BIT_SUPER = 0x04;\n+    public static final int BIT_LOOP3 = 0x10;\n+    public static final int BIT_LOOP2 = 0x20;\n+    public static final int BIT_LOOP4 = 0x40;\n+    public static final int BIT_LOOP1 = 0x80;\n+\n+    /** Address serial number */\n+    public final int serial;\n+\n+    /** Message data */\n+    public final int data;\n+\n+    public RFXMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"Multiple colons found in RFX message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        if (parts.size() != 2) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in RFX message\");\n+        }\n+\n+        try {\n+            serial = Integer.parseInt(parts.get(0));\n+            data = Integer.parseInt(parts.get(1), 16);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "url": "https://github.com/openhab/openhab-addons/commit/310488e29c2265cef1367c2bf3a4ef30a4a853ae", "message": "[alarmdecoder] Address review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-11T17:58:43Z", "type": "commit"}, {"oid": "dbd1f70710e0ef73f0aecb9684bd9fbc3c01c0b5", "url": "https://github.com/openhab/openhab-addons/commit/dbd1f70710e0ef73f0aecb9684bd9fbc3c01c0b5", "message": "[alarmdecoder] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-11T20:17:15Z", "type": "commit"}, {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "url": "https://github.com/openhab/openhab-addons/commit/72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "message": "[alarmdecoder] Doc update\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-11T20:42:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MDU3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407150577", "bodyText": "couldn't this have been checked in the initialize method instead?", "author": "cpmeister", "createdAt": "2020-04-12T05:53:34Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            if (config.hostname != null && config.tcpPort > 0 && config.tcpPort < 65536) {", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410598060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Boolean responsibleFor(final int address, final int channel) {\n          \n          \n            \n                public boolean responsibleFor(final int address, final int channel) {", "author": "cpmeister", "createdAt": "2020-04-18T03:51:48Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public Boolean responsibleFor(final int address, final int channel) {", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODIwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410598209", "bodyText": "use or lose", "author": "cpmeister", "createdAt": "2020-04-18T03:52:12Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // serialPort.disableReceiveFraming();\n+                // serialPort.disableReceiveThreshold();", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMDEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410730132", "bodyText": "The original V1 code using gnu.io (RXTX) called these here, but org.eclipse.smarthome.io.transport.serial does not seem to provide them for some reason. I assume they default to off? I removed them and added a different comment as a reminder.", "author": "bobadair", "createdAt": "2020-04-18T18:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTgzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410599836", "bodyText": "Shouldn't his logic be in the initialize method?", "author": "cpmeister", "createdAt": "2020-04-18T03:55:59Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMzA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410733085", "bodyText": "Maybe. I moved it, but I'm hoping that we can get rid of it in 3.0 since the new serial library update. I added a comment to that effect. See openhab/openhab-core/#1426", "author": "bobadair", "createdAt": "2020-04-18T18:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410599893", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-04-18T03:56:07Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMzUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410733503", "bodyText": "I don't know. That depends on whether or not serial ports can be dynamically added/removed on a system. I thought it was safer to leave it in connect().", "author": "bobadair", "createdAt": "2020-04-18T18:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwMzc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410803774", "bodyText": "Since the name of the port is configured by the user beforehand it should be expected that the serial port exists and is available at the time of handler initialization. The binding should fail-fast with regards to configuration errors otherwise you are wasting the user's time.", "author": "cpmeister", "createdAt": "2020-04-19T03:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMDI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411020247", "bodyText": "Ok. I moved it.", "author": "bobadair", "createdAt": "2020-04-19T23:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMTQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410601497", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    commandMap = new HashMap<Integer, String>();\n          \n          \n            \n                    commandMap = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-04-18T03:59:59Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    public IntCommandMap(String mappingString) throws IllegalArgumentException {\n+        commandMap = new HashMap<Integer, String>();", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603096", "bodyText": "You should override the .equals(Object obj) method instead of overloading.", "author": "cpmeister", "createdAt": "2020-04-18T04:04:13Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public int getZone() {\n+        return numericCode;\n+    }\n+\n+    /**\n+     * Returns a string containing the keypad text\n+     */\n+    public String getText() {\n+        return new String(alphaMessage);\n+    }\n+\n+    /**\n+     * Returns the value of an individual bit in the status field\n+     *\n+     * @param bit status field bit to test\n+     * @return true if bit is 1, false if bit is 0\n+     */\n+    public boolean getStatus(int bit) {\n+        int v = (status >> bit) & 0x1;\n+        return (v == 0) ? false : true;\n+    }\n+\n+    /**\n+     * Returns true if the READY status bit is set\n+     */\n+    public boolean panelClear() {\n+        return ((status & (1 << BIT_READY)) != 0);\n+    }\n+\n+    /**\n+     * Returns a string containing the address mask of the message in hex\n+     */\n+    public String getAddressMask() {\n+        return rawData.substring(3, 11);\n+    }\n+\n+    /**\n+     * Returns an int containing the address mask of the message\n+     */\n+    public int getIntAddressMask() {\n+        return Integer.parseInt(getAddressMask(), 16);\n+    }\n+\n+    /**\n+     * Compares two KeypadMessage objects\n+     *\n+     * @param other KeypadMessage to compare against\n+     * @return true if messages are equal, false if other is null or messages are not equal\n+     */\n+    public boolean equals(@Nullable KeypadMessage other) {", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzI4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(alphaMessage);\n          \n          \n            \n                    return alphaMessage;", "author": "cpmeister", "createdAt": "2020-04-18T04:04:43Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public int getZone() {\n+        return numericCode;\n+    }\n+\n+    /**\n+     * Returns a string containing the keypad text\n+     */\n+    public String getText() {\n+        return new String(alphaMessage);", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603725", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (parts.size() == 4) {\n          \n          \n            \n                        reportCode = parts.get(3);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        reportCode = \"\";\n          \n          \n            \n                    }\n          \n          \n            \n                    reportCode = parts.size() == 4 ? parts.get(3) : \"\";", "author": "cpmeister", "createdAt": "2020-04-18T04:05:50Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+\n+        if (parts.size() == 4) {\n+            reportCode = parts.get(3);\n+        } else {\n+            reportCode = \"\";\n+        }", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410607801", "bodyText": "Please make sure to set the thread as daemon.", "author": "cpmeister", "createdAt": "2020-04-18T04:15:33Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczOTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410739074", "bodyText": "Done.", "author": "bobadair", "createdAt": "2020-04-18T19:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzgwMQ=="}], "type": "inlineReview"}, {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "url": "https://github.com/openhab/openhab-addons/commit/3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "message": "[alarmdecoder] Address review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-18T19:07:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwMjM1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410802355", "bodyText": "You should specify the Charset that these streams should use.\nThe default charset varies from system to system so it is better to specify it yourself instead of using the default.", "author": "cpmeister", "createdAt": "2020-04-19T03:19:26Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNDEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410804136", "bodyText": "This logic should be abstracted into the ADBridgeHandler. The ADBridgeHandler should be responsible for opening and closing the input/output streams leaving the subclasses only having to handle sending and parsing messages.", "author": "cpmeister", "createdAt": "2020-04-19T03:31:55Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null || config.serialPort.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"no serial port configured\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        // Exit if no identifiers exist to work around possible library bug. May not be needed in 3.0.\n+        Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+        if (!serialPortIdentifiers.findAny().isPresent()) {\n+            logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+            return;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // Note: The V1 code called disableReceiveFraming() and disableReceiveThreshold() here\n+\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                logger.debug(\"connected to serial port: {}\", serialDeviceName);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk5MzAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410993030", "bodyText": "It's actually the other way around. The ADBridgeHandler class contains all of the message sending, receiving, and parsing, and the subclasses (IPBridgeHandler & SerialBridgeHandler) contain mostly the IO setup, tear-down, retry and monitoring logic for their specific type of communication. The lines you indicate are shared between the two, and so could be abstracted out, but I wasn't sure it was really worth the effort given that they are wrapped in common exception handling, etc., along with the more subclass-specific connection setup code.", "author": "bobadair", "createdAt": "2020-04-19T21:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410806323", "bodyText": "There is nothing the user could do about this even if you informed him. I suggest changing the logging level to debug.", "author": "cpmeister", "createdAt": "2020-04-19T03:47:23Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3MzU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410973554", "bodyText": "Well, at least for now, I would really like users to be warned of any parse errors so that they can report the problem. Otherwise there may be silent failures in some cases which we won't know about. Do you think it would make sense to leave it at INFO for now and bump it down to DEBUG later? Or I can bump it up to WARN for now if you would rather reserve INFO level.", "author": "bobadair", "createdAt": "2020-04-19T19:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4OTk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414789967", "bodyText": "If this is something that should be reported, I would suggest to include that in the message (e.e. \"This is a bug and should be reported\") and increase to WARN", "author": "J-N-K", "createdAt": "2020-04-24T18:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410808825", "bodyText": "Right now you have this designed such that the bridge searches out handlers that should process a given message. This requires the bridge to have knowledge of all of the ADHandler subclasses and also a two step approach:\n\nBridge must identify which handlers could handle a message.\nBridge then passes on message to handlers found in step 1\n\nI think it would be simpler if instead you just send the message to all of the handlers and let the handlers decide whether or not they want to handle it. This allows the bridge to be ignorant of the types of handlers as well as possibly allowing the bridge to be ignorant of the message type as well. Also instead of each handler having to implement 2 methods (one to judge if it can handle the message and another to actually handle it), each handler would only have to implement a single method which optionally handles the message.", "author": "cpmeister", "createdAt": "2020-04-19T04:05:09Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        // Notify appropriate KeypadHandlers\n+        Collection<KeypadHandler> handlers = findKeypadHandlers(kpm.getIntAddressMask());\n+        for (KeypadHandler handler : handlers) {\n+            handler.handleUpdate(kpm);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        ZoneHandler handler = findZoneHandler(expm.address, expm.channel);\n+        if (handler != null) {\n+            handler.handleUpdate(expm.data);\n+        }\n+\n+        if (discovery && discoveryService != null) {\n+            discoveryService.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        RFZoneHandler handler = findRFZoneHandler(rfxm.serial);\n+        if (handler != null) {\n+            handler.handleUpdate(rfxm.data);\n+        }\n+\n+        if (discovery && discoveryService != null) {\n+            discoveryService.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        // Notify appropriate LRRHandlers\n+        Collection<LRRHandler> handlers = findLRRHandlers(lrrm.partition);\n+        for (LRRHandler handler : handlers) {\n+            handler.handleUpdate(lrrm);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify all child thing handlers that the alarm panel is in the ready state. Since there is no way to poll, all\n+     * channels are initialized into the UNDEF state. This method is called when there is reason to assume that there\n+     * are no faulted zones, because the alarm panel is in state READY. Zone handlers that have not yet received updates\n+     * can then set their contact states to CLOSED. Only executes the first time panel is ready after bridge\n+     * connect/reconnect.\n+     */\n+    private void notifyChildHandlersPanelReady() {\n+        if (!panelReadyReceived) {\n+            panelReadyReceived = true;\n+            logger.trace(\"Notifying child handlers that panel is in ready state\");\n+\n+            // Notify child zone handlers by calling notifyPanelReady() for each\n+            for (Thing thing : getThing().getThings()) {\n+                if (thing.getHandler() instanceof ZoneHandler || thing.getHandler() instanceof RFZoneHandler) {\n+                    ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+                    if (handler != null) {\n+                        handler.notifyPanelReady();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the ZoneHandler for the given address and channel, or null if no handler exists and is initialized.\n+     */\n+    private @Nullable ZoneHandler findZoneHandler(int address, int channel) {", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMDI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411000279", "bodyText": "Yeah, I'll admit I don't love the way this works at the moment. I'm not sure I really like the idea of sending every message to every handler either, though, although it would probably eliminate a lot of code.  The AD protocol can be very chatty, especially with keypad messages which it seems to send every few seconds. I'd rather not hit every zone/rfzone handler with every keypad message, since there can be a lot of both. Sending each message to every handler of the correct type may be ok, but that would still require maintaining or generating a list of the child handlers of each type. Originally I was planning on registering all of the child handlers in maps in the bridge so that look-ups would be very efficient, but that seemed complex and error-prone, especially given the address mask comparisons necessary for finding the appropriate keypad or lrr handler for a given message.\nGiven a choice, I would rather not mess with this for now, since it works well enough, and come up with a better scheme later.", "author": "bobadair", "createdAt": "2020-04-19T21:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNTY5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411805698", "bodyText": "Ok. I had some time today, so I rewrote this part of the code. The bridge now sends messages to all child handlers of the correct type, and they decide in their handleUpdate(ADMessage) methods whether or not they should act on them. I'll merge it in to this branch after a bit more testing.", "author": "bobadair", "createdAt": "2020-04-21T01:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwOTM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410809389", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-19T04:09:12Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public boolean responsibleFor(final int address, final int channel) {\n+        return (config.address != null && config.channel != null && config.address.equals(address)\n+                && config.channel.equals(channel));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(ZoneConfig.class);\n+\n+        if (config.address == null || config.channel == null || config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n+\n+        String id = zoneID(config.address, config.channel);\n+        updateProperty(PROPERTY_ID, id); // set representation property used by discovery\n+\n+        initDeviceState();\n+        logger.trace(\"Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for Zone {},{}\", config.address, config.channel);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            firstUpdateReceived.set(false);\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Set contact channel state to \"UNDEF\" at init time. The real state will be set either when the first message\n+     * arrives for the zone, or it should be set to \"CLOSED\" the first time the panel goes into the \"READY\" state.\n+     */\n+    @Override\n+    public void initChannelState() {\n+        UnDefType state = UnDefType.UNDEF;\n+        updateState(CHANNEL_CONTACT, state);\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        logger.trace(\"Zone handler for {},{} received panel ready notification.\", config.address, config.channel);\n+        if (firstUpdateReceived.compareAndSet(false, true)) {\n+            updateState(CHANNEL_CONTACT, OpenClosedType.CLOSED);\n+        }\n+", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwOTczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410809739", "bodyText": "please put static fields before non-static fields", "author": "cpmeister", "createdAt": "2020-04-19T04:12:06Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410810085", "bodyText": "How would you know this is correct if you are given a hexadecimal number that doesn't have any letters in it?", "author": "cpmeister", "createdAt": "2020-04-19T04:14:26Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+        reportCode = parts.size() == 4 ? parts.get(3) : \"\";\n+\n+        try {\n+            int p = 0;\n+            try {\n+                p = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                p = Integer.parseInt(parts.get(1), 16);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0Nzk2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410947969", "bodyText": "Looking through the docs again, I think this field is unlikely to ever be a hex number. However, if it were, I believe it would have a 0x prefix. There is equivalent code in the keypad message parser, which comes from the V1 binding.", "author": "bobadair", "createdAt": "2020-04-19T17:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk1OTg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410959846", "bodyText": "I could not find precisely what the protocol specs say about that field. The specs don't even say it's an integer, but the example they are giving is:\n\"Event Data:\nThis is either the user number of the person performing the action or the zone that was bypassed.\"\nhttp://www.alarmdecoder.com/wiki/index.php/Protocol#Format_5\nI don't know, might be safest to treat it as a string? (Sorry, I don't receive LRR messages on my system, so I don't have any example messages).", "author": "berndpfrommer", "createdAt": "2020-04-19T18:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2NzczNA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410967734", "bodyText": "Thanks @berndpfrommer. Yes, the AD protocol spec wasn't too much help. From looking at the SIA DC-05-1999.09 document (pp. 5-8) it seems clear that zone and user are both integers, but there is no clear indication as to what number system the AD would use to send them other than the example in there docs which appears to be decimal. Maybe @LuckyMallari would have some input on this?\nUsing a string could work as well if we can't come up with a definitive answer.  BTW - I've been planning to add another channel to the lrr thing that provides the whole LRR message payload as a string for better backward compatibility with the V1 binding, but I thought I would do that after this initial submission was merged.", "author": "bobadair", "createdAt": "2020-04-19T18:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3NTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411875752", "bodyText": "Thanks @berndpfrommer. Yes, the AD protocol spec wasn't too much help. From looking at the SIA DC-05-1999.09 document (pp. 5-8) it seems clear that zone and user are both integers, but there is no clear indication as to what number system the AD would use to send them other than the example in there docs which appears to be decimal. Maybe @LuckyMallari would have some input on this?\nUsing a string could work as well if we can't come up with a definitive answer. BTW - I've been planning to add another channel to the lrr thing that provides the whole LRR message payload as a string for better backward compatibility with the V1 binding, but I thought I would do that after this initial submission was merged.\n\nSorry for being inactive on the thread.. busy with stuff ;) Had to dig from my old posts, but here's some info:\nhttps://www.openhab.org/addons/bindings/alarmdecoder1/\nLRR format from Alarm Decoder is:\n\n!LRR:<data>,<partition>,<event>\n\nand\nBecause <data> could be anything, it cannot be tied to a particular item as opposed to item bindings such as Contacts mentioned above. Instead, the entire message is sent to the binding.\n\n!LRR:<entiremessage>\n\nNow, if you look at the history story of the page, it has not been updated since 2013, so my comments are still correct.\nI am still using the AD binding v1, and still works flawlessly at the time of this writing. Here are some same LRR messages captured from my Vista20P:\n!SER2SOCK Connected\n!SER2SOCK SERIAL_CONNECTED\n##1\n!Sending.done\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n#1\n!Sending.done\n!RFX:0746846,80\n#\n!Sending.done\n1\n!RFX:0746846,00\n!Sending.done\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n#2\n!Sending.done\n[0101050100000000----],008,[f70000ff1008050c0c020000000000],\"ARMED ***AWAY***You                                                                              may exit now\"\n!LRR:000,1,ARM_AWAY\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!RFX:0322328,84\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!LRR:003,1,OPEN\n!Sending.done\n!Sending.done\n!LRR:000,1,ARM_STAY\n[0011030100000000----],008,[f70000ff1008038c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!LRR:003,1,OPEN\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[0011030100000000----],008,[f70000ff1008038c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!LRR:003,1,ARM_STAY\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!LRR:002,1,OPEN\n!Sending.done\n!LRR:002,1,ARM_STAY\n[0011030100000000----],008,[f70000ff1008038c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!RFX:0702437,84\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You may exit now\"\n!Sending.done\n!Sending.done\n!Sending..done\n!RFX:0638432,80\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     Ready to Arm  \"\n!RFX:0638432,00\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     Ready to Arm  \"\n!LRR:002,1,OPEN\n\nHere's how to interpret the LRR messages:\n\n!LRR:000,1,ARM_AWAY - I simply sent # 2 (which is same as hitting # 2 on keypad. This means the system was Armed (away), but it is 000 because there is no user. In my OH rules, I treat 000 as \"system\" user, which means an arm was invoked without using a PIN (like doing a # 2) from keypad.\n!LRR:002,1,OPEN - Disarmed by User 2\n!LRR:003,1,ARM_STAY - Armed stay by user 3. This is when you hit PIN then Stay (in Vista20P keypads, this is 3). For example, if user 3 pin code is 1234, then you get this by hitting 12343 on keypad.\n!LRR:00,1,OPEN - Disarmed by User 3\n\nLRR Event Types can be retrieved here\nNote that LRR events will need to be enabled by user on the alarm itself. For example, for OPEN to show up in LRR, OPEN reports should be enabled (field *65)\nYou need to\n\nFilter (or switch/case) events such as OPEN/ARM_AWAY/ARM_STAY and treat the field as USER\n\nI just dont have enough free time to test which events are user events and which are system/partition events\nBut to quickly answer your question,  Data field are always INTEGERS", "author": "LuckyMallari", "createdAt": "2020-04-21T05:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412316536", "bodyText": "Thanks @LuckyMallari ! That is great info. So we can assume that data and partition will always be decimal integers. I've removed the hex parsing code that @cpmeister originally commented on, and also added your LRR messages to the test data I'm using.\nDo you know what determines whether the LRR messages will be of the format in your data or the \"CID\" format mentioned in the current protocol docs (e.g. \"!LRR:012,1,CID_1441,ff\")? The parsing code will work with either, so I only ask out of curiosity, and maybe for purposes of documentation. I see there is an AD firmware capability called \"L2 - Long range radio messages (!LRR) with CID reporting format\", so I've been assuming it is related to firmware version and/or configuration.", "author": "bobadair", "createdAt": "2020-04-21T16:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM1MTE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412351141", "bodyText": "I thought I read someplace that LRR is always in Ademco Contact ID format (CID) regardless of the alarm setting for the phoneline.\nThe LRR seems to be another destination for reports. What is the benefit of LRR support in the binding if the same messages are sent to the keypad?", "author": "billfor", "createdAt": "2020-04-21T17:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}], "type": "inlineReview"}, {"oid": "931d565f12f9dce717c720505077d35cc30c53a1", "url": "https://github.com/openhab/openhab-addons/commit/931d565f12f9dce717c720505077d35cc30c53a1", "message": "[alarmdecoder] Address a few more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-19T17:48:09Z", "type": "commit"}, {"oid": "463495df30a70361a0618afa8e0d4f5e25c76791", "url": "https://github.com/openhab/openhab-addons/commit/463495df30a70361a0618afa8e0d4f5e25c76791", "message": "[alarmdecoder] Minor update to SerialBridgeHandler\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-19T23:47:16Z", "type": "commit"}, {"oid": "7491fe7def52bb535d9a6dc95348281bf7f21567", "url": "https://github.com/openhab/openhab-addons/commit/7491fe7def52bb535d9a6dc95348281bf7f21567", "message": "[alarmdecoder] Change message dispatching model\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T02:40:26Z", "type": "commit"}, {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "url": "https://github.com/openhab/openhab-addons/commit/9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "message": "[alarmdecoder] Update to LRR message parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T16:55:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412505290", "bodyText": "There has been a consensus among the addon maintainers to not allow use of @NonNullByDefault({}) on config fields. There are several alternatives that are allowed:\n\nmake field nullable\nwrap config in a non-null Optional field\nmake config field non-null by initializing to a default configuration.", "author": "cpmeister", "createdAt": "2020-04-21T21:30:10Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MjA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412562069", "bodyText": "Ok. Easy enough to fix. It's a bit silly, though, isn't it? Now in every handler we're just creating a dummy config object in the constructor that is then immediately thrown away and replaced with the real one in the initialize() method. The other alternatives seem even more annoying, though.", "author": "bobadair", "createdAt": "2020-04-21T23:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNjUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412616538", "bodyText": "A little silly yes, but it is preferable to NPEs. The null checker may have its annoyances but I've generally grown to like it since helps address possible concurrency issues as well as preventing NPEs. I just really wish it handled maps properly.", "author": "cpmeister", "createdAt": "2020-04-22T02:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNjMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412506323", "bodyText": "Please either make these fields nullable or provide a default value for them. Do not use @NonNullByDefault({}) in any config classes.", "author": "cpmeister", "createdAt": "2020-04-21T21:32:03Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n+\n+/**\n+ * The {@link ZoneConfig} class contains fields mapping thing configuration parameters for {@link ZoneHandler}.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneConfig {\n+    public @NonNullByDefault({}) Integer address;", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412566014", "bodyText": "Ok. Done for all of the config classes.", "author": "bobadair", "createdAt": "2020-04-21T23:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412509174", "bodyText": "Is this handled properly?", "author": "cpmeister", "createdAt": "2020-04-21T21:37:27Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412564713", "bodyText": "I believe so. This comes from the original V1 binding code, so it has been running happily lo these many years. :-) I expect that in the rare instances this field contains a hex number, it will be prefixed with 0x so that the first parseInt will reliably throw an exception.\nAs a side note... who comes up with a protocol where an integer represented as text may be either decimal or hex? Sigh.", "author": "bobadair", "createdAt": "2020-04-21T23:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODY3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412618670", "bodyText": "As a side note... who comes up with a protocol where an integer represented as text may be either decimal or hex? Sigh.\n\nProbably not one person, but a group of people that don't check or correct each-other's work managed by a manager that doesn't care.", "author": "cpmeister", "createdAt": "2020-04-22T02:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MzU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413183589", "bodyText": "LOL. That's the sort of thing that slips through as a team approaches a release deadline.", "author": "bobadair", "createdAt": "2020-04-22T17:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTY4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412515689", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-04-21T21:49:44Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The various message types that come from the ad2usb/ad2pi interface\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1)\n+ * @author Bob Adair - Re-factored and removed methods unused in OH2 binding\n+ */\n+public enum ADMsgType {", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4NDUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413184530", "bodyText": "This is done, even though the comment isn't flagged as \"Outdated\".", "author": "bobadair", "createdAt": "2020-04-22T17:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTY4OQ=="}], "type": "inlineReview"}, {"oid": "605e2624207e1806c20ed0e515fc447652ff5656", "url": "https://github.com/openhab/openhab-addons/commit/605e2624207e1806c20ed0e515fc447652ff5656", "message": "[alarmdecoder] Change null annotations in config classes\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T23:45:58Z", "type": "commit"}, {"oid": "33b706af73c1b1f0704478f9e386513dffcd2e15", "url": "https://github.com/openhab/openhab-addons/commit/33b706af73c1b1f0704478f9e386513dffcd2e15", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T23:50:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412707677", "bodyText": "Almost all of the of the handlers implement this method the same way, is it possible to have it refactored?", "author": "cpmeister", "createdAt": "2020-04-22T06:35:10Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private ZoneConfig config = new ZoneConfig();\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(ZoneConfig.class);\n+\n+        if (config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid address/channel setting\");\n+            return;\n+        }\n+        logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n+\n+        String id = zoneID(config.address, config.channel);\n+        updateProperty(PROPERTY_ID, id); // set representation property used by discovery\n+\n+        initDeviceState();\n+        logger.trace(\"Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {", "originalCommit": "33b706af73c1b1f0704478f9e386513dffcd2e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyODI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413128254", "bodyText": "Yeah, I had actually meant to do that. Done.", "author": "bobadair", "createdAt": "2020-04-22T16:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzY3Nw=="}], "type": "inlineReview"}, {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa", "url": "https://github.com/openhab/openhab-addons/commit/8a4be504a4c3bdf74696491625be23fbb73704fa", "message": "[alarmecoder] Move device state init to handler superclass\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T16:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5NDA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413194086", "bodyText": "It is very easy to get a NPE here if another thread sets reader to null in-between your null check and your readLine call.", "author": "cpmeister", "createdAt": "2020-04-22T17:53:23Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5ODAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413198038", "bodyText": "Please cache bridgeStatusInfo.getStatus() in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-04-22T17:58:51Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+\n+    public ADThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Initialize device state and set status for handler. Should be called at the end of initialize(). Calls\n+     * initChannelState() to initialize channels if setting status to ONLINE.\n+     */\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state\");\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Initialize channel states if necessary\n+     */\n+    public abstract void initChannelState();\n+\n+    /**\n+     * Notify handler that panel is in ready state so that any un-updated contact channels can be set to default\n+     * (closed).\n+     */\n+    public abstract void notifyPanelReady();\n+\n+    /**\n+     * Notify handler of a message from the AD via the bridge\n+     *\n+     * @param msg The ADMessage to handle\n+     */\n+    public abstract void handleUpdate(ADMessage msg);\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} for AD handler\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMDY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413200664", "bodyText": "For instance, the warnings on the following two lines can be fixed like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        socket = new Socket(config.hostname, config.tcpPort);\n          \n          \n            \n                        Socket socket = new Socket(config.hostname, config.tcpPort);\n          \n          \n            \n                        this.socket = socket;", "author": "cpmeister", "createdAt": "2020-04-22T18:02:22Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMjg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413202889", "bodyText": "This is how you fix the warning here. It can be annoying, but it makes the code much more thread-safe. You get the general idea though, so I'll let you fix the rest.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (msgReaderThread != null && !msgReaderThread.isAlive()) {\n          \n          \n            \n                    Thread msgReaderThread = this.msgReaderThread;\n          \n          \n            \n                    if (msgReaderThread != null && !msgReaderThread.isAlive()) {", "author": "cpmeister", "createdAt": "2020-04-22T18:05:33Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", config.hostname, config.tcpPort, e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(config.reconnect); // Possibly a retryable error. Try again later.\n+        }\n+    }\n+\n+    protected synchronized void connectionCheck() {\n+        logger.trace(\"Connection check job running\");\n+\n+        if (msgReaderThread != null && !msgReaderThread.isAlive()) {", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "url": "https://github.com/openhab/openhab-addons/commit/7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "message": "[alarmecoder] Fix all compiler warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T20:27:49Z", "type": "commit"}, {"oid": "4a7995bb300539cf99378c2a13fd93d4eb046ce1", "url": "https://github.com/openhab/openhab-addons/commit/4a7995bb300539cf99378c2a13fd93d4eb046ce1", "message": "[alarmecoder] Run spotless apply\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T21:02:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413337457", "bodyText": "This would solve the only warning left.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void reboot() {\n          \n          \n            \n                    if (bridge != null) {\n          \n          \n            \n                public void reboot() {\n          \n          \n            \n                    ADBridgeHandler bridge = this.bridge;\n          \n          \n            \n                    if (bridge != null) {", "author": "cpmeister", "createdAt": "2020-04-22T21:14:06Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.actions;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BridgeActions} class defines thing actions for alarmdecoder bridges.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@ThingActionsScope(name = \"alarmdecoder\")\n+@NonNullByDefault\n+public class BridgeActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BridgeActions.class);\n+\n+    private @Nullable ADBridgeHandler bridge;\n+\n+    public BridgeActions() {\n+        logger.trace(\"Alarm Decoder bridge actions service created\");\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ADBridgeHandler) {\n+            this.bridge = (ADBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridge;\n+    }\n+\n+    /**\n+     * Reboot thing action\n+     */\n+    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n+    public void reboot() {\n+        if (bridge != null) {", "originalCommit": "4a7995bb300539cf99378c2a13fd93d4eb046ce1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0NzA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413347092", "bodyText": "How did I miss that one? That was one of that warnings that wasn't showing up in Eclipse.\nFixed.", "author": "bobadair", "createdAt": "2020-04-22T21:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzQ1Nw=="}], "type": "inlineReview"}, {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "url": "https://github.com/openhab/openhab-addons/commit/09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "message": "[alarmecoder] Really fix all compiler warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T21:29:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4Mzg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414783866", "bodyText": "Does this pass the codestyle-check without warning?", "author": "J-N-K", "createdAt": "2020-04-24T18:37:41Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/AlarmDecoderDiscoveryService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AlarmDecoderDiscoveryService} handles discovery of devices as they are identified by the bridge handler.\n+ * Requests from the framework to startScan() are ignored, since no active scanning is possible.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AlarmDecoderDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(AlarmDecoderDiscoveryService.class);\n+\n+    private ADBridgeHandler bridgeHandler;", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwNDQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414904448", "bodyText": "Yes. There are no SCA warnings.", "author": "bobadair", "createdAt": "2020-04-24T22:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4Mzg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414785752", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n          \n          \n            \n                @RuleAction(label = \"Reboot\", description = \"Reboot the Alarm Decoder device\")", "author": "J-N-K", "createdAt": "2020-04-24T18:40:54Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.actions;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BridgeActions} class defines thing actions for alarmdecoder bridges.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@ThingActionsScope(name = \"alarmdecoder\")\n+@NonNullByDefault\n+public class BridgeActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BridgeActions.class);\n+\n+    private @Nullable ADBridgeHandler bridge;\n+\n+    public BridgeActions() {\n+        logger.trace(\"Alarm Decoder bridge actions service created\");\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ADBridgeHandler) {\n+            this.bridge = (ADBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridge;\n+    }\n+\n+    /**\n+     * Reboot thing action\n+     */\n+    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414787562", "bodyText": "I don't think this is a valid serial port. Wouldn't it be better to use @nullable here?", "author": "J-N-K", "createdAt": "2020-04-24T18:43:51Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/SerialBridgeConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link SerialBridgeConfig} class contains fields mapping thing configuration parameters for SerialBridgeHandler.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfig {\n+    public String serialPort = \"\";", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzMzEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414933108", "bodyText": "LOL. I just changed this from being a @nullable, It was previously annotated @NonNullByDefault({}). When I removed that, it caused too many null check warnings, so I went with this method instead. The handler will indicate a config error if it is unchanged.", "author": "bobadair", "createdAt": "2020-04-25T00:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg0NTA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r416845045", "bodyText": "IMO @Nullable would be the correct way, but we can leave it as-is.", "author": "J-N-K", "createdAt": "2020-04-28T18:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4ODkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414788929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ADMsgType mt = ADMsgType.getMsgType(msg);\n          \n          \n            \n                            ADMsgType msgType = ADMsgType.getMsgType(msg);\n          \n      \n    \n    \n  \n\nuse meaningful names where possible", "author": "J-N-K", "createdAt": "2020-04-24T18:46:13Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MDM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414790362", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    KeypadMessage kpm;\n          \n          \n            \n                    KeypadMessage keyPadMessage;\n          \n      \n    \n    \n  \n\nIt would be nice if you could check other occurences of two/three letter variable/field/parameter names and refactor them to something more readable.", "author": "J-N-K", "createdAt": "2020-04-24T18:48:46Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MzI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414793257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Thing thing : getThing().getThings()) {\n          \n          \n            \n                    getThing().getThings().forEach(thing -> {", "author": "J-N-K", "createdAt": "2020-04-24T18:53:55Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        notifyChildHandlers(kpm);\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(expm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(rfxm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(lrrm);\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify appropriate child thing handlers of an AD message by calling their handleUpdate() methods.\n+     *\n+     * @param msg message to forward to child handler(s)\n+     */\n+    private void notifyChildHandlers(ADMessage msg) {\n+        for (Thing thing : getThing().getThings()) {", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414795567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (Thing thing : getThing().getThings()) {\n          \n          \n            \n                            ADThingHandler handler = (ADThingHandler) thing.getHandler();\n          \n          \n            \n                            if (handler != null && (handler instanceof ZoneHandler || handler instanceof RFZoneHandler)) {\n          \n          \n            \n                                handler.notifyPanelReady();\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        getThing().getThings().stream().map(Thing::getHandler).filter(Objects::nonNull).forEach(handler -> {\n          \n          \n            \n                            if (handler instanceof ZoneHandler || handler instanceof RFZoneHandler) {\n          \n          \n            \n                                ((ADThingHandler) handler).notifyPanelReady();\n          \n          \n            \n                            }\n          \n          \n            \n                        });", "author": "J-N-K", "createdAt": "2020-04-24T18:57:54Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        notifyChildHandlers(kpm);\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(expm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(rfxm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(lrrm);\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify appropriate child thing handlers of an AD message by calling their handleUpdate() methods.\n+     *\n+     * @param msg message to forward to child handler(s)\n+     */\n+    private void notifyChildHandlers(ADMessage msg) {\n+        for (Thing thing : getThing().getThings()) {\n+            ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+            //@formatter:off\n+            if (handler != null && ((handler instanceof ZoneHandler && msg instanceof EXPMessage) ||\n+                                    (handler instanceof RFZoneHandler && msg instanceof RFXMessage) ||\n+                                    (handler instanceof KeypadHandler && msg instanceof KeypadMessage) ||\n+                                    (handler instanceof LRRHandler && msg instanceof LRRMessage))) {\n+                handler.handleUpdate(msg);\n+            }\n+            //@formatter:on\n+        }\n+    }\n+\n+    /**\n+     * Notify child thing handlers that the alarm panel is in the ready state. Since there is no way to poll, all\n+     * contact channels are initialized into the UNDEF state. This method is called when there is reason to assume that\n+     * there are no faulted zones, because the alarm panel is in state READY. Zone handlers that have not yet received\n+     * updates can then set their contact states to CLOSED. Only executes the first time panel is ready after bridge\n+     * connect/reconnect. Currently only notifies ZoneHandler and RFZoneHandler things.\n+     */\n+    private void notifyChildHandlersPanelReady() {\n+        if (!panelReadyReceived) {\n+            panelReadyReceived = true;\n+            logger.trace(\"Notifying child handlers that panel is in ready state\");\n+\n+            // Notify child zone handlers by calling notifyPanelReady() for each\n+            for (Thing thing : getThing().getThings()) {\n+                ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+                if (handler != null && (handler instanceof ZoneHandler || handler instanceof RFZoneHandler)) {\n+                    handler.notifyPanelReady();\n+                }\n+            }", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMDMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414830333", "bodyText": "Technically instanceof will only return true for a non-null object, so you don't need to filter them out explicitly.\n@J-N-K Also I think this suggested change is less readable than the original.\nIn addition, it is less performant and includes the overhead of generating anonymous lambda classes in the bytecode.\nLambdas are fun and useful, but you shouldn't treat them as the only trick in your toolbox otherwise you will try to use them for everything.", "author": "cpmeister", "createdAt": "2020-04-24T20:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNTUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414835516", "bodyText": "I think readability is probably a bit personal preference. But I\u2018m ok to leave it as-is.", "author": "J-N-K", "createdAt": "2020-04-24T20:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NjIxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414796215", "bodyText": "see above: does this pass the codestyle check?", "author": "J-N-K", "createdAt": "2020-04-24T18:59:00Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwNDY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414904684", "bodyText": "Yes. There are no SCA warnings.", "author": "bobadair", "createdAt": "2020-04-24T22:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NjIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5ODYxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414798611", "bodyText": "better set StandardCharsets.UTF8 instead of the UTF-8 string.", "author": "J-N-K", "createdAt": "2020-04-24T19:03:21Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5ODk4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414798985", "bodyText": "no need to add debug logging, thing status changes are already logged", "author": "J-N-K", "createdAt": "2020-04-24T19:04:00Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5OTE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414799193", "bodyText": "see above", "author": "J-N-K", "createdAt": "2020-04-24T19:04:22Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", config.hostname, config.tcpPort, e.getMessage());", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwMjUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414802525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);\n          \n          \n            \n                    updateState(CHANNEL_KP_READY, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_READY)));", "author": "J-N-K", "createdAt": "2020-04-24T19:10:34Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.KeypadConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.IntCommandMap;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KeypadHandler} is responsible for handling keypad messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadHandler extends ADThingHandler {\n+\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    private final Logger logger = LoggerFactory.getLogger(KeypadHandler.class);\n+\n+    private KeypadConfig config = new KeypadConfig();\n+    private boolean singleAddress;\n+    private @Nullable IntCommandMap intCommandMap;\n+    private @Nullable KeypadMessage previousMessage;\n+\n+    public KeypadHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(KeypadConfig.class);\n+\n+        if (config.addressMask < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid addressMask setting\");\n+            return;\n+        }\n+        singleAddress = (Integer.bitCount(config.addressMask) == 1);\n+\n+        try {\n+            intCommandMap = new IntCommandMap(config.commandMapping);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Invalid commmandMapping parameter supplied. Error: {}.\", e.getMessage());\n+            intCommandMap = null;\n+        }\n+\n+        logger.debug(\"Keypad handler initializing for address mask {}\", config.addressMask);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"Keypad handler finished initializing\");\n+    }\n+\n+    @Override\n+    public void initChannelState() {\n+        previousMessage = null;\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntCommandMap intCommandMap = this.intCommandMap;\n+\n+        if (channelUID.getId().equals(CHANNEL_KP_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = ((StringType) command).toString();\n+                handleKeypadCommand(cmd);\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_KP_INTCOMMAND)) {\n+            if (command instanceof Number) {\n+                int icmd = ((Number) command).intValue();\n+                if (intCommandMap != null) {\n+                    String cmd = intCommandMap.getCommand(icmd);\n+                    if (cmd != null) {\n+                        handleKeypadCommand(cmd);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleKeypadCommand(String command) {\n+        String cmd = command;\n+        if (cmd.length() > 0) {\n+            if (!config.sendCommands) {\n+                logger.info(\"Sending keypad commands is disabled. Enable using the sendCommands keypad parameter.\");\n+                return;\n+            }\n+\n+            // check that received command is valid\n+            Matcher matcher = VALID_COMMAND_PATTERN.matcher(cmd);\n+            if (!matcher.matches()) {\n+                logger.info(\"Invalid characters in command. Ignoring command: {}\", cmd);\n+                return;\n+            }\n+\n+            // Replace A-H in command string with special key strings\n+            cmd = cmd.replace(\"A\", ADCommand.SPECIAL_KEY_1);\n+            cmd = cmd.replace(\"B\", ADCommand.SPECIAL_KEY_2);\n+            cmd = cmd.replace(\"C\", ADCommand.SPECIAL_KEY_3);\n+            cmd = cmd.replace(\"D\", ADCommand.SPECIAL_KEY_4);\n+            cmd = cmd.replace(\"E\", ADCommand.SPECIAL_KEY_5);\n+            cmd = cmd.replace(\"F\", ADCommand.SPECIAL_KEY_6);\n+            cmd = cmd.replace(\"G\", ADCommand.SPECIAL_KEY_7);\n+            cmd = cmd.replace(\"H\", ADCommand.SPECIAL_KEY_8);\n+\n+            if (singleAddress) {\n+                sendCommand(ADCommand.addressedMessage(config.addressMask, cmd)); // send from keypad address\n+            } else {\n+                sendCommand(new ADCommand(cmd)); // send from AD address\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleUpdate(ADMessage msg) {\n+        // This will ignore a received message unless it is a KeypadMessage and either this handler's address mask is 0\n+        // (all), the message's address mask is 0 (all), or any bits in this handler's address mask match bits set in\n+        // the message's address mask.\n+        if (!(msg instanceof KeypadMessage)) {\n+            return;\n+        }\n+        KeypadMessage kpm = (KeypadMessage) msg;\n+        int addressMask = kpm.getIntAddressMask();\n+        if (!(((config.addressMask & addressMask) != 0) || config.addressMask == 0 || addressMask == 0)) {\n+            return;\n+        }\n+        logger.trace(\"Keypad handler for address mask {} received update: {}\", config.addressMask, kpm);\n+\n+        if (kpm.equals(previousMessage)) {\n+            return; // ignore repeated messages\n+        }\n+\n+        if (config.sendStar) {\n+            if (kpm.alphaMessage.contains(\"Hit * for faults\") || kpm.alphaMessage.contains(\"Press * to show faults\")\n+                    || kpm.alphaMessage.contains(\"Press * Key\")) {\n+                logger.debug(\"Sending * command to show faults.\");\n+                if (singleAddress) {\n+                    sendCommand(ADCommand.addressedMessage(config.addressMask, \"*\")); // send from keypad address\n+                } else {\n+                    sendCommand(new ADCommand(\"*\")); // send from AD address\n+                }\n+            }\n+        }\n+\n+        updateState(CHANNEL_KP_ZONE, new DecimalType(kpm.getZone()));\n+        updateState(CHANNEL_KP_TEXT, new StringType(kpm.alphaMessage));\n+\n+        updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwOTkyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414909927", "bodyText": "Nice. Didn't know about that method.", "author": "bobadair", "createdAt": "2020-04-24T23:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwMjUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMTUxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414811515", "bodyText": "After reading the code below, this seems to be an invalid value. Leave it out if that is correct", "author": "J-N-K", "createdAt": "2020-04-24T19:27:28Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/RFZoneConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link RFZoneConfig} class contains fields mapping thing configuration parameters for RFZoneHandler.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFZoneConfig {\n+    public int serial = -1;", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMDQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414920491", "bodyText": "Yes, I think that is a recent change. I initialize it to an invalid value (0 is potentially a valid value) rather than using a @nullable Integer to determine if it was not set by the user. As a general rule, anything weird like this in the code was done to get rid of  null annotation warnings. I think here it isn't strictly necessary because that parameter should be marked as required, but it still seemed like a good idea to have the code enforce it.", "author": "bobadair", "createdAt": "2020-04-24T23:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMTUxNQ=="}], "type": "inlineReview"}, {"oid": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "url": "https://github.com/openhab/openhab-addons/commit/96149fa6df32bfe52e14a63a7170e25596d7b9ca", "message": "[alarmecoder] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-24T23:51:50Z", "type": "commit"}, {"oid": "09de463dbcb35337177de90b967e8f4727c840ca", "url": "https://github.com/openhab/openhab-addons/commit/09de463dbcb35337177de90b967e8f4727c840ca", "message": "[alarmecoder] And a couple more\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-25T00:57:25Z", "type": "commit"}, {"oid": "1f30d0ba54af3e2013d2e179035187e840e5be72", "url": "https://github.com/openhab/openhab-addons/commit/1f30d0ba54af3e2013d2e179035187e840e5be72", "message": "[alarmecoder] Address more comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-26T00:09:51Z", "type": "commit"}, {"oid": "448031fecb6a720084a72c9f375ecac0fa1d615e", "url": "https://github.com/openhab/openhab-addons/commit/448031fecb6a720084a72c9f375ecac0fa1d615e", "message": "[alarmecoder] Address two comments I had missed\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-27T17:19:02Z", "type": "commit"}, {"oid": "490f62138745e3d9411b2f34a18d90ed64ecae47", "url": "https://github.com/openhab/openhab-addons/commit/490f62138745e3d9411b2f34a18d90ed64ecae47", "message": "[alarmecoder] README file updates\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-29T01:56:59Z", "type": "commit"}]}