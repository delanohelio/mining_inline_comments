{"pr_number": 8791, "pr_title": "[remoteopenhab] Remote openHAB binding - initial contribution", "pr_createdAt": "2020-10-18T14:37:42Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8791", "timeline": [{"oid": "023b3589c4f2f270c9a07e5f0771115b70942832", "url": "https://github.com/openhab/openhab-addons/commit/023b3589c4f2f270c9a07e5f0771115b70942832", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-18T15:52:08Z", "type": "forcePushed"}, {"oid": "e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "url": "https://github.com/openhab/openhab-addons/commit/e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-18T16:36:44Z", "type": "forcePushed"}, {"oid": "332da34cd131b5797a00aa8b48d8fd5110013422", "url": "https://github.com/openhab/openhab-addons/commit/332da34cd131b5797a00aa8b48d8fd5110013422", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-19T22:51:30Z", "type": "forcePushed"}, {"oid": "5e078b7c3c989058f6c29adce34e9ea5886df99b", "url": "https://github.com/openhab/openhab-addons/commit/5e078b7c3c989058f6c29adce34e9ea5886df99b", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-19T23:11:18Z", "type": "forcePushed"}, {"oid": "335f18e30dddff63ee31f101dd58b9cda870055a", "url": "https://github.com/openhab/openhab-addons/commit/335f18e30dddff63ee31f101dd58b9cda870055a", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-19T23:45:49Z", "type": "forcePushed"}, {"oid": "a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "url": "https://github.com/openhab/openhab-addons/commit/a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-20T12:34:43Z", "type": "forcePushed"}, {"oid": "d752da047f972112f9a3ac01e557acc150b205c8", "url": "https://github.com/openhab/openhab-addons/commit/d752da047f972112f9a3ac01e557acc150b205c8", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-20T12:46:46Z", "type": "forcePushed"}, {"oid": "35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "url": "https://github.com/openhab/openhab-addons/commit/35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-20T18:32:21Z", "type": "forcePushed"}, {"oid": "a95bdbfa2b6335e53d419720ad294a8c38078acc", "url": "https://github.com/openhab/openhab-addons/commit/a95bdbfa2b6335e53d419720ad294a8c38078acc", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-21T21:14:45Z", "type": "forcePushed"}, {"oid": "978d18e87a8056157d3ab3963b676727b1c8a744", "url": "https://github.com/openhab/openhab-addons/commit/978d18e87a8056157d3ab3963b676727b1c8a744", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-21T22:47:55Z", "type": "forcePushed"}, {"oid": "d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "url": "https://github.com/openhab/openhab-addons/commit/d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-22T11:27:34Z", "type": "forcePushed"}, {"oid": "b623bd4cc53f5fe6b10ef91ce0be832b67748003", "url": "https://github.com/openhab/openhab-addons/commit/b623bd4cc53f5fe6b10ef91ce0be832b67748003", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-22T18:27:58Z", "type": "forcePushed"}, {"oid": "3dc867e53fe095f9925c318f8b1963318874020d", "url": "https://github.com/openhab/openhab-addons/commit/3dc867e53fe095f9925c318f8b1963318874020d", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-23T20:12:45Z", "type": "commit"}, {"oid": "3dc867e53fe095f9925c318f8b1963318874020d", "url": "https://github.com/openhab/openhab-addons/commit/3dc867e53fe095f9925c318f8b1963318874020d", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-23T20:12:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296767", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    createChannels(items, false);\n          \n          \n            \n                    createChannels(List.of(item), false);", "author": "cpmeister", "createdAt": "2020-10-24T03:42:56Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359891", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296843", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    removeChannels(items);\n          \n          \n            \n                    removeChannels(List.of(item));", "author": "cpmeister", "createdAt": "2020-10-24T03:43:11Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359823", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300254", "bodyText": "In this circumstance it would be better to synchronize on the client itself rather than 'this'.\nAlso it seems wasteful to remove and re-add yourself as a listener every time you restart the client so I've adjusted the restartStreamingUpdates code accordingly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    synchronized (this) {\n          \n          \n            \n                        stopStreamingUpdates();\n          \n          \n            \n                        startStreamingUpdates();\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized(client){\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-10-24T03:53:05Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM0OTIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511349236", "bodyText": "Ok for the synchronized on the client.\nRegarding adding and removing the thing handler as listener, the idea is to be sure to not handle events coming from SSE after you d\u00e9cided to stop it. I prefer to keep this unchanged.", "author": "lolodomo", "createdAt": "2020-10-24T08:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMTc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511501799", "bodyText": "fine by me", "author": "cpmeister", "createdAt": "2020-10-24T18:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300644", "bodyText": "Might as well cover all your bases.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n          \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isDone()) {", "author": "cpmeister", "createdAt": "2020-10-24T03:54:21Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1MjM3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511352373", "bodyText": "Why should I use here a different \"pattern\" from you can already find in hundreds of bindings ?", "author": "lolodomo", "createdAt": "2020-10-24T09:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMjAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511502004", "bodyText": "Well if the prior job finished due to an error then isCancelled would return false, but isDone would return true. I figure if the intent is to restart the future if it is no longer running, isDone is more appropriate in that case.", "author": "cpmeister", "createdAt": "2020-10-24T18:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511303168", "bodyText": "Please cache channelState.toFullString() to a local variable.", "author": "cpmeister", "createdAt": "2020-10-24T04:01:46Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);\n+        } else {\n+            logger.trace(\"Updated remote item {} ignored because item type {} is unchanged\", newItem.name,\n+                    newItem.type);\n+        }\n+    }\n+\n+    private void updateChannelState(String itemName, @Nullable String stateType, String state) {\n+        Channel channel = getThing().getChannel(itemName);\n+        if (channel == null) {\n+            logger.trace(\"No channel for item {}\", itemName);\n+            return;\n+        }\n+        String acceptedItemType = channel.getAcceptedItemType();\n+        if (acceptedItemType == null) {\n+            logger.trace(\"Channel without accepted item type for item {}\", itemName);\n+            return;\n+        }\n+        if (!isLinked(channel.getUID())) {\n+            logger.trace(\"Unlinked channel {}\", channel.getUID());\n+            return;\n+        }\n+        State channelState = null;\n+        if (stateType == null && \"NULL\".equals(state)) {\n+            channelState = UnDefType.NULL;\n+        } else if (stateType == null && \"UNDEF\".equals(state)) {\n+            channelState = UnDefType.UNDEF;\n+        } else if (\"UnDef\".equals(stateType)) {\n+            switch (state) {\n+                case \"NULL\":\n+                    channelState = UnDefType.NULL;\n+                    break;\n+                case \"UNDEF\":\n+                    channelState = UnDefType.UNDEF;\n+                    break;\n+                default:\n+                    logger.debug(\"Invalid UnDef value {} for item {}\", state, itemName);\n+                    break;\n+            }\n+        } else if (acceptedItemType.startsWith(CoreItemFactory.NUMBER + \":\")) {\n+            // Item type Number with dimension\n+            if (checkStateType(itemName, stateType, \"Quantity\")) {\n+                List<Class<? extends State>> stateTypes = Collections.singletonList(QuantityType.class);\n+                channelState = TypeParser.parseState(stateTypes, state);\n+            }\n+        } else {\n+            switch (acceptedItemType) {\n+                case CoreItemFactory.STRING:\n+                    if (checkStateType(itemName, stateType, \"String\")) {\n+                        channelState = new StringType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.NUMBER:\n+                    if (checkStateType(itemName, stateType, \"Decimal\")) {\n+                        channelState = new DecimalType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.SWITCH:\n+                    if (checkStateType(itemName, stateType, \"OnOff\")) {\n+                        channelState = \"ON\".equals(state) ? OnOffType.ON : OnOffType.OFF;\n+                    }\n+                    break;\n+                case CoreItemFactory.CONTACT:\n+                    if (checkStateType(itemName, stateType, \"OpenClosed\")) {\n+                        channelState = \"OPEN\".equals(state) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                    }\n+                    break;\n+                case CoreItemFactory.DIMMER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.COLOR:\n+                    if (checkStateType(itemName, stateType, \"HSB\")) {\n+                        channelState = HSBType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.DATETIME:\n+                    if (checkStateType(itemName, stateType, \"DateTime\")) {\n+                        try {\n+                            channelState = new DateTimeType(ZonedDateTime.parse(state, FORMATTER_DATE));\n+                        } catch (DateTimeParseException e) {\n+                            logger.debug(\"Failed to parse date {} for item {}\", state, itemName);\n+                            channelState = null;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.LOCATION:\n+                    if (checkStateType(itemName, stateType, \"Point\")) {\n+                        channelState = new PointType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.IMAGE:\n+                    if (checkStateType(itemName, stateType, \"Raw\")) {\n+                        channelState = RawType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.PLAYER:\n+                    if (checkStateType(itemName, stateType, \"PlayPause\")) {\n+                        switch (state) {\n+                            case \"PLAY\":\n+                                channelState = PlayPauseType.PLAY;\n+                                break;\n+                            case \"PAUSE\":\n+                                channelState = PlayPauseType.PAUSE;\n+                                break;\n+                            default:\n+                                logger.debug(\"Unexpected value {} for item {}\", state, itemName);\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.ROLLERSHUTTER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"Item type {} is not yet supported\", acceptedItemType);\n+                    break;\n+            }\n+        }\n+        if (channelState != null) {\n+            updateState(channel.getUID(), channelState);\n+            logger.debug(\"updateState {} with {}\", channel.getUID(),\n+                    channelState.toFullString().length() < 50 ? channelState.toFullString()\n+                            : channelState.toFullString().substring(0, 50) + \"...\");", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359744", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305125", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-24T04:06:34Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTcwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359700", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305701", "bodyText": "I think this javadoc needs to be updated", "author": "cpmeister", "createdAt": "2020-10-24T04:07:45Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1NDc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511354767", "bodyText": "You see where was my initial inspiration :)", "author": "lolodomo", "createdAt": "2020-10-24T09:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTYyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359623", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ=="}], "type": "inlineReview"}, {"oid": "678d76ffde124beb440c5e418f35fc593b5a03e6", "url": "https://github.com/openhab/openhab-addons/commit/678d76ffde124beb440c5e418f35fc593b5a03e6", "message": "Review comment: List.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T08:43:56Z", "type": "commit"}, {"oid": "184d00e637e6dd7da2a314c15899a43ebaddd92e", "url": "https://github.com/openhab/openhab-addons/commit/184d00e637e6dd7da2a314c15899a43ebaddd92e", "message": "Review comment: synchronized on restClient rather than thingHandler\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T08:52:31Z", "type": "commit"}, {"oid": "b4de2cc7da1d3442ca277a69c47169b5e26a4bbe", "url": "https://github.com/openhab/openhab-addons/commit/b4de2cc7da1d3442ca277a69c47169b5e26a4bbe", "message": "Review comment: cache channelState.toFullString() and command.toFullString() to local variables\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T09:09:21Z", "type": "commit"}, {"oid": "e0f4e3f868826a1d85926fc598fb356d81a55e66", "url": "https://github.com/openhab/openhab-addons/commit/e0f4e3f868826a1d85926fc598fb356d81a55e66", "message": "Review comment: class description (thing handler)\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T09:17:10Z", "type": "commit"}, {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "url": "https://github.com/openhab/openhab-addons/commit/81f2e2faf5d54ee22f8c579d08c37ef95508e197", "message": "Switch the thing to a bridge to prepare the near future\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T09:59:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517799", "bodyText": "Please at least one line of JavaDoc.", "author": "kaikreuzer", "createdAt": "2020-10-24T21:47:19Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/RemoteopenhabChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ *", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522705", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T22:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517987", "bodyText": "Don't add the IP to the label, but make it the representation property instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n          \n          \n            \n                        String label = \"openHAB Server\";", "author": "kaikreuzer", "createdAt": "2020-10-24T21:49:47Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzExOA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523118", "bodyText": "If I do that, we will have no way to distinguish servers in the inbox.", "author": "lolodomo", "createdAt": "2020-10-24T22:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDk3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524970", "bodyText": "Here is how it looks now:\n\nWith your proposed change, all entries would have the same name \"openHAB server\" in the inbox.", "author": "lolodomo", "createdAt": "2020-10-24T23:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY0MTgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511641825", "bodyText": "Yes, that's exactly the idea - the label should describe the \"what\" it found and the presentation property allows to differentiate identical devices from each other.\n@ghys, it seems then that the presentation property is not yet considered that way in the Inbox. Shall I enter an issue for that?", "author": "kaikreuzer", "createdAt": "2020-10-25T20:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY1ODQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511658422", "bodyText": "@kaikreuzer : the representation property was not yet defined. With it added, I see the IP (representation property) on the second line.\n@ghys : don't loose your time ;)", "author": "lolodomo", "createdAt": "2020-10-25T22:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY1OTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511659074", "bodyText": "Done (simplified label + representation property added)", "author": "lolodomo", "createdAt": "2020-10-25T22:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n          \n          \n            \n                        logger.debug(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "author": "kaikreuzer", "createdAt": "2020-10-24T21:49:58Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522936", "bodyText": "Ok", "author": "lolodomo", "createdAt": "2020-10-24T22:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ=="}], "type": "inlineReview"}, {"oid": "761b31eb8795e521e507859e4b4b381028b4d905", "url": "https://github.com/openhab/openhab-addons/commit/761b31eb8795e521e507859e4b4b381028b4d905", "message": "Do not create discovery results for the local server\n\nImproved checking of the configuration setting validity at thing handler initialization\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:15:48Z", "type": "commit"}, {"oid": "9117730f3bd25575e616742680cf13c691bd5c70", "url": "https://github.com/openhab/openhab-addons/commit/9117730f3bd25575e616742680cf13c691bd5c70", "message": "Review comment: Item example changed in the documentation\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:45:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521311", "bodyText": "This can be a one liner in Java 11:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new HashMap<>(1);\n          \n          \n            \n                        properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);\n          \n          \n            \n                        Map<String, Object> properties = Map.of(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "author": "wborn", "createdAt": "2020-10-24T22:32:29Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        // Host address matching a local IP address are ignored\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()\n+                && !matchLocalIpAddress(service.getHostAddresses()[0])) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    private boolean matchLocalIpAddress(String serviceHostAddress) {\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        return localIpAddresses.contains(serviceHostAddress.replaceAll(\"\\\\[|\\\\]\", \"\"));\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n+                    url + restPath);\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523748", "bodyText": "Ok", "author": "lolodomo", "createdAt": "2020-10-24T23:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521556", "bodyText": "Can you turn the magic number 50 into a constant with a descriptive name? It's also used below on line 541.", "author": "wborn", "createdAt": "2020-10-24T22:36:06Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524009", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T23:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521784", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Item> items = new ArrayList<>();\n          \n          \n            \n                        items.add(newItem);\n          \n          \n            \n                        createChannels(items, false);\n          \n          \n            \n                        createChannels(List.of(newItem), false);", "author": "wborn", "createdAt": "2020-10-24T22:39:49Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                stopStreamingUpdates();\n+                startStreamingUpdates();\n+            }\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        createChannels(List.of(item), false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        removeChannels(List.of(item));\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524280", "bodyText": "I already changed 2 just below this morning but forgot this one.\nDone", "author": "lolodomo", "createdAt": "2020-10-24T23:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA=="}], "type": "inlineReview"}, {"oid": "1ca8e3aaf97d29bc08c126f607df1d09634e009a", "url": "https://github.com/openhab/openhab-addons/commit/1ca8e3aaf97d29bc08c126f607df1d09634e009a", "message": "Review comment: description added to class RemoteopenhabChannelTypeProvider\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:52:59Z", "type": "commit"}, {"oid": "ffa1344f0aa9e12540fd42e380ede6ca4add5a0c", "url": "https://github.com/openhab/openhab-addons/commit/ffa1344f0aa9e12540fd42e380ede6ca4add5a0c", "message": "Review comment: log level in the discovery service\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:56:11Z", "type": "commit"}, {"oid": "8f39558be54080a90cefaa3042ffe703724cd062", "url": "https://github.com/openhab/openhab-addons/commit/8f39558be54080a90cefaa3042ffe703724cd062", "message": "Review comment: change the label of the thing type\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:57:59Z", "type": "commit"}, {"oid": "ee33d72d2567c5025bb67ae13d9e9fc975899b2a", "url": "https://github.com/openhab/openhab-addons/commit/ee33d72d2567c5025bb67ae13d9e9fc975899b2a", "message": "Review comment: fix feature.xml\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:05:12Z", "type": "commit"}, {"oid": "f4b108bece16ef4579d391a62a9555f237fe469a", "url": "https://github.com/openhab/openhab-addons/commit/f4b108bece16ef4579d391a62a9555f237fe469a", "message": "Review comment: use Map.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:08:06Z", "type": "commit"}, {"oid": "41e50467840cd74bb1a4a6316b9a1e70bb5d8c4c", "url": "https://github.com/openhab/openhab-addons/commit/41e50467840cd74bb1a4a6316b9a1e70bb5d8c4c", "message": "Review comment: define MAX_STATE_SIZE_FOR_LOGGING\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:10:52Z", "type": "commit"}, {"oid": "d75c42e1eeee7aed1b2f4e56cd1dc412fd6e5293", "url": "https://github.com/openhab/openhab-addons/commit/d75c42e1eeee7aed1b2f4e56cd1dc412fd6e5293", "message": "Review comment: another List.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:13:51Z", "type": "commit"}, {"oid": "6a010df21d2d1863aac75c444c92979d21da911e", "url": "https://github.com/openhab/openhab-addons/commit/6a010df21d2d1863aac75c444c92979d21da911e", "message": "Review comment: Change thing configuration settings\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T10:27:59Z", "type": "commit"}, {"oid": "3ffc257e79da5c6fbdca81d1bcb699ed97c91fc9", "url": "https://github.com/openhab/openhab-addons/commit/3ffc257e79da5c6fbdca81d1bcb699ed97c91fc9", "message": "Take into consideration the read only property of an item\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T19:13:09Z", "type": "commit"}, {"oid": "d1d1c6d8e1a20bb3d7d9c0510ea8d4b014bde1f5", "url": "https://github.com/openhab/openhab-addons/commit/d1d1c6d8e1a20bb3d7d9c0510ea8d4b014bde1f5", "message": "Review comment: add the host as representation property and simplify the discovery result label\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T22:39:01Z", "type": "commit"}, {"oid": "d8fd8b3b3e7897940e8db33fc04288e3e03f7933", "url": "https://github.com/openhab/openhab-addons/commit/d8fd8b3b3e7897940e8db33fc04288e3e03f7933", "message": "Restore the use of Map.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T22:54:00Z", "type": "commit"}]}