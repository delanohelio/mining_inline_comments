{"pr_number": 7266, "pr_title": "[radiothermostat] RadioThermostat Binding - initial contribution", "pr_createdAt": "2020-03-31T23:41:59Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7266", "timeline": [{"oid": "a1434084ee8c2fa255d6a30491e0d694ba596748", "url": "https://github.com/openhab/openhab-addons/commit/a1434084ee8c2fa255d6a30491e0d694ba596748", "message": "RadioThermostat Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-03-31T23:42:38Z", "type": "commit"}, {"oid": "a1434084ee8c2fa255d6a30491e0d694ba596748", "url": "https://github.com/openhab/openhab-addons/commit/a1434084ee8c2fa255d6a30491e0d694ba596748", "message": "RadioThermostat Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-03-31T23:42:38Z", "type": "forcePushed"}, {"oid": "2082b2dcd6c05f2279fd1a1f24864683e1ec89c9", "url": "https://github.com/openhab/openhab-addons/commit/2082b2dcd6c05f2279fd1a1f24864683e1ec89c9", "message": "remove HTTPException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-01T01:09:18Z", "type": "commit"}, {"oid": "af112f4e3ace230ed6d4f4a711f42691d29f8c50", "url": "https://github.com/openhab/openhab-addons/commit/af112f4e3ace230ed6d4f4a711f42691d29f8c50", "message": "update ui before sending command; slow response time caused the ui values to bounce\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-01T20:10:51Z", "type": "commit"}, {"oid": "00343edcb5171c11b2a045d5b92a4cefb9809d0b", "url": "https://github.com/openhab/openhab-addons/commit/00343edcb5171c11b2a045d5b92a4cefb9809d0b", "message": "Add discovery service from billfor\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-08T04:42:34Z", "type": "commit"}, {"oid": "2c1ed9b00a0592d461de528284f4c9e2aa649688", "url": "https://github.com/openhab/openhab-addons/commit/2c1ed9b00a0592d461de528284f4c9e2aa649688", "message": "make hold function a switch and improve examples in readme\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-13T19:48:11Z", "type": "commit"}, {"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-13T19:56:53Z", "type": "commit"}, {"oid": "caae6836f8d203aa307aef064abd25b96e40b888", "url": "https://github.com/openhab/openhab-addons/commit/caae6836f8d203aa307aef064abd25b96e40b888", "message": "Merge branch '2.5.x' into RadioThermostat", "committedDate": "2020-04-13T19:58:46Z", "type": "commit"}, {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-19T18:41:08Z", "type": "commit"}, {"oid": "f43c452a8771ae1b8511ad663f436320d57dee55", "url": "https://github.com/openhab/openhab-addons/commit/f43c452a8771ae1b8511ad663f436320d57dee55", "message": "Merge branch '2.5.x' into RadioThermostat", "committedDate": "2020-04-19T20:19:13Z", "type": "commit"}, {"oid": "7f1529b28df74f821ce282bb979ebe2cb439f669", "url": "https://github.com/openhab/openhab-addons/commit/7f1529b28df74f821ce282bb979ebe2cb439f669", "message": "a couple more tweaks and increment pom version to 2.5.5\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T21:02:13Z", "type": "commit"}, {"oid": "5affb52dbd3e6f04fda75a460f8eb56e9990f799", "url": "https://github.com/openhab/openhab-addons/commit/5affb52dbd3e6f04fda75a460f8eb56e9990f799", "message": "some changes per review comments\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-20T22:16:58Z", "type": "commit"}, {"oid": "8e3b1043c659f2a34ccf6c4b1ee209745e2c77d9", "url": "https://github.com/openhab/openhab-addons/commit/8e3b1043c659f2a34ccf6c4b1ee209745e2c77d9", "message": "format runtime output\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-21T02:36:07Z", "type": "commit"}, {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "url": "https://github.com/openhab/openhab-addons/commit/2a7a732b9d9fb769b631ae8a46787f66c7292727", "message": "Cleanup 'advanced' tag attribute usage on channel-types in thing-types.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-04T16:00:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3NzgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428777839", "bodyText": "typo AND it's bad practice to throw unchecked (RuntimeException) Exceptions, because the compiler doesn't force you to catch the Exception. Better extend from Exception.", "author": "fwolter", "createdAt": "2020-05-21T16:46:15Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThemostatHttpException.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+/**\n+ * The {@link RadioThemostatHttpException} extends RuntimeException\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThemostatHttpException extends RuntimeException {", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4NzkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429287921", "bodyText": "@fwolter Thanks for reviewing this binding. I fixed everything that you flagged. Please take another look and let me know of any other problems.", "author": "mlobstein", "createdAt": "2020-05-22T14:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3NzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNTAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428805024", "bodyText": "Better use scheduleWithFixedDelay", "author": "fwolter", "createdAt": "2020-05-21T17:34:12Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNjA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428806068", "bodyText": "This will only work for Unix systems, better use isLoopback().", "author": "fwolter", "createdAt": "2020-05-21T17:36:10Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428808914", "bodyText": "Are you sure you need this fine grained trace logging or can you use a debugger instead?", "author": "fwolter", "createdAt": "2020-05-21T17:41:30Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.trace(\"Sending discovery broadcast\");\n+        // logger.trace(\"Considering {}\", ni.getName());\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.trace(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.trace(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.trace(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.trace(\"Match: {} \", response);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODczMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429288733", "bodyText": "Agreed. The code was contributed by someone else and I thought it was production ready. I switched all of these to use debug.", "author": "mlobstein", "createdAt": "2020-05-22T14:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxMzkwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428813909", "bodyText": "Are you sure you need this fine grained logging or can you use a debugger instead?", "author": "fwolter", "createdAt": "2020-05-21T17:50:12Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429289387", "bodyText": "removed", "author": "mlobstein", "createdAt": "2020-05-22T14:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxMzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODY0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428818643", "bodyText": "The initialize() method should return fast. No network interaction is allowed here. Schedule a task with scheduleWithFixedDelay or even better, use async HTTP client: https://www.eclipse.org/jetty/documentation/current/http-client-api.html#http-client-async", "author": "fwolter", "createdAt": "2020-05-21T17:58:39Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5MjM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429292371", "bodyText": "I moved the initial query calls out into a different method and call it the first time the refresh job runs.", "author": "mlobstein", "createdAt": "2020-05-22T14:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428818837", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-21T17:58:59Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxOTQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428819486", "bodyText": "Bindings should only log to error, when they hit a bug. The correct log level would be warn. You also don't need to log the stacktrace when the connection fails, so remove the last parameter.", "author": "fwolter", "createdAt": "2020-05-21T18:00:08Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTgxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r429289813", "bodyText": "Fixed and noted for future reference!", "author": "mlobstein", "createdAt": "2020-05-22T14:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxOTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMTA0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428821048", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-21T18:02:54Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMzc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428823789", "bodyText": "This will block one of openHAB's scheduler Threads. You should schedule another one-shot task with a 2 sec delay.", "author": "fwolter", "createdAt": "2020-05-21T18:07:57Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMzk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428823958", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-21T18:08:20Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428827175", "bodyText": "Consider doing this asynchronously (see Jetty link above), to not block a openHAB's scheduler Thread.", "author": "fwolter", "createdAt": "2020-05-21T18:14:30Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428827942", "bodyText": "Should be warn, see above.", "author": "fwolter", "createdAt": "2020-05-21T18:15:54Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428830324", "bodyText": "You don't need to trim, if you specify network-address in the context tag of the hostname parameter in the XML files. This ensures your parameter is always a valid network address.", "author": "fwolter", "createdAt": "2020-05-21T18:20:12Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjYwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428836603", "bodyText": "Jetty is the preferred library to perform HTTP requests: https://www.openhab.org/docs/developer/guidelines.html#default-libraries", "author": "fwolter", "createdAt": "2020-05-21T18:31:48Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzU0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428837541", "bodyText": "See Jetty hint above.", "author": "fwolter", "createdAt": "2020-05-21T18:33:43Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());\n+                logger.debug(\"thermostatResponse = {}\", response);\n+\n+                // Map the JSON response to the correct object\n+                if (DEFAULT_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+                } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+                } else if (MODEL_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+                } else if (NAME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n+                }\n+                \n+            } finally {\n+                IOUtils.closeQuietly(connection.getInputStream());\n+            }\n+\n+            if (result != null ) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            errorMsg = e.getMessage();\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal, String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\"+ cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        byte[] out = postJson.getBytes(StandardCharsets.US_ASCII);\n+        String output = null;\n+        String errorMsg = null;\n+        \n+        try {\n+            URL url = new URL(urlStr);\n+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428837882", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-21T18:34:28Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());\n+                logger.debug(\"thermostatResponse = {}\", response);\n+\n+                // Map the JSON response to the correct object\n+                if (DEFAULT_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+                } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+                } else if (MODEL_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+                } else if (NAME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n+                }\n+                \n+            } finally {\n+                IOUtils.closeQuietly(connection.getInputStream());\n+            }\n+\n+            if (result != null ) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            errorMsg = e.getMessage();\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal, String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\"+ cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        byte[] out = postJson.getBytes(StandardCharsets.US_ASCII);\n+        String output = null;\n+        String errorMsg = null;\n+        \n+        try {\n+            URL url = new URL(urlStr);\n+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n+            conn.setRequestProperty(\"Content-Type\", \"text/plain\");\n+            conn.setFixedLengthStreamingMode(out.length);\n+            conn.setRequestMethod(\"POST\");\n+            conn.setDoOutput(true);\n+            conn.connect();\n+            \n+            OutputStream os = conn.getOutputStream();\n+            os.write(postJson.getBytes(StandardCharsets.US_ASCII));\n+            \n+            BufferedReader br = new BufferedReader(new InputStreamReader(\n+                    (conn.getInputStream())));\n+            try {\n+                if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n+                    throw new RadioThemostatHttpException(\"HTTP response code: \" + conn.getResponseCode());\n+                }\n+                output = br.readLine();\n+                \n+            } catch (IOException | RadioThemostatHttpException e) {\n+                logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+            } finally {\n+                br.close();\n+                os.close();\n+                conn.disconnect();\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat command: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MjQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428842490", "bodyText": "You don't need these checks, since you already specified min/max in the XML file.", "author": "fwolter", "createdAt": "2020-05-21T18:43:11Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }", "originalCommit": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ae6d1b33204282462651a57d6f39944e646f582", "url": "https://github.com/openhab/openhab-addons/commit/2ae6d1b33204282462651a57d6f39944e646f582", "message": "Code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T14:35:49Z", "type": "commit"}, {"oid": "5c1f7e3d5a9300b060cf749a562e3096d2f2990c", "url": "https://github.com/openhab/openhab-addons/commit/5c1f7e3d5a9300b060cf749a562e3096d2f2990c", "message": "Remove Thread.sleep\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T15:03:02Z", "type": "commit"}, {"oid": "64f506f87220d02125ef1a4b39492d59b962de55", "url": "https://github.com/openhab/openhab-addons/commit/64f506f87220d02125ef1a4b39492d59b962de55", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-23T04:54:44Z", "type": "commit"}, {"oid": "f068374354480a0b4706a4d32cd057dee105946f", "url": "https://github.com/openhab/openhab-addons/commit/f068374354480a0b4706a4d32cd057dee105946f", "message": "Remove org.apache.commons.lang dependency\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-26T04:04:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNzExMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430737112", "bodyText": "There are some formatting errors. You can view them with mvn install -Dspotless.check.skip=false and fix them by running mvn spotless:apply.", "author": "fwolter", "createdAt": "2020-05-26T22:14:23Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -417,30 +399,24 @@ private Object getRadioThermostatData(String resource) {\n \n         try {\n             // Run the HTTP request and get the JSON response from the thermostat\n-            URL url = new URL(urlStr);\n-            URLConnection connection = url.openConnection();\n-\n-            try {\n-                String response = IOUtils.toString(connection.getInputStream());\n-                logger.debug(\"thermostatResponse = {}\", response);\n-\n-                // Map the JSON response to the correct object\n-                if (DEFAULT_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n-                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n-                } else if (RUNTIME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n-                } else if (MODEL_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n-                } else if (NAME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n-                }\n-                \n-            } finally {\n-                IOUtils.closeQuietly(connection.getInputStream());\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n             }\n-\n+                ", "originalCommit": "f068374354480a0b4706a4d32cd057dee105946f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430858826", "bodyText": "Done!", "author": "mlobstein", "createdAt": "2020-05-27T05:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNzExMg=="}], "type": "inlineReview"}, {"oid": "07232c4278f02a3944dd6dcf6ada367ba86b0794", "url": "https://github.com/openhab/openhab-addons/commit/07232c4278f02a3944dd6dcf6ada367ba86b0794", "message": "Add @NonNullByDefault annotations\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T03:48:12Z", "type": "commit"}, {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-05-27T03:57:29Z", "type": "commit"}, {"oid": "c32d4166f1233e2ef35be55b0b0e0b397fbe3450", "url": "https://github.com/openhab/openhab-addons/commit/c32d4166f1233e2ef35be55b0b0e0b397fbe3450", "message": "apply spotless and label name fixes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T04:23:14Z", "type": "commit"}, {"oid": "54603bd39d4550947734bb4e532bfa4ebabbebb6", "url": "https://github.com/openhab/openhab-addons/commit/54603bd39d4550947734bb4e532bfa4ebabbebb6", "message": "Merge branch '2.5.x' into RadioThermostat", "committedDate": "2020-05-27T04:24:19Z", "type": "commit"}, {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "url": "https://github.com/openhab/openhab-addons/commit/b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "message": "Temp value needs to have decimal places\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T19:09:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODQ0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431488447", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> scheduledFuture = null;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> scheduledFuture = null;", "author": "cpmeister", "createdAt": "2020-05-27T22:56:19Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431488673", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.", "author": "cpmeister", "createdAt": "2020-05-27T22:56:57Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyODM5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431528396", "bodyText": "I'm not sure I understand where it should be specified.", "author": "mlobstein", "createdAt": "2020-05-28T01:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAyNDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432024103", "bodyText": "There are several different constructors for String, just use one that allows you to specify the charset like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    String response = new String(packet.getData());\n          \n          \n            \n                                    String response = new String(packet.getData(), StandardCharsets.UTF_8);", "author": "cpmeister", "createdAt": "2020-05-28T18:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NDExMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432044112", "bodyText": "Is this an issue for the other bindings that do discovery as well? It seems like only Feican specifies it?\nroot@Ratbert2:/mnt/d/openhab/openhab2-addons/bundles# egrep -Re 'new String.*packet.getData' *\norg.openhab.binding.feican/src/main/java/org/openhab/binding/feican/internal/FeicanDiscoveryService.java:                    new String(packet.getData(), 0, packet.getLength() - 1, StandardCharsets.UTF_8));\norg.openhab.binding.globalcache/src/main/java/org/openhab/binding/globalcache/internal/discovery/MulticastListener.java:        String beacon = (new String(packet.getData())).trim();\norg.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LutronMcastBridgeDiscoveryService.java:            String data = new String(packet.getData(), packet.getOffset(), packet.getLength(),\norg.openhab.binding.miele/src/main/java/org/openhab/binding/miele/internal/handler/MieleBridgeHandler.java:                                String event = new String(packet.getData());\norg.openhab.binding.milight/src/main/java/org/openhab/binding/milight/internal/handler/BridgeV3Handler.java:                final String received = new String(packet.getData());\norg.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java:                        String response = new String(packet.getData());", "author": "billfor", "createdAt": "2020-05-28T18:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MzczOA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432053738", "bodyText": "I think that is because you are searching for String(packet.getData() which I'm pretty sure a lot bindings don't use that exact text", "author": "cpmeister", "createdAt": "2020-05-28T18:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432055947", "bodyText": "But yes, this would be an issue with other bindings as well. But the default charset is usually ok since it is US_ASCII or UTF-8, it only becomes a problem when running on machines with vastly different locales like arabic or chinese.", "author": "cpmeister", "createdAt": "2020-05-28T19:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1Nzg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432057885", "bodyText": "@bobadair, one of them is Lutron.", "author": "billfor", "createdAt": "2020-05-28T19:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyMDA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432120054", "bodyText": "one of them is Lutron\n\nThanks Bill. I checked that file in the Lutron binding, and it actually does specify the US_ASCII charset. It just does it on the next line. :-)\n            String data = new String(packet.getData(), packet.getOffset(), packet.getLength(),\n                    StandardCharsets.US_ASCII);", "author": "bobadair", "createdAt": "2020-05-28T20:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTExOA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431489118", "bodyText": "use it or lose it", "author": "cpmeister", "createdAt": "2020-05-27T22:58:12Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n+                // .withProperty(RadioThermostatBindingConstants.PROPERTY_UUID, uuid)", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575481", "bodyText": "gone", "author": "mlobstein", "createdAt": "2020-05-28T04:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431490167", "bodyText": "just use an if statement here instead.", "author": "cpmeister", "createdAt": "2020-05-27T23:01:25Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTU0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575542", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-05-28T04:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431490880", "bodyText": "Don't forget to catch JsonSyntaxException", "author": "cpmeister", "createdAt": "2020-05-27T23:03:23Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTU3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575577", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-05-28T04:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491004", "bodyText": "Please catch specific exceptions", "author": "cpmeister", "createdAt": "2020-05-27T23:03:46Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575869", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-05-28T04:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491483", "bodyText": "so you only care about the last url and ip that your find and discard the rest?", "author": "cpmeister", "createdAt": "2020-05-27T23:05:17Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyODg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431528878", "bodyText": "Yes, the discovery message has several lines of output. I only care about the line that has \"location\" in it. The value will be the thermostat's IP address.", "author": "mlobstein", "createdAt": "2020-05-28T01:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491974", "bodyText": "I assume it is supposed to be this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n          \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label)\n          \n          \n            \n                                  .withRepresentationProperty(RadioThermostatBindingConstants.PROPERTY_IP)", "author": "cpmeister", "createdAt": "2020-05-27T23:06:29Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575919", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-05-28T04:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NjI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431496297", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Double temperature = new Double(0);\n          \n          \n            \n                private Double temperature = 0d;", "author": "cpmeister", "createdAt": "2020-05-27T23:19:33Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/json/RadioThermostatJsonResponse.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.json;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link RadioThermostatJsonResponse} is responsible for storing\n+ * the data from the thermostat 'tstat' JSON response\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatJsonResponse {\n+\n+    @SerializedName(\"temp\")\n+    private Double temperature = new Double(0);", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NTcwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431575700", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-05-28T04:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NjI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431498807", "bodyText": "It doesn't appear as if the discovery service is in any way tied to the ThingHandler instance. I also don't think there should be multiple discovery services either, so you should just make your RadioThermostatDiscoveryService a osgi service instead of initialize it here.\nPlease add this above your RadioThermostatDiscoveryService class:\n@Component(immediate=true, service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n\nthen remove all RadioThermostatDiscoveryService and ServiceRegistration logic from the RadioThrmostatHandlerFactory.", "author": "cpmeister", "createdAt": "2020-05-27T23:27:23Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUzNjk1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431536959", "bodyText": "I did this based on example that I found that passed the httpClient from the HandlerFactory into the DiscoveryService. Is there a better way to pass httpClient?", "author": "mlobstein", "createdAt": "2020-05-28T01:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNTYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432035609", "bodyText": "My comments below will show exactly how to get an HttpClient into your DiscoveryService. It is the same way that you inject an HttpClient into this class.", "author": "cpmeister", "createdAt": "2020-05-28T18:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432047329", "bodyText": "Actually, per my latest comments, you don't need httpClient in your discovery service at all.", "author": "cpmeister", "createdAt": "2020-05-28T18:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432089124", "bodyText": "yep. I removed it completely.", "author": "mlobstein", "createdAt": "2020-05-28T19:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5OTI3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431499270", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n            \n          \n          \n            \n                public RadioThermostatDiscoveryService(HttpClient httpClient) {\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                \n          \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {", "author": "cpmeister", "createdAt": "2020-05-27T23:28:55Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NjM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431576340", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-05-28T04:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5OTI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431500116", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Override\n          \n          \n            \n                public void deactivate() {\n          \n          \n            \n                @Override\n          \n          \n            \n                @Deactivate\n          \n          \n            \n                public void deactivate() {", "author": "cpmeister", "createdAt": "2020-05-27T23:31:34Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {", "originalCommit": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3NjQ2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431576462", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-05-28T04:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDExNg=="}], "type": "inlineReview"}, {"oid": "92f5f2d7e684e6fa36204cd38ead286a4deb2e62", "url": "https://github.com/openhab/openhab-addons/commit/92f5f2d7e684e6fa36204cd38ead286a4deb2e62", "message": "Code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T02:41:50Z", "type": "forcePushed"}, {"oid": "96b0dabe297a6e5ee762f06574285bd14174ac8e", "url": "https://github.com/openhab/openhab-addons/commit/96b0dabe297a6e5ee762f06574285bd14174ac8e", "message": "Update bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T02:46:35Z", "type": "forcePushed"}, {"oid": "75eef230ad5bfeb104bcc7b0eab421805be4a99c", "url": "https://github.com/openhab/openhab-addons/commit/75eef230ad5bfeb104bcc7b0eab421805be4a99c", "message": "Merge branch 'RadioThermostat' of https://github.com/mlobstein/openhab-addons into RadioThermostat\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T03:22:55Z", "type": "forcePushed"}, {"oid": "05043d3fc07fe88f8a6a46096b567176efc18775", "url": "https://github.com/openhab/openhab-addons/commit/05043d3fc07fe88f8a6a46096b567176efc18775", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T04:27:53Z", "type": "commit"}, {"oid": "05043d3fc07fe88f8a6a46096b567176efc18775", "url": "https://github.com/openhab/openhab-addons/commit/05043d3fc07fe88f8a6a46096b567176efc18775", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T04:27:53Z", "type": "forcePushed"}, {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "url": "https://github.com/openhab/openhab-addons/commit/57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "message": "fix hold switch bug\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T15:57:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNTk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432035951", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            @Component(immediate=true, service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n          \n          \n            \n            public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {", "author": "cpmeister", "createdAt": "2020-05-28T18:26:22Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {", "originalCommit": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzOTE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432039194", "bodyText": "I forgot that you can't inject a HttpClient, only a HttpClientFactory. So my apologies.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n          \n          \n            \n                    super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n          \n          \n            \n                    this.httpClient = httpClient;\n          \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClientFactory httpClientFactory) {\n          \n          \n            \n                    super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n          \n          \n            \n                    this.httpClient = httpClientFactory.getCommonHttpClient();", "author": "cpmeister", "createdAt": "2020-05-28T18:32:22Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;", "originalCommit": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074984", "bodyText": "removed and reverted the factory class back to the original incarnation.", "author": "mlobstein", "createdAt": "2020-05-28T19:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzOTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432041783", "bodyText": "remove this loop", "author": "cpmeister", "createdAt": "2020-05-28T18:37:17Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {", "originalCommit": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4ODE2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432088160", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-05-28T19:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432046511", "bodyText": "Actually now that I look at it, you don't need an httpClient at all if this is all you are using it for.\nYou can replace this with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n          \n          \n            \n                                .send();\n          \n          \n            \n                        sysinfo = contentResponse.getContentAsString();\n          \n          \n            \n                        sysinfo = HttpUtil.executeUrl(\"GET\", url, 20000);\n          \n      \n    \n    \n  \n\nYou can do the same for the code below as well.\nYeah, I think the best course of action would be to remove the httpClient field entirely from this class.", "author": "cpmeister", "createdAt": "2020-05-28T18:45:48Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            if (\"location\".equals(key)) {\n+                try {\n+                    url = value;\n+                    ip = new URL(value).getHost();\n+                } catch (MalformedURLException e) {\n+                    logger.debug(\"Malfored URL {}\", e.getMessage());\n+                }\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();", "originalCommit": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDQwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074406", "bodyText": "Cool that simplifies a lot of things!", "author": "mlobstein", "createdAt": "2020-05-28T19:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074234", "bodyText": "@cpmeister is it ok to use a blocking HTTP request on a scheduler thread?", "author": "fwolter", "createdAt": "2020-05-28T19:38:01Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "originalCommit": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3ODQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432078403", "bodyText": "It is ok to use a blocking request on a scheduler thread.", "author": "cpmeister", "createdAt": "2020-05-28T19:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4MDgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432080816", "bodyText": "The only time that you wouldn't want to use the scheduler thread is when you are running a task that could take longer than a couple of seconds. In that case a dedicated thread/threadpool would be more appropriate.", "author": "cpmeister", "createdAt": "2020-05-28T19:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5ODc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432098768", "bodyText": "If I see correctly, the thread is blocked for 20 sec. if the device is not reachable. Is that acceptable?", "author": "fwolter", "createdAt": "2020-05-28T20:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwNTUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432105511", "bodyText": "Couldn't you set a timeout for the request so that it would only block for a couple of seconds at most?", "author": "cpmeister", "createdAt": "2020-05-28T20:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwNjE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432106148", "bodyText": "I think an http timeout of 20 seconds is a little unreasonable. Even in the worst conditions a timeout of 3 seconds should be more than sufficient.", "author": "cpmeister", "createdAt": "2020-05-28T20:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExMTI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432111248", "bodyText": "Ordinarily I would agree. But this thing is slow as molasses. It can only process one request at a time. And if it is busy doing other things, the response will take a while. But if you got past the point of the device responding with the SSDP packet, there is not any issue with reachability. The 20 seconds was for insurance because I saw it timeout frequently with the timeout set for 10 seconds.", "author": "mlobstein", "createdAt": "2020-05-28T20:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExMjc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432112778", "bodyText": "What about using Jetty's async API?\nhttpClient.newRequest(\"http://domain.com/path\")\n        .send(result -> { /* Your logic here */ });", "author": "fwolter", "createdAt": "2020-05-28T20:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNDEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432114102", "bodyText": "If it is going to be a problem I can get rid of the Http calls in the discovery. The IP address from the SSDP packet would be enough to create the thing. Getting additional info via Http was needed to provide the friendly name of the thermostat to the inbox.", "author": "mlobstein", "createdAt": "2020-05-28T20:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNTA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432125060", "bodyText": "What about using Jetty's async API?\n\nI though we had already gone down that road but the issues injecting openhab's httpClient instance into the discovery service was too much overhead.\n@cpmeister", "author": "mlobstein", "createdAt": "2020-05-28T21:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432129723", "bodyText": "I think discovery runs in a dedicated thread, which is not a problem. But the code we're talking about is in the handler. I just saw that this HTTP request is even invoked within initialize(), which should return fast.\nEDIT: Sorry, it's too late. This is ran via the scheduler thread.", "author": "fwolter", "createdAt": "2020-05-28T21:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNDgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432134838", "bodyText": "Yep. initialize() just calls the scheduler now.", "author": "mlobstein", "createdAt": "2020-05-28T21:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432143295", "bodyText": "For the RT I wait 3 seconds, and retry 3 times before giving up. I haven't had any permanent timeouts in a month (I have 4 of the CT50 model).\n    private String getData(String path) throws RadioThermostatCommunicationException {\n        String content;\n        for (int i = 0; i < RETRY_ATTEMPTS; i++) {\n            try {\n                String requestString = baseURL + path;\n                logger.trace(\"Requesting {}\", requestString);\n\n                ContentResponse response = httpClient.newRequest(requestString)\n                        .timeout(TIMEOUT_SECONDS, TimeUnit.SECONDS).send();\n                logger.trace(\"Response code {}\", response.getStatus());\n                if (response.getStatus() != 200) {\n                    throw new RadioThermostatCommunicationException(\n                            \"Error communicating with thermostat. Error Code: \" + response.getStatus());\n                }\n                content = response.getContentAsString();\n                logger.trace(\"sendRequest: response {}\", content);\n                return content;\n            } catch (InterruptedException | ExecutionException e) {\n                throw new RadioThermostatCommunicationException(e);\n            } catch (TimeoutException e) {\n                logger.debug(\"Timeout\", e);\n            }\n        }\n        throw new RadioThermostatCommunicationException(\"All retries timed out.\");\n    }", "author": "billfor", "createdAt": "2020-05-28T21:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MDA0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432150046", "bodyText": "Ok I'll change the timeout in the handler to 3 seconds and do some testing with it tonight. If I don't have issues with 3 second timeouts I will leave it synchronous. Otherwise I will do async as suggested by @fwolter.", "author": "mlobstein", "createdAt": "2020-05-28T22:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDIwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432160202", "bodyText": "Using the async api is a completely viable alternative if you want to go that route.", "author": "cpmeister", "createdAt": "2020-05-28T22:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432182213", "bodyText": "@billfor I have a CT-80 Rev A that I use as for testing. The connection failed the first time when I sent the timeout to 3 seconds. I think I might need to re-think the design of the binding to deal with async. Right now the getRadioThermostatData() calls expect an object to be returned by the method. I think it would work better for async if the calls send an event when they finally finish and then an event listener will receive the event and update the channels accordingly.", "author": "mlobstein", "createdAt": "2020-05-28T23:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNTE5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432215199", "bodyText": "It does time out a lot, but most of the time after three retries it seems to work for me.  I poll it at a frequency of 60 seconds, so it might always miss one entirely but pick up another and I don't notice. I didn't see anything in my logs.", "author": "billfor", "createdAt": "2020-05-29T01:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA=="}], "type": "inlineReview"}, {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "url": "https://github.com/openhab/openhab-addons/commit/0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "message": "remove httpClient from discovery service\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T19:56:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432270573", "bodyText": "You could populate in the RadioThermostatHandlerFactory constructor the same way you do with the HttpClientFactory. It would allow you to make this field non-null and final as well as get rid of the set/unset methods.", "author": "cpmeister", "createdAt": "2020-05-29T05:56:58Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4ODQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432588422", "bodyText": "got it.", "author": "mlobstein", "createdAt": "2020-05-29T16:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432271543", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                private Gson gson;\n          \n          \n            \n            \n          \n          \n            \n                private final Gson gson;", "author": "cpmeister", "createdAt": "2020-05-29T06:00:30Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273051", "bodyText": "change this to a boolean", "author": "cpmeister", "createdAt": "2020-05-29T06:05:22Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2Mjg1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432562853", "bodyText": "it will be removed", "author": "mlobstein", "createdAt": "2020-05-29T15:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273129", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);", "author": "cpmeister", "createdAt": "2020-05-29T06:05:38Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273318", "bodyText": "If you make the change I suggested in the ThingHandlerFactory you can make this non-null", "author": "cpmeister", "createdAt": "2020-05-29T06:06:16Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273678", "bodyText": "calling getConfigAs is a costly operation, so you should try to cache the parsed config in a field so that other parts of the code can use it.", "author": "cpmeister", "createdAt": "2020-05-29T06:07:40Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NDU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432274586", "bodyText": "What do you expect to throw an IllegalStateException?", "author": "cpmeister", "createdAt": "2020-05-29T06:10:50Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2MzQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432563463", "bodyText": "probably leftover from when I was doing regexes here. removed.", "author": "mlobstein", "createdAt": "2020-05-29T15:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NDU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NTg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432275858", "bodyText": "Right now you are trying to figure out the expected json return type based on the value of the resource parameter. Instead you should supply the expected return type class as a parameter so you can take advantage of generics.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Object getRadioThermostatData(String resource) {\n          \n          \n            \n                private <T> @Nullable T getRadioThermostatData(String resource, Class<T> returnType) {", "author": "cpmeister", "createdAt": "2020-05-29T06:15:09Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NTI2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432585261", "bodyText": "I re-worked the data retrieval to be async. This will be OBE when the changes are pushed.", "author": "mlobstein", "createdAt": "2020-05-29T16:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjA2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432276065", "bodyText": "What throws an Exception here?", "author": "cpmeister", "createdAt": "2020-05-29T06:15:50Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3NjEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432576103", "bodyText": "nothing; removed", "author": "mlobstein", "createdAt": "2020-05-29T15:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjE2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432276164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n          \n          \n            \n                            if (data.getThermostatData().getTemperature() != 0) {", "author": "cpmeister", "createdAt": "2020-05-29T06:16:12Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NzU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432277598", "bodyText": "Why are you always returning the current time? You shouldn't do this since a channel might be trying to refresh this value from a cached RadioThermostatData.", "author": "cpmeister", "createdAt": "2020-05-29T06:20:41Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case STATUS:\n+                return data.getThermostatData().getStatus();\n+            case FAN_STATUS:\n+                return data.getThermostatData().getFanStatus();\n+            case DAY:\n+                return data.getThermostatData().getTime().getDayOfWeek();\n+            case HOUR:\n+                return data.getThermostatData().getTime().getHour();\n+            case MINUTE:\n+                return data.getThermostatData().getTime().getMinute();\n+            case DATE_STAMP:\n+                return data.getThermostatData().getTime().getThemostatDateTime();\n+            case LAST_UPDATE:\n+                return ZonedDateTime.now();", "originalCommit": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3ODY3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432578676", "bodyText": "I think I did this as a hold over from the rules way of doing things. It's a clue to know if your thermostat connection is dead. It also displays in the official app to tell you the last time the thermostat phoned home. But I'll take it out since the binding will report offline if contact is lost.", "author": "mlobstein", "createdAt": "2020-05-29T15:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NzU5OA=="}], "type": "inlineReview"}, {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "url": "https://github.com/openhab/openhab-addons/commit/2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "message": "refactor to async http and other review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-29T19:52:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNDIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432734213", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        listeners.get(i).onNewMessageEvent(event);\n          \n          \n            \n                    }\n          \n          \n            \n                    for (RadioThermostatEventListener listener : listeners) {\n          \n          \n            \n                        listener.onNewMessageEvent(event);\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-05-29T21:03:44Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;\n+\n+    private List<RadioThermostatEventListener> listeners = new ArrayList<>();\n+\n+    public RadioThermostatConnector(HttpClient httpClient, @Nullable String hostName) {\n+        this.httpClient = httpClient;\n+        this.hostName = hostName;\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(RadioThermostatEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(RadioThermostatEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Send an asynchronous http call to the thermostat, the response will be send to the\n+     * event listeners as a RadioThermostat event when it is finally received\n+     *\n+     * @param resouce the url of the json resource on the thermostat\n+     */\n+    public void getAsyncThermostatData(String resource) {\n+        String urlStr = buildRequestURL(resource);\n+\n+        httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @Override\n+            public void onComplete(@Nullable Result result) {\n+                if (!result.isFailed()) {\n+                    String response = getContentAsString();\n+                    logger.debug(\"thermostatResponse = {}\", response);\n+                    dispatchKeyValue(resource, response);\n+                } else {\n+                    dispatchKeyValue(KEY_ERROR, \"\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    public String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    public String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Dispatch an event (key, value) to the event listeners\n+     *\n+     * @param key the key\n+     * @param value the value\n+     */\n+    private void dispatchKeyValue(String key, String value) {\n+        RadioThermostatEvent event = new RadioThermostatEvent(this, key, value);\n+        for (int i = 0; i < listeners.size(); i++) {\n+            listeners.get(i).onNewMessageEvent(event);\n+        }", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNjI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432736254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HttpClient httpClient;\n          \n          \n            \n                private @Nullable String hostName;\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                private final @Nullable String hostName;", "author": "cpmeister", "createdAt": "2020-05-29T21:08:40Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNjUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432736533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<RadioThermostatEventListener> listeners = new ArrayList<>();\n          \n          \n            \n                private final List<RadioThermostatEventListener> listeners = new CopyOnWriteArrayList<>();", "author": "cpmeister", "createdAt": "2020-05-29T21:09:14Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;\n+\n+    private List<RadioThermostatEventListener> listeners = new ArrayList<>();", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MDI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432740294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event);\n          \n          \n            \n                public void onNewMessageEvent(RadioThermostatEvent event);", "author": "cpmeister", "createdAt": "2020-05-29T21:19:01Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatEventListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * RadtioThermostat Event Listener interface. Handles incoming RadioThermostat message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface RadioThermostatEventListener extends EventListener {\n+\n+    /**\n+     * Event handler method for incoming RadioThermostat message events\n+     *\n+     * @param event the event object\n+     */\n+    public void onNewMessageEvent(EventObject event);", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MDU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432740592", "bodyText": "Please move final fields above the non-final fields", "author": "cpmeister", "createdAt": "2020-05-29T21:19:55Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741004", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event) {\n          \n          \n            \n                    RadioThermostatEvent evt = (RadioThermostatEvent) event;\n          \n          \n            \n                public void onNewMessageEvent(RadioThermostatEvent evt) {", "author": "cpmeister", "createdAt": "2020-05-29T21:20:59Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741247", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-05-29T21:21:44Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741384", "bodyText": "this can be removed", "author": "cpmeister", "createdAt": "2020-05-29T21:22:07Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTU3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741577", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n          \n          \n            \n                                rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n          \n          \n            \n                                rthermData.setThermostatData(gson.fromJson(evtVal, RadioThermostatJsonResponse.class));", "author": "cpmeister", "createdAt": "2020-05-29T21:22:41Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741896", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n          \n          \n            \n                                rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n          \n          \n            \n                                rthermData.setHumidity(gson.fromJson(evtVal, RadioThermostatJsonHumidity.class).getHumidity());", "author": "cpmeister", "createdAt": "2020-05-29T21:23:34Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MjAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432742012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n          \n          \n            \n                                rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n          \n          \n            \n                                rthermData.setRuntime(gson.fromJson(evtVal, RadioThermostatJsonRuntime.class));", "author": "cpmeister", "createdAt": "2020-05-29T21:23:55Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n+                    rthermData.setRuntime((RadioThermostatJsonRuntime) result);", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432742970", "bodyText": "Things might get wonky if the user supplies a value with a decimal point.", "author": "cpmeister", "createdAt": "2020-05-29T21:26:29Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc1ODgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432758803", "bodyText": "They shouldn't. The values are all constrained by the drop downs and set points.", "author": "mlobstein", "createdAt": "2020-05-29T22:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2NjgzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432766833", "bodyText": "What if the command comes from someone's rules?", "author": "cpmeister", "createdAt": "2020-05-29T22:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzczNw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432793737", "bodyText": "Alright, I improved it. A number with a decimal will be transformed into an appropriate integer value. If their rules are sending values outside the range of what the thermostat will accept, its on them.", "author": "mlobstein", "createdAt": "2020-05-30T00:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MzgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432743814", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (data.getThermostatData().getHold() == 1) {\n          \n          \n            \n                                return OnOffType.ON;\n          \n          \n            \n                            } else {\n          \n          \n            \n                                return OnOffType.OFF;\n          \n          \n            \n                            }\n          \n          \n            \n                            return OnOffType.from(data.getThermostatData().getHold() == 1);", "author": "cpmeister", "createdAt": "2020-05-29T21:28:56Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n+                    rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                    updateChannel(TODAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(TODAY_COOL_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_COOL_RUNTIME, rthermData);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data the RadioThermostat dto\n+     * @return the value to be set in the state\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(0d)) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NDc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432744788", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private RadioThermostatData rthermData = new RadioThermostatData();\n          \n          \n            \n                private final RadioThermostatData rthermData = new RadioThermostatData();", "author": "cpmeister", "createdAt": "2020-05-29T21:31:40Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();", "originalCommit": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74d92c01f6c9f586b656087420157351699fd693", "url": "https://github.com/openhab/openhab-addons/commit/74d92c01f6c9f586b656087420157351699fd693", "message": "additional review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-29T22:21:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3MjIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432772233", "bodyText": "oops forgot to return! fixing...", "author": "mlobstein", "createdAt": "2020-05-29T22:48:13Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final Gson gson;\n+    private final RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private @Nullable RadioThermostatConnector connector;\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(RadioThermostatEvent event) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", event.getKey(), event.getValue());\n+\n+        String evtKey = event.getKey();\n+        String evtVal = event.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    rthermData.setThermostatData(gson.fromJson(evtVal, RadioThermostatJsonResponse.class));\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    rthermData.setHumidity(gson.fromJson(evtVal, RadioThermostatJsonHumidity.class).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    rthermData.setRuntime(gson.fromJson(evtVal, RadioThermostatJsonRuntime.class));\n+                    updateChannel(TODAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(TODAY_COOL_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_COOL_RUNTIME, rthermData);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data the RadioThermostat dto\n+     * @return the value to be set in the state\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(0d)) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                OnOffType.from(data.getThermostatData().getHold() == 1);", "originalCommit": "74d92c01f6c9f586b656087420157351699fd693", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c758c9437755c4476b83a746efd20954002f7a42", "url": "https://github.com/openhab/openhab-addons/commit/c758c9437755c4476b83a746efd20954002f7a42", "message": "add missing return\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-29T22:54:06Z", "type": "commit"}, {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328", "url": "https://github.com/openhab/openhab-addons/commit/a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328", "message": "improve number parsing\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-30T00:45:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800022", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                cmdInt = ((Number)NumberFormat.getInstance().parse(cmdStr)).intValue();\n          \n          \n            \n                                cmdInt = NumberFormat.getInstance().parse(cmdStr).intValue();", "author": "cpmeister", "createdAt": "2020-05-30T01:58:57Z", "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -193,9 +195,10 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             String cmdStr = command.toString();\n             if (cmdStr != null) {\n                 try {\n-                    // remove all non-numeric characters except negative '-' and parse int\n-                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n-                } catch (NumberFormatException e) {\n+                    // parse out an Integer from the string\n+                    // ie '70.5 F' becomes 70, also handles negative numbers \n+                    cmdInt = ((Number)NumberFormat.getInstance().parse(cmdStr)).intValue();", "originalCommit": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "87c570596b307e24b4fa9a46494854112c44e5d4", "url": "https://github.com/openhab/openhab-addons/commit/87c570596b307e24b4fa9a46494854112c44e5d4", "message": "couple more changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-30T03:05:16Z", "type": "commit"}, {"oid": "542afbb620dc55c0463e28e98aeb0a7e5505dfa6", "url": "https://github.com/openhab/openhab-addons/commit/542afbb620dc55c0463e28e98aeb0a7e5505dfa6", "message": "fix some warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T01:09:59Z", "type": "commit"}, {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-04T21:19:29Z", "type": "commit"}, {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5", "url": "https://github.com/openhab/openhab-addons/commit/a748961fec70fa4731076e2670287a1cb0fa57f5", "message": "fix compilier warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-09T04:21:20Z", "type": "commit"}, {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-24T13:47:17Z", "type": "commit"}, {"oid": "d290815e064605dcb42e8be261f725b6626fbbb8", "url": "https://github.com/openhab/openhab-addons/commit/d290815e064605dcb42e8be261f725b6626fbbb8", "message": "Merge branch '2.5.x' into RadioThermostat", "committedDate": "2020-06-24T13:49:09Z", "type": "commit"}, {"oid": "76e8f563cf08eca6de40286b4f0ae8daeaf59906", "url": "https://github.com/openhab/openhab-addons/commit/76e8f563cf08eca6de40286b4f0ae8daeaf59906", "message": "Update pom version and format README\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-24T14:09:31Z", "type": "commit"}]}