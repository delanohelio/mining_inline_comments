{"pr_number": 8464, "pr_title": "[velbus] Added support for additional Velbus modules and module features.", "pr_createdAt": "2020-09-12T15:30:34Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8464", "timeline": [{"oid": "03a21f83c9c02a3c7559636f06f5e48070e3660d", "url": "https://github.com/openhab/openhab-addons/commit/03a21f83c9c02a3c7559636f06f5e48070e3660d", "message": "Added support for additional Velbus modules and module features.\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-13T06:11:47Z", "type": "commit"}, {"oid": "03a21f83c9c02a3c7559636f06f5e48070e3660d", "url": "https://github.com/openhab/openhab-addons/commit/03a21f83c9c02a3c7559636f06f5e48070e3660d", "message": "Added support for additional Velbus modules and module features.\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-13T06:11:47Z", "type": "forcePushed"}, {"oid": "798f00cf377672939117416ae770b50130ec6a75", "url": "https://github.com/openhab/openhab-addons/commit/798f00cf377672939117416ae770b50130ec6a75", "message": "Minor corrections in Readme + addition of the\nVMB1RYS module.\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-13T20:38:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIxNjY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489216682", "bodyText": "Since your changing this anyway. Can you rewrite this to be implemented as a ThingHandlerService, You can read about this in this preview documentation page: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "author": "Hilbrand", "createdAt": "2020-09-16T07:19:21Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/VelbusHandlerFactory.java", "diffHunk": "@@ -109,13 +134,11 @@ private synchronized void registerDiscoveryService(VelbusBridgeHandler bridgeHan\n \n     private synchronized void unregisterDiscoveryService(VelbusBridgeHandler bridgeHandler) {\n         ServiceRegistration<?> serviceReg = this.discoveryServiceRegs.remove(bridgeHandler.getThing().getUID());\n-        if (serviceReg != null) {\n-            VelbusThingDiscoveryService service = (VelbusThingDiscoveryService) bundleContext\n-                    .getService(serviceReg.getReference());\n-            serviceReg.unregister();\n-            if (service != null) {\n-                service.deactivate();\n-            }\n+        VelbusThingDiscoveryService service = (VelbusThingDiscoveryService) bundleContext", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNjc2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491216766", "bodyText": "Modified to be implemented as a ThingHandlerService in commit 780323c.", "author": "cedricboon", "createdAt": "2020-09-18T22:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIxNjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489231744", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Integer.parseInt(id.substring(id.indexOf(\"#\") + 1).substring(2));\n          \n          \n            \n                    return Integer.parseInt(channelUID.getIdWithoutGroup()).substring(2));", "author": "Hilbrand", "createdAt": "2020-09-16T07:45:42Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/VelbusModuleAddress.java", "diffHunk": "@@ -73,7 +75,8 @@ public VelbusChannelIdentifier getChannelIdentifier(ChannelUID channelUID) {\n     }\n \n     public int getChannelNumber(ChannelUID channelUID) {\n-        return Integer.parseInt(channelUID.getId().substring(2));\n+        String id = channelUID.getId();\n+        return Integer.parseInt(id.substring(id.indexOf(\"#\") + 1).substring(2));", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNjk2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491216968", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNTQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489235414", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    timeUpdateJob = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                    timeUpdateJob = scheduler.scheduleWithFixedDelay(this::updateDateTime, .....", "author": "Hilbrand", "createdAt": "2020-09-16T07:51:51Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -12,101 +12,134 @@\n  */\n package org.openhab.binding.velbus.internal.handler;\n \n-import static org.openhab.binding.velbus.internal.VelbusBindingConstants.PORT;\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n \n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.TooManyListenersException;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.thing.Bridge;\n import org.eclipse.smarthome.core.thing.ChannelUID;\n import org.eclipse.smarthome.core.thing.ThingStatus;\n import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n import org.eclipse.smarthome.core.types.Command;\n-import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n-import org.eclipse.smarthome.io.transport.serial.SerialPort;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n-import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n import org.openhab.binding.velbus.internal.VelbusPacketInputStream;\n import org.openhab.binding.velbus.internal.VelbusPacketListener;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetDatePacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetDaylightSavingsStatusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetRealtimeClockPacket;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * {@link VelbusBridgeHandler} is the handler for a Velbus Serial-interface and connects it to\n+ * {@link VelbusBridgeHandler} is an abstract handler for a Velbus interface and connects it to\n  * the framework.\n  *\n  * @author Cedric Boon - Initial contribution\n  */\n-public class VelbusBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+@NonNullByDefault\n+public abstract class VelbusBridgeHandler extends BaseBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusBridgeHandler.class);\n \n-    private Logger logger = LoggerFactory.getLogger(VelbusBridgeHandler.class);\n-\n-    private static final int BAUD = 9600;\n-    private SerialPort serialPort;\n-    private final SerialPortManager serialPortManager;\n-    private OutputStream outputStream;\n-    private VelbusPacketInputStream inputStream;\n     private long lastPacketTimeMillis;\n \n-    private VelbusPacketListener defaultPacketListener;\n-    private final Map<Byte, VelbusPacketListener> packetListeners = new HashMap<>();\n+    protected @Nullable VelbusPacketListener defaultPacketListener;\n+    protected Map<Byte, VelbusPacketListener> packetListeners = new HashMap<Byte, VelbusPacketListener>();\n \n-    public VelbusBridgeHandler(Bridge velbusBridge, SerialPortManager serialPortManager) {\n-        super(velbusBridge);\n-        this.serialPortManager = serialPortManager;\n-    }\n+    private @Nullable ScheduledFuture<?> timeUpdateJob;\n+    private @Nullable ScheduledFuture<?> reconnectionHandler;\n \n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) VelbusPacketInputStream inputStream;\n+\n+    private boolean listenerStopped;\n+\n+    public VelbusBridgeHandler(Bridge velbusBridge) {\n+        super(velbusBridge);\n     }\n \n     @Override\n     public void initialize() {\n         logger.debug(\"Initializing velbus bridge handler.\");\n \n-        String port = (String) getConfig().get(PORT);\n-        if (port == null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Serial port name not configured\");\n-            return;\n-        }\n+        connect();\n+        initializeTimeUpdate();\n+    }\n \n-        SerialPortIdentifier serialPortIdentifier = serialPortManager.getIdentifier(port);\n-        if (serialPortIdentifier == null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Serial port not found: \" + port);\n-            return;\n+    private void initializeTimeUpdate() {\n+        Object timeUpdateIntervalObject = getConfig().get(TIME_UPDATE_INTERVAL);\n+        if (timeUpdateIntervalObject != null) {\n+            int timeUpdateInterval = ((BigDecimal) timeUpdateIntervalObject).intValue();\n+\n+            if (timeUpdateInterval > 0) {\n+                startTimeUpdates(timeUpdateInterval);\n+            }\n         }\n+    }\n \n-        try {\n-            serialPort = serialPortIdentifier.open(VelbusBridgeHandler.class.getCanonicalName(), 2000);\n-            serialPort.setSerialPortParams(BAUD, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+    private void startTimeUpdates(int timeUpdatesInterval) {\n+        timeUpdateJob = scheduler.scheduleWithFixedDelay(() -> {", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491217151", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNTQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489236669", "bodyText": "This is not such a big problem that it should be reported as an error log. Errors logs are used to indicate major failures of the system in openHAB.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error while closing output stream\", e);\n          \n          \n            \n                        logger.debug(\"Error while closing output stream\", e);", "author": "Hilbrand", "createdAt": "2020-09-16T07:53:56Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -124,61 +157,125 @@ public synchronized void sendPacket(byte[] packet) {\n             return;\n         }\n \n-        try {\n-            outputStream.write(packet);\n-            outputStream.flush();\n-        } catch (IOException e) {\n-            logger.error(\"Serial port write error\", e);\n-        }\n+        writePacket(packet);\n \n         lastPacketTimeMillis = System.currentTimeMillis();\n     }\n \n-    public void setDefaultPacketListener(VelbusPacketListener velbusPacketListener) {\n-        defaultPacketListener = velbusPacketListener;\n+    private void readPacket(byte[] packet) {\n+        byte address = packet[2];\n+\n+        if (packetListeners.containsKey(address)) {\n+            VelbusPacketListener packetListener = packetListeners.get(address);\n+            packetListener.onPacketReceived(packet);\n+        } else if (defaultPacketListener != null) {\n+            defaultPacketListener.onPacketReceived(packet);\n+        }\n     }\n \n-    public void registerPacketListener(byte address, VelbusPacketListener packetListener) {\n-        if (packetListener == null) {\n-            throw new IllegalArgumentException(\"It's not allowed to pass a null RelayStatusListener.\");\n+    protected void readPackets() {\n+        if (inputStream == null) {\n+            onConnectionLost();\n+            return;\n         }\n \n-        packetListeners.put(Byte.valueOf(address), packetListener);\n+        byte[] packet;\n+\n+        listenerStopped = false;\n+\n+        try {\n+            while (!listenerStopped & ((packet = inputStream.readPacket()).length > 0)) {\n+                readPacket(packet);\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                onConnectionLost();\n+            }\n+        }\n     }\n \n-    public void unregisterRelayStatusListener(byte address, VelbusPacketListener packetListener) {\n-        packetListeners.remove(Byte.valueOf(address));\n+    private void writePacket(byte[] packet) {\n+        if (outputStream == null) {\n+            onConnectionLost();\n+            return;\n+        }\n+\n+        try {\n+            outputStream.write(packet);\n+            outputStream.flush();\n+        } catch (IOException e) {\n+            onConnectionLost();\n+        }\n     }\n \n-    @Override\n-    public void dispose() {\n-        if (serialPort != null) {\n-            serialPort.removeEventListener();\n-            serialPort.close();\n-            serialPort = null;\n+    protected void onConnectionLost() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"A network communication error occurred.\");\n+        disconnect();\n+        startReconnectionHandler();\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected void disconnect() {\n+        listenerStopped = true;\n+\n+        try {\n+            if (outputStream != null) {\n+                outputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing output stream\", e);", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzM4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491217381", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489236803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error while closing input stream\", e);\n          \n          \n            \n                        logger.debug(\"Error while closing input stream\", e);", "author": "Hilbrand", "createdAt": "2020-09-16T07:54:10Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -124,61 +157,125 @@ public synchronized void sendPacket(byte[] packet) {\n             return;\n         }\n \n-        try {\n-            outputStream.write(packet);\n-            outputStream.flush();\n-        } catch (IOException e) {\n-            logger.error(\"Serial port write error\", e);\n-        }\n+        writePacket(packet);\n \n         lastPacketTimeMillis = System.currentTimeMillis();\n     }\n \n-    public void setDefaultPacketListener(VelbusPacketListener velbusPacketListener) {\n-        defaultPacketListener = velbusPacketListener;\n+    private void readPacket(byte[] packet) {\n+        byte address = packet[2];\n+\n+        if (packetListeners.containsKey(address)) {\n+            VelbusPacketListener packetListener = packetListeners.get(address);\n+            packetListener.onPacketReceived(packet);\n+        } else if (defaultPacketListener != null) {\n+            defaultPacketListener.onPacketReceived(packet);\n+        }\n     }\n \n-    public void registerPacketListener(byte address, VelbusPacketListener packetListener) {\n-        if (packetListener == null) {\n-            throw new IllegalArgumentException(\"It's not allowed to pass a null RelayStatusListener.\");\n+    protected void readPackets() {\n+        if (inputStream == null) {\n+            onConnectionLost();\n+            return;\n         }\n \n-        packetListeners.put(Byte.valueOf(address), packetListener);\n+        byte[] packet;\n+\n+        listenerStopped = false;\n+\n+        try {\n+            while (!listenerStopped & ((packet = inputStream.readPacket()).length > 0)) {\n+                readPacket(packet);\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                onConnectionLost();\n+            }\n+        }\n     }\n \n-    public void unregisterRelayStatusListener(byte address, VelbusPacketListener packetListener) {\n-        packetListeners.remove(Byte.valueOf(address));\n+    private void writePacket(byte[] packet) {\n+        if (outputStream == null) {\n+            onConnectionLost();\n+            return;\n+        }\n+\n+        try {\n+            outputStream.write(packet);\n+            outputStream.flush();\n+        } catch (IOException e) {\n+            onConnectionLost();\n+        }\n     }\n \n-    @Override\n-    public void dispose() {\n-        if (serialPort != null) {\n-            serialPort.removeEventListener();\n-            serialPort.close();\n-            serialPort = null;\n+    protected void onConnectionLost() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"A network communication error occurred.\");\n+        disconnect();\n+        startReconnectionHandler();\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected void disconnect() {\n+        listenerStopped = true;\n+\n+        try {\n+            if (outputStream != null) {\n+                outputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing output stream\", e);\n+        }\n+\n+        try {\n+            if (inputStream != null) {\n+                inputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing input stream\", e);", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxODUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491218507", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNzIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489237239", "bodyText": "Use lambda notation:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                reconnectionHandler = scheduler.scheduleWithFixedDelay(new Runnable() {\n          \n          \n            \n                                reconnectionHandler = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                                     try {\n          \n          \n            \n                                      ....", "author": "Hilbrand", "createdAt": "2020-09-16T07:54:50Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -124,61 +157,125 @@ public synchronized void sendPacket(byte[] packet) {\n             return;\n         }\n \n-        try {\n-            outputStream.write(packet);\n-            outputStream.flush();\n-        } catch (IOException e) {\n-            logger.error(\"Serial port write error\", e);\n-        }\n+        writePacket(packet);\n \n         lastPacketTimeMillis = System.currentTimeMillis();\n     }\n \n-    public void setDefaultPacketListener(VelbusPacketListener velbusPacketListener) {\n-        defaultPacketListener = velbusPacketListener;\n+    private void readPacket(byte[] packet) {\n+        byte address = packet[2];\n+\n+        if (packetListeners.containsKey(address)) {\n+            VelbusPacketListener packetListener = packetListeners.get(address);\n+            packetListener.onPacketReceived(packet);\n+        } else if (defaultPacketListener != null) {\n+            defaultPacketListener.onPacketReceived(packet);\n+        }\n     }\n \n-    public void registerPacketListener(byte address, VelbusPacketListener packetListener) {\n-        if (packetListener == null) {\n-            throw new IllegalArgumentException(\"It's not allowed to pass a null RelayStatusListener.\");\n+    protected void readPackets() {\n+        if (inputStream == null) {\n+            onConnectionLost();\n+            return;\n         }\n \n-        packetListeners.put(Byte.valueOf(address), packetListener);\n+        byte[] packet;\n+\n+        listenerStopped = false;\n+\n+        try {\n+            while (!listenerStopped & ((packet = inputStream.readPacket()).length > 0)) {\n+                readPacket(packet);\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                onConnectionLost();\n+            }\n+        }\n     }\n \n-    public void unregisterRelayStatusListener(byte address, VelbusPacketListener packetListener) {\n-        packetListeners.remove(Byte.valueOf(address));\n+    private void writePacket(byte[] packet) {\n+        if (outputStream == null) {\n+            onConnectionLost();\n+            return;\n+        }\n+\n+        try {\n+            outputStream.write(packet);\n+            outputStream.flush();\n+        } catch (IOException e) {\n+            onConnectionLost();\n+        }\n     }\n \n-    @Override\n-    public void dispose() {\n-        if (serialPort != null) {\n-            serialPort.removeEventListener();\n-            serialPort.close();\n-            serialPort = null;\n+    protected void onConnectionLost() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"A network communication error occurred.\");\n+        disconnect();\n+        startReconnectionHandler();\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected void disconnect() {\n+        listenerStopped = true;\n+\n+        try {\n+            if (outputStream != null) {\n+                outputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing output stream\", e);\n+        }\n+\n+        try {\n+            if (inputStream != null) {\n+                inputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing input stream\", e);\n         }\n     }\n \n-    @Override\n-    public void serialEvent(SerialPortEvent event) {\n-        logger.debug(\"Serial port event triggered\");\n-\n-        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n-            try {\n-                byte[] packet;\n-                while ((packet = inputStream.readPacket()) != null) {\n-                    byte address = packet[2];\n-\n-                    VelbusPacketListener packetListener = packetListeners.get(address);\n-                    if (packetListener != null) {\n-                        packetListener.onPacketReceived(packet);\n-                    } else if (defaultPacketListener != null) {\n-                        defaultPacketListener.onPacketReceived(packet);\n-                    }\n+    public void startReconnectionHandler() {\n+        if (reconnectionHandler == null || reconnectionHandler.isCancelled()) {\n+            Object reconnectionIntervalObject = getConfig().get(RECONNECTION_INTERVAL);\n+            if (reconnectionIntervalObject != null) {\n+                long reconnectionInterval = ((BigDecimal) reconnectionIntervalObject).longValue();\n+\n+                if (reconnectionInterval > 0) {\n+                    reconnectionHandler = scheduler.scheduleWithFixedDelay(new Runnable() {", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxODY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491218654", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNzIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTY0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489241642", "bodyText": "Can you catch a specific exception? Also if this happens you might want to set the thing to offline to indicate it's not connecting", "author": "Hilbrand", "createdAt": "2020-09-16T08:01:53Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -124,61 +157,125 @@ public synchronized void sendPacket(byte[] packet) {\n             return;\n         }\n \n-        try {\n-            outputStream.write(packet);\n-            outputStream.flush();\n-        } catch (IOException e) {\n-            logger.error(\"Serial port write error\", e);\n-        }\n+        writePacket(packet);\n \n         lastPacketTimeMillis = System.currentTimeMillis();\n     }\n \n-    public void setDefaultPacketListener(VelbusPacketListener velbusPacketListener) {\n-        defaultPacketListener = velbusPacketListener;\n+    private void readPacket(byte[] packet) {\n+        byte address = packet[2];\n+\n+        if (packetListeners.containsKey(address)) {\n+            VelbusPacketListener packetListener = packetListeners.get(address);\n+            packetListener.onPacketReceived(packet);\n+        } else if (defaultPacketListener != null) {\n+            defaultPacketListener.onPacketReceived(packet);\n+        }\n     }\n \n-    public void registerPacketListener(byte address, VelbusPacketListener packetListener) {\n-        if (packetListener == null) {\n-            throw new IllegalArgumentException(\"It's not allowed to pass a null RelayStatusListener.\");\n+    protected void readPackets() {\n+        if (inputStream == null) {\n+            onConnectionLost();\n+            return;\n         }\n \n-        packetListeners.put(Byte.valueOf(address), packetListener);\n+        byte[] packet;\n+\n+        listenerStopped = false;\n+\n+        try {\n+            while (!listenerStopped & ((packet = inputStream.readPacket()).length > 0)) {\n+                readPacket(packet);\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                onConnectionLost();\n+            }\n+        }\n     }\n \n-    public void unregisterRelayStatusListener(byte address, VelbusPacketListener packetListener) {\n-        packetListeners.remove(Byte.valueOf(address));\n+    private void writePacket(byte[] packet) {\n+        if (outputStream == null) {\n+            onConnectionLost();\n+            return;\n+        }\n+\n+        try {\n+            outputStream.write(packet);\n+            outputStream.flush();\n+        } catch (IOException e) {\n+            onConnectionLost();\n+        }\n     }\n \n-    @Override\n-    public void dispose() {\n-        if (serialPort != null) {\n-            serialPort.removeEventListener();\n-            serialPort.close();\n-            serialPort = null;\n+    protected void onConnectionLost() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"A network communication error occurred.\");\n+        disconnect();\n+        startReconnectionHandler();\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected void disconnect() {\n+        listenerStopped = true;\n+\n+        try {\n+            if (outputStream != null) {\n+                outputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing output stream\", e);\n+        }\n+\n+        try {\n+            if (inputStream != null) {\n+                inputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing input stream\", e);\n         }\n     }\n \n-    @Override\n-    public void serialEvent(SerialPortEvent event) {\n-        logger.debug(\"Serial port event triggered\");\n-\n-        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n-            try {\n-                byte[] packet;\n-                while ((packet = inputStream.readPacket()) != null) {\n-                    byte address = packet[2];\n-\n-                    VelbusPacketListener packetListener = packetListeners.get(address);\n-                    if (packetListener != null) {\n-                        packetListener.onPacketReceived(packet);\n-                    } else if (defaultPacketListener != null) {\n-                        defaultPacketListener.onPacketReceived(packet);\n-                    }\n+    public void startReconnectionHandler() {\n+        if (reconnectionHandler == null || reconnectionHandler.isCancelled()) {\n+            Object reconnectionIntervalObject = getConfig().get(RECONNECTION_INTERVAL);\n+            if (reconnectionIntervalObject != null) {\n+                long reconnectionInterval = ((BigDecimal) reconnectionIntervalObject).longValue();\n+\n+                if (reconnectionInterval > 0) {\n+                    reconnectionHandler = scheduler.scheduleWithFixedDelay(new Runnable() {\n+\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                connect();\n+                                if (reconnectionHandler != null) {\n+                                    reconnectionHandler.cancel(false);\n+                                }\n+                            } catch (Exception e) {", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220131", "bodyText": "Modified in commit 780323c: replaced the exception catching by a boolean check on \"connect()\". In case of problems during the connection, the \"connect()\" operation is setting the thing to offline through \"onConnectionLost()\".", "author": "cedricboon", "createdAt": "2020-09-18T22:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489241954", "bodyText": "You should probably set the status of the thing and then this should be an log to debug:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            logger.error(\"Reconnection failed\", e);\n          \n          \n            \n                                            logger.debug(\"Reconnection failed\", e);", "author": "Hilbrand", "createdAt": "2020-09-16T08:02:31Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -124,61 +157,125 @@ public synchronized void sendPacket(byte[] packet) {\n             return;\n         }\n \n-        try {\n-            outputStream.write(packet);\n-            outputStream.flush();\n-        } catch (IOException e) {\n-            logger.error(\"Serial port write error\", e);\n-        }\n+        writePacket(packet);\n \n         lastPacketTimeMillis = System.currentTimeMillis();\n     }\n \n-    public void setDefaultPacketListener(VelbusPacketListener velbusPacketListener) {\n-        defaultPacketListener = velbusPacketListener;\n+    private void readPacket(byte[] packet) {\n+        byte address = packet[2];\n+\n+        if (packetListeners.containsKey(address)) {\n+            VelbusPacketListener packetListener = packetListeners.get(address);\n+            packetListener.onPacketReceived(packet);\n+        } else if (defaultPacketListener != null) {\n+            defaultPacketListener.onPacketReceived(packet);\n+        }\n     }\n \n-    public void registerPacketListener(byte address, VelbusPacketListener packetListener) {\n-        if (packetListener == null) {\n-            throw new IllegalArgumentException(\"It's not allowed to pass a null RelayStatusListener.\");\n+    protected void readPackets() {\n+        if (inputStream == null) {\n+            onConnectionLost();\n+            return;\n         }\n \n-        packetListeners.put(Byte.valueOf(address), packetListener);\n+        byte[] packet;\n+\n+        listenerStopped = false;\n+\n+        try {\n+            while (!listenerStopped & ((packet = inputStream.readPacket()).length > 0)) {\n+                readPacket(packet);\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                onConnectionLost();\n+            }\n+        }\n     }\n \n-    public void unregisterRelayStatusListener(byte address, VelbusPacketListener packetListener) {\n-        packetListeners.remove(Byte.valueOf(address));\n+    private void writePacket(byte[] packet) {\n+        if (outputStream == null) {\n+            onConnectionLost();\n+            return;\n+        }\n+\n+        try {\n+            outputStream.write(packet);\n+            outputStream.flush();\n+        } catch (IOException e) {\n+            onConnectionLost();\n+        }\n     }\n \n-    @Override\n-    public void dispose() {\n-        if (serialPort != null) {\n-            serialPort.removeEventListener();\n-            serialPort.close();\n-            serialPort = null;\n+    protected void onConnectionLost() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"A network communication error occurred.\");\n+        disconnect();\n+        startReconnectionHandler();\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected void disconnect() {\n+        listenerStopped = true;\n+\n+        try {\n+            if (outputStream != null) {\n+                outputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing output stream\", e);\n+        }\n+\n+        try {\n+            if (inputStream != null) {\n+                inputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing input stream\", e);\n         }\n     }\n \n-    @Override\n-    public void serialEvent(SerialPortEvent event) {\n-        logger.debug(\"Serial port event triggered\");\n-\n-        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n-            try {\n-                byte[] packet;\n-                while ((packet = inputStream.readPacket()) != null) {\n-                    byte address = packet[2];\n-\n-                    VelbusPacketListener packetListener = packetListeners.get(address);\n-                    if (packetListener != null) {\n-                        packetListener.onPacketReceived(packet);\n-                    } else if (defaultPacketListener != null) {\n-                        defaultPacketListener.onPacketReceived(packet);\n-                    }\n+    public void startReconnectionHandler() {\n+        if (reconnectionHandler == null || reconnectionHandler.isCancelled()) {\n+            Object reconnectionIntervalObject = getConfig().get(RECONNECTION_INTERVAL);\n+            if (reconnectionIntervalObject != null) {\n+                long reconnectionInterval = ((BigDecimal) reconnectionIntervalObject).longValue();\n+\n+                if (reconnectionInterval > 0) {\n+                    reconnectionHandler = scheduler.scheduleWithFixedDelay(new Runnable() {\n+\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                connect();\n+                                if (reconnectionHandler != null) {\n+                                    reconnectionHandler.cancel(false);\n+                                }\n+                            } catch (Exception e) {\n+                                logger.error(\"Reconnection failed\", e);", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220303", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489242805", "bodyText": "You should use the construtor which add the group id as a separate paramter.", "author": "Hilbrand", "createdAt": "2020-09-16T08:04:04Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusMemoHandler.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.velbus.internal.packets.VelbusMemoTextPacket;\n+\n+/**\n+ * The {@link VelbusMemoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class VelbusMemoHandler extends VelbusThermostatHandler {\n+    public static final int MEMO_TEXT_MAX_LENGTH = 63;\n+\n+    private final ChannelUID memoChannel = new ChannelUID(thing.getUID(), \"oledDisplay#MEMO\");", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220487", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzY3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489243679", "bodyText": "Same here. Use other constructor.", "author": "Hilbrand", "createdAt": "2020-09-16T08:05:31Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusMemoHandler.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.velbus.internal.packets.VelbusMemoTextPacket;\n+\n+/**\n+ * The {@link VelbusMemoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class VelbusMemoHandler extends VelbusThermostatHandler {\n+    public static final int MEMO_TEXT_MAX_LENGTH = 63;\n+\n+    private final ChannelUID memoChannel = new ChannelUID(thing.getUID(), \"oledDisplay#MEMO\");\n+\n+    public VelbusMemoHandler(Thing thing) {\n+        super(thing, 4, new ChannelUID(thing.getUID(), \"input#CH33\"));", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDYzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220635", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NDIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489244231", "bodyText": "Remove this variable and use this::readPackets", "author": "Hilbrand", "createdAt": "2020-09-16T08:06:28Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusNetworkBridgeHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link VelbusNetworkBridgeHandler} is the handler for a Velbus network interface and connects it to\n+ * the framework.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusNetworkBridgeHandler extends VelbusBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusNetworkBridgeHandler.class);\n+\n+    private @Nullable Socket socket;\n+\n+    public VelbusNetworkBridgeHandler(Bridge velbusBridge) {\n+        super(velbusBridge);\n+    }\n+\n+    /**\n+     * Runnable that handles inbound communication from Velbus network interface.\n+     * <p>\n+     * The thread listens to the TCP socket opened at initialization of the {@link VelbusNetworkBridgeHandler} class\n+     * and interprets all inbound velbus packets.\n+     */\n+    private Runnable networkEvents = () -> {", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220755", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NDIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NDkxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489244917", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.error(\"Error while closing socket\", e);\n          \n          \n            \n                            logger.debug(\"Error while closing socket\", e);", "author": "Hilbrand", "createdAt": "2020-09-16T08:07:34Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusNetworkBridgeHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link VelbusNetworkBridgeHandler} is the handler for a Velbus network interface and connects it to\n+ * the framework.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusNetworkBridgeHandler extends VelbusBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusNetworkBridgeHandler.class);\n+\n+    private @Nullable Socket socket;\n+\n+    public VelbusNetworkBridgeHandler(Bridge velbusBridge) {\n+        super(velbusBridge);\n+    }\n+\n+    /**\n+     * Runnable that handles inbound communication from Velbus network interface.\n+     * <p>\n+     * The thread listens to the TCP socket opened at initialization of the {@link VelbusNetworkBridgeHandler} class\n+     * and interprets all inbound velbus packets.\n+     */\n+    private Runnable networkEvents = () -> {\n+        readPackets();\n+    };\n+\n+    @Override\n+    protected void connect() {\n+        String address = (String) getConfig().get(ADDRESS);\n+        BigDecimal port = (BigDecimal) getConfig().get(PORT);\n+\n+        if (address != null && port != null) {\n+            int portInt = port.intValue();\n+            try {\n+                Socket socket = new Socket(address, portInt);\n+                this.socket = socket;\n+\n+                initializeStreams(socket.getOutputStream(), socket.getInputStream());\n+\n+                updateStatus(ThingStatus.ONLINE);\n+                logger.debug(\"Bridge online on network address {}:{}\", address, portInt);\n+            } catch (IOException ex) {\n+                onConnectionLost();\n+                logger.debug(\"Failed to connect to network address {}:{}\", address, port);\n+            }\n+\n+            // Start Velbus packet listener. This listener will act on all packets coming from\n+            // IP-interface.\n+            (new Thread(networkEvents)).start();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Network address or port not configured\");\n+            logger.debug(\"Network address or port not configured\");\n+        }\n+    }\n+\n+    @Override\n+    protected void disconnect() {\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+                logger.error(\"Error while closing socket\", e);", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220825", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NDI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489264266", "bodyText": "It would be better to create classes with the configuration options as fields and use getConfigAs in initialize method and store the configuration in a field object. That way you don't need to get the config everytime and don't need to convert the objects to usefull types.", "author": "Hilbrand", "createdAt": "2020-09-16T08:38:09Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -124,61 +157,125 @@ public synchronized void sendPacket(byte[] packet) {\n             return;\n         }\n \n-        try {\n-            outputStream.write(packet);\n-            outputStream.flush();\n-        } catch (IOException e) {\n-            logger.error(\"Serial port write error\", e);\n-        }\n+        writePacket(packet);\n \n         lastPacketTimeMillis = System.currentTimeMillis();\n     }\n \n-    public void setDefaultPacketListener(VelbusPacketListener velbusPacketListener) {\n-        defaultPacketListener = velbusPacketListener;\n+    private void readPacket(byte[] packet) {\n+        byte address = packet[2];\n+\n+        if (packetListeners.containsKey(address)) {\n+            VelbusPacketListener packetListener = packetListeners.get(address);\n+            packetListener.onPacketReceived(packet);\n+        } else if (defaultPacketListener != null) {\n+            defaultPacketListener.onPacketReceived(packet);\n+        }\n     }\n \n-    public void registerPacketListener(byte address, VelbusPacketListener packetListener) {\n-        if (packetListener == null) {\n-            throw new IllegalArgumentException(\"It's not allowed to pass a null RelayStatusListener.\");\n+    protected void readPackets() {\n+        if (inputStream == null) {\n+            onConnectionLost();\n+            return;\n         }\n \n-        packetListeners.put(Byte.valueOf(address), packetListener);\n+        byte[] packet;\n+\n+        listenerStopped = false;\n+\n+        try {\n+            while (!listenerStopped & ((packet = inputStream.readPacket()).length > 0)) {\n+                readPacket(packet);\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                onConnectionLost();\n+            }\n+        }\n     }\n \n-    public void unregisterRelayStatusListener(byte address, VelbusPacketListener packetListener) {\n-        packetListeners.remove(Byte.valueOf(address));\n+    private void writePacket(byte[] packet) {\n+        if (outputStream == null) {\n+            onConnectionLost();\n+            return;\n+        }\n+\n+        try {\n+            outputStream.write(packet);\n+            outputStream.flush();\n+        } catch (IOException e) {\n+            onConnectionLost();\n+        }\n     }\n \n-    @Override\n-    public void dispose() {\n-        if (serialPort != null) {\n-            serialPort.removeEventListener();\n-            serialPort.close();\n-            serialPort = null;\n+    protected void onConnectionLost() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"A network communication error occurred.\");\n+        disconnect();\n+        startReconnectionHandler();\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected void disconnect() {\n+        listenerStopped = true;\n+\n+        try {\n+            if (outputStream != null) {\n+                outputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing output stream\", e);\n+        }\n+\n+        try {\n+            if (inputStream != null) {\n+                inputStream.close();\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Error while closing input stream\", e);\n         }\n     }\n \n-    @Override\n-    public void serialEvent(SerialPortEvent event) {\n-        logger.debug(\"Serial port event triggered\");\n-\n-        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n-            try {\n-                byte[] packet;\n-                while ((packet = inputStream.readPacket()) != null) {\n-                    byte address = packet[2];\n-\n-                    VelbusPacketListener packetListener = packetListeners.get(address);\n-                    if (packetListener != null) {\n-                        packetListener.onPacketReceived(packet);\n-                    } else if (defaultPacketListener != null) {\n-                        defaultPacketListener.onPacketReceived(packet);\n-                    }\n+    public void startReconnectionHandler() {\n+        if (reconnectionHandler == null || reconnectionHandler.isCancelled()) {\n+            Object reconnectionIntervalObject = getConfig().get(RECONNECTION_INTERVAL);", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMDkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491220931", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NDk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489264967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.error(\"Error while closing socket\", e);\n          \n          \n            \n                            logger.debug(\"Error while closing socket\", e);", "author": "Hilbrand", "createdAt": "2020-09-16T08:38:57Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusNetworkBridgeHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link VelbusNetworkBridgeHandler} is the handler for a Velbus network interface and connects it to\n+ * the framework.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusNetworkBridgeHandler extends VelbusBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusNetworkBridgeHandler.class);\n+\n+    private @Nullable Socket socket;\n+\n+    public VelbusNetworkBridgeHandler(Bridge velbusBridge) {\n+        super(velbusBridge);\n+    }\n+\n+    /**\n+     * Runnable that handles inbound communication from Velbus network interface.\n+     * <p>\n+     * The thread listens to the TCP socket opened at initialization of the {@link VelbusNetworkBridgeHandler} class\n+     * and interprets all inbound velbus packets.\n+     */\n+    private Runnable networkEvents = () -> {\n+        readPackets();\n+    };\n+\n+    @Override\n+    protected void connect() {\n+        String address = (String) getConfig().get(ADDRESS);\n+        BigDecimal port = (BigDecimal) getConfig().get(PORT);\n+\n+        if (address != null && port != null) {\n+            int portInt = port.intValue();\n+            try {\n+                Socket socket = new Socket(address, portInt);\n+                this.socket = socket;\n+\n+                initializeStreams(socket.getOutputStream(), socket.getInputStream());\n+\n+                updateStatus(ThingStatus.ONLINE);\n+                logger.debug(\"Bridge online on network address {}:{}\", address, portInt);\n+            } catch (IOException ex) {\n+                onConnectionLost();\n+                logger.debug(\"Failed to connect to network address {}:{}\", address, port);\n+            }\n+\n+            // Start Velbus packet listener. This listener will act on all packets coming from\n+            // IP-interface.\n+            (new Thread(networkEvents)).start();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Network address or port not configured\");\n+            logger.debug(\"Network address or port not configured\");\n+        }\n+    }\n+\n+    @Override\n+    protected void disconnect() {\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+                logger.error(\"Error while closing socket\", e);", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMTAwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491221001", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489266625", "bodyText": "I'm assuming you stop this thread indirectly by closing the stream and setting reconnect to false?\nYou should set the thread name to something like \"OH-binding-\" + thingUID and setDeamon to true.", "author": "Hilbrand", "createdAt": "2020-09-16T08:41:32Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusNetworkBridgeHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link VelbusNetworkBridgeHandler} is the handler for a Velbus network interface and connects it to\n+ * the framework.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusNetworkBridgeHandler extends VelbusBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusNetworkBridgeHandler.class);\n+\n+    private @Nullable Socket socket;\n+\n+    public VelbusNetworkBridgeHandler(Bridge velbusBridge) {\n+        super(velbusBridge);\n+    }\n+\n+    /**\n+     * Runnable that handles inbound communication from Velbus network interface.\n+     * <p>\n+     * The thread listens to the TCP socket opened at initialization of the {@link VelbusNetworkBridgeHandler} class\n+     * and interprets all inbound velbus packets.\n+     */\n+    private Runnable networkEvents = () -> {\n+        readPackets();\n+    };\n+\n+    @Override\n+    protected void connect() {\n+        String address = (String) getConfig().get(ADDRESS);\n+        BigDecimal port = (BigDecimal) getConfig().get(PORT);\n+\n+        if (address != null && port != null) {\n+            int portInt = port.intValue();\n+            try {\n+                Socket socket = new Socket(address, portInt);\n+                this.socket = socket;\n+\n+                initializeStreams(socket.getOutputStream(), socket.getInputStream());\n+\n+                updateStatus(ThingStatus.ONLINE);\n+                logger.debug(\"Bridge online on network address {}:{}\", address, portInt);\n+            } catch (IOException ex) {\n+                onConnectionLost();\n+                logger.debug(\"Failed to connect to network address {}:{}\", address, port);\n+            }\n+\n+            // Start Velbus packet listener. This listener will act on all packets coming from\n+            // IP-interface.\n+            (new Thread(networkEvents)).start();", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMTg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491221898", "bodyText": "Modified in commit 780323c.\nThe thread is indeed stopped by closing the stream.", "author": "cedricboon", "createdAt": "2020-09-18T22:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NjYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NzY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489267683", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else\n          \n          \n            \n                    } else {", "author": "Hilbrand", "createdAt": "2020-09-16T08:43:05Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusSerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.PORT;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link VelbusSerialBridgeHandler} is the handler for a Velbus Serial-interface and connects it to\n+ * the framework.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusSerialBridgeHandler extends VelbusBridgeHandler implements SerialPortEventListener {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusSerialBridgeHandler.class);\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    public VelbusSerialBridgeHandler(Bridge velbusBridge, SerialPortManager serialPortManager) {\n+        super(velbusBridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        logger.debug(\"Serial port event triggered\");\n+\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            readPackets();\n+        }\n+    }\n+\n+    @Override\n+    protected void connect() {\n+        String port = (String) getConfig().get(PORT);\n+        if (port != null) {\n+            // parse ports and if the port is found, initialize the reader\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+                return;\n+            }\n+\n+            // initialize serial port\n+            try {\n+                SerialPort serialPort = portId.open(getThing().getUID().toString(), 2000);\n+                this.serialPort = serialPort;\n+\n+                OutputStream outputStream = serialPort.getOutputStream();\n+                InputStream inputStream = serialPort.getInputStream();\n+\n+                if (outputStream != null && inputStream != null) {\n+                    initializeStreams(outputStream, inputStream);\n+\n+                    serialPort.addEventListener(this);\n+                    serialPort.notifyOnDataAvailable(true);\n+\n+                    updateStatus(ThingStatus.ONLINE);\n+                    logger.debug(\"Bridge online on serial port {}\", port);\n+                }\n+            } catch (final IOException ex) {\n+                onConnectionLost();\n+                logger.debug(\"I/O error on serial port {}\", port);\n+            } catch (PortInUseException e) {\n+                onConnectionLost();\n+                logger.debug(\"Port {} is in use\", port);\n+            } catch (TooManyListenersException e) {\n+                onConnectionLost();\n+                logger.debug(\"Cannot attach listener to port {}\", port);\n+            }\n+        } else", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMjkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491222921", "bodyText": "Removed the \"else\" part in commit 780323c, as a result of using classes with the configuration options, loaded by getConfigAs.", "author": "cedricboon", "createdAt": "2020-09-18T22:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NzY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2ODM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489268369", "bodyText": "Use the constructor with separate group paramter", "author": "Hilbrand", "createdAt": "2020-09-16T08:44:13Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.CommonTriggerEvents;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSensorSettingsRequestPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetTemperaturePacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusThermostatModePacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusThermostatOperatingModePacket;\n+\n+/**\n+ * The {@link VelbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class VelbusThermostatHandler extends VelbusTemperatureSensorHandler {\n+    private static final double THERMOSTAT_TEMPERATURE_SETPOINT_RESOLUTION = 0.5;\n+\n+    private static final StringType OPERATING_MODE_HEATING = new StringType(\"HEATING\");\n+    private static final StringType OPERATING_MODE_COOLING = new StringType(\"COOLING\");\n+\n+    private static final byte OPERATING_MODE_MASK = (byte) 0x80;\n+    private static final byte COOLING_MODE_MASK = (byte) 0x80;\n+\n+    private static final StringType MODE_COMFORT = new StringType(\"COMFORT\");\n+    private static final StringType MODE_DAY = new StringType(\"DAY\");\n+    private static final StringType MODE_NIGHT = new StringType(\"NIGHT\");\n+    private static final StringType MODE_SAFE = new StringType(\"SAFE\");\n+\n+    private static final byte MODE_MASK = (byte) 0x70;\n+    private static final byte COMFORT_MODE_MASK = (byte) 0x40;\n+    private static final byte DAY_MODE_MASK = (byte) 0x20;\n+    private static final byte NIGHT_MODE_MASK = (byte) 0x10;\n+\n+    private final ChannelUID currentTemperatureSetpointChannel = new ChannelUID(thing.getUID(),", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2OTU5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489269593", "bodyText": "These can be static final?", "author": "Hilbrand", "createdAt": "2020-09-16T08:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2ODM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491223640", "bodyText": "It doens't look like it can, as the non-static field \"thing\" is used in the ChannelUID constructor to get the thing's UID.", "author": "cedricboon", "createdAt": "2020-09-18T22:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2ODM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI3MjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489272154", "bodyText": "Just get the value without group id in the line above and you can remove this if statement check", "author": "Hilbrand", "createdAt": "2020-09-16T08:49:49Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusThingHandler.java", "diffHunk": "@@ -137,49 +153,79 @@ private void initializeChannelNames() {\n         for (int i = 0; i < channels.size(); i++) {\n             Channel channel = channels.get(i);\n             String channelUID = channel.getUID().getId();\n+\n+            if (channelUID.contains(\"#\")) {", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNDEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491224100", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI3MjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI3Mzc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489273740", "bodyText": "Use constructor with groupid parameter", "author": "Hilbrand", "createdAt": "2020-09-16T08:52:06Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusVMBGPHandler.java", "diffHunk": "@@ -28,11 +29,13 @@\n  *\n  * @author Cedric Boon - Initial contribution\n  */\n-public class VelbusVMBGPHandler extends VelbusTemperatureSensorHandler {\n-    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMBGP1,\n-            THING_TYPE_VMBGP2, THING_TYPE_VMBGP4, THING_TYPE_VMBGP4, THING_TYPE_VMBGP4PIR));\n+@NonNullByDefault\n+public class VelbusVMBGPHandler extends VelbusThermostatHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n+            Arrays.asList(THING_TYPE_VMBGP1, THING_TYPE_VMBGP1_2, THING_TYPE_VMBGP2, THING_TYPE_VMBGP2_2,\n+                    THING_TYPE_VMBGP4, THING_TYPE_VMBGP4_2, THING_TYPE_VMBGP4PIR, THING_TYPE_VMBGP4PIR_2));\n \n     public VelbusVMBGPHandler(Thing thing) {\n-        super(thing, 4, new ChannelUID(thing.getUID(), \"CH9\"));\n+        super(thing, 4, new ChannelUID(thing.getUID(), \"input#CH9\"));", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNDE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491224196", "bodyText": "Modified in commit  780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI3Mzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NTQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489295442", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            boolean enabled = (command == OnOffType.ON) ? true : false;\n          \n          \n            \n                            boolean enabled = command == OnOffType.ON;", "author": "Hilbrand", "createdAt": "2020-09-16T09:25:51Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusSensorWithAlarmClockHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.VelbusClockAlarm;\n+import org.openhab.binding.velbus.internal.VelbusClockAlarmConfiguration;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetLocalClockAlarmPacket;\n+\n+/**\n+ * The {@link VelbusSensorWithAlarmClockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusSensorWithAlarmClockHandler extends VelbusSensorHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMB2PBN,\n+            THING_TYPE_VMB6PBN, THING_TYPE_VMB8PBU, THING_TYPE_VMBPIRC, THING_TYPE_VMBPIRM, THING_TYPE_VMBRFR8S));\n+    private static final HashMap<ThingTypeUID, Integer> ALARM_CONFIGURATION_MEMORY_ADDRESSES = new HashMap<ThingTypeUID, Integer>();\n+\n+    static {\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB2PBN, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB4AN, 0x0046);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB6PBN, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB7IN, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB8PBU, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBEL1, 0x0357);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBEL2, 0x0357);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBEL4, 0x0357);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBELO, 0x0593);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBPIRC, 0x0031);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBPIRM, 0x0031);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBPIRO, 0x0031);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBMETEO, 0x0083);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP1, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP1_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP2_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4PIR, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4PIR_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGPO, 0x0284);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGPOD, 0x0284);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGPOD_2, 0x0284);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBRFR8S, 0x0093);\n+    }\n+\n+    private static final byte ALARM_CONFIGURATION_MEMORY_SIZE = 0x09;\n+    private static final byte ALARM_1_ENABLED_MASK = 0x01;\n+    private static final byte ALARM_1_TYPE_MASK = 0x02;\n+    private static final byte ALARM_2_ENABLED_MASK = 0x04;\n+    private static final byte ALARM_2_TYPE_MASK = 0x08;\n+\n+    private static final StringType ALARM_TYPE_LOCAL = new StringType(\"LOCAL\");\n+    private static final StringType ALARM_TYPE_GLOBAL = new StringType(\"GLOBAL\");\n+\n+    private final ChannelUID clockAlarm1Enabled = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM1ENABLED\");\n+    private final ChannelUID clockAlarm1Type = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM1TYPE\");\n+    private final ChannelUID clockAlarm1WakeupHour = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM1WAKEUPHOUR\");\n+    private final ChannelUID clockAlarm1WakeupMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM1WAKEUPMINUTE\");\n+    private final ChannelUID clockAlarm1BedtimeHour = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM1BEDTIMEHOUR\");\n+    private final ChannelUID clockAlarm1BedtimeMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM1BEDTIMEMINUTE\");\n+    private final ChannelUID clockAlarm2Enabled = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM2ENABLED\");\n+    private final ChannelUID clockAlarm2Type = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM2TYPE\");\n+    private final ChannelUID clockAlarm2WakeupHour = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM2WAKEUPHOUR\");\n+    private final ChannelUID clockAlarm2WakeupMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM2WAKEUPMINUTE\");\n+    private final ChannelUID clockAlarm2BedtimeHour = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM2BEDTIMEHOUR\");\n+    private final ChannelUID clockAlarm2BedtimeMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM2BEDTIMEMINUTE\");\n+\n+    private int clockAlarmConfigurationMemoryAddress;\n+    private VelbusClockAlarmConfiguration alarmClockConfiguration = new VelbusClockAlarmConfiguration();\n+\n+    public VelbusSensorWithAlarmClockHandler(Thing thing) {\n+        this(thing, 0);\n+    }\n+\n+    public VelbusSensorWithAlarmClockHandler(Thing thing, int numberOfSubAddresses) {\n+        super(thing, numberOfSubAddresses);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        if (ALARM_CONFIGURATION_MEMORY_ADDRESSES.containsKey(thing.getThingTypeUID())) {\n+            this.clockAlarmConfigurationMemoryAddress = ALARM_CONFIGURATION_MEMORY_ADDRESSES\n+                    .get(thing.getThingTypeUID());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        super.handleCommand(channelUID, command);\n+\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        if (isAlarmClockChannel(channelUID) && command instanceof RefreshType) {\n+            sendReadMemoryBlockPacket(velbusBridgeHandler, this.clockAlarmConfigurationMemoryAddress + 0);\n+            sendReadMemoryBlockPacket(velbusBridgeHandler, this.clockAlarmConfigurationMemoryAddress + 4);\n+            sendReadMemoryPacket(velbusBridgeHandler, this.clockAlarmConfigurationMemoryAddress + 8);\n+        } else if (isAlarmClockChannel(channelUID)) {\n+            byte alarmNumber = determineAlarmNumber(channelUID);\n+            VelbusClockAlarm alarmClock = alarmClockConfiguration.getAlarmClock(alarmNumber);\n+\n+            if ((channelUID.equals(clockAlarm1Enabled) || channelUID.equals(clockAlarm2Enabled))\n+                    && command instanceof OnOffType) {\n+                boolean enabled = (command == OnOffType.ON) ? true : false;", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491217773", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NTQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NTYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489295637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            boolean isLocal = (((StringType) command).equals(ALARM_TYPE_LOCAL)) ? true : false;\n          \n          \n            \n                            boolean isLocal = ((StringType) command).equals(ALARM_TYPE_LOCAL);", "author": "Hilbrand", "createdAt": "2020-09-16T09:26:08Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusSensorWithAlarmClockHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.VelbusClockAlarm;\n+import org.openhab.binding.velbus.internal.VelbusClockAlarmConfiguration;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetLocalClockAlarmPacket;\n+\n+/**\n+ * The {@link VelbusSensorWithAlarmClockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusSensorWithAlarmClockHandler extends VelbusSensorHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMB2PBN,\n+            THING_TYPE_VMB6PBN, THING_TYPE_VMB8PBU, THING_TYPE_VMBPIRC, THING_TYPE_VMBPIRM, THING_TYPE_VMBRFR8S));\n+    private static final HashMap<ThingTypeUID, Integer> ALARM_CONFIGURATION_MEMORY_ADDRESSES = new HashMap<ThingTypeUID, Integer>();\n+\n+    static {\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB2PBN, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB4AN, 0x0046);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB6PBN, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB7IN, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMB8PBU, 0x0093);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBEL1, 0x0357);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBEL2, 0x0357);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBEL4, 0x0357);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBELO, 0x0593);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBPIRC, 0x0031);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBPIRM, 0x0031);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBPIRO, 0x0031);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBMETEO, 0x0083);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP1, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP1_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP2_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4PIR, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGP4PIR_2, 0x00A4);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGPO, 0x0284);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGPOD, 0x0284);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBGPOD_2, 0x0284);\n+        ALARM_CONFIGURATION_MEMORY_ADDRESSES.put(THING_TYPE_VMBRFR8S, 0x0093);\n+    }\n+\n+    private static final byte ALARM_CONFIGURATION_MEMORY_SIZE = 0x09;\n+    private static final byte ALARM_1_ENABLED_MASK = 0x01;\n+    private static final byte ALARM_1_TYPE_MASK = 0x02;\n+    private static final byte ALARM_2_ENABLED_MASK = 0x04;\n+    private static final byte ALARM_2_TYPE_MASK = 0x08;\n+\n+    private static final StringType ALARM_TYPE_LOCAL = new StringType(\"LOCAL\");\n+    private static final StringType ALARM_TYPE_GLOBAL = new StringType(\"GLOBAL\");\n+\n+    private final ChannelUID clockAlarm1Enabled = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM1ENABLED\");\n+    private final ChannelUID clockAlarm1Type = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM1TYPE\");\n+    private final ChannelUID clockAlarm1WakeupHour = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM1WAKEUPHOUR\");\n+    private final ChannelUID clockAlarm1WakeupMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM1WAKEUPMINUTE\");\n+    private final ChannelUID clockAlarm1BedtimeHour = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM1BEDTIMEHOUR\");\n+    private final ChannelUID clockAlarm1BedtimeMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM1BEDTIMEMINUTE\");\n+    private final ChannelUID clockAlarm2Enabled = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM2ENABLED\");\n+    private final ChannelUID clockAlarm2Type = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM2TYPE\");\n+    private final ChannelUID clockAlarm2WakeupHour = new ChannelUID(thing.getUID(), \"clockAlarm#CLOCKALARM2WAKEUPHOUR\");\n+    private final ChannelUID clockAlarm2WakeupMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM2WAKEUPMINUTE\");\n+    private final ChannelUID clockAlarm2BedtimeHour = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM2BEDTIMEHOUR\");\n+    private final ChannelUID clockAlarm2BedtimeMinute = new ChannelUID(thing.getUID(),\n+            \"clockAlarm#CLOCKALARM2BEDTIMEMINUTE\");\n+\n+    private int clockAlarmConfigurationMemoryAddress;\n+    private VelbusClockAlarmConfiguration alarmClockConfiguration = new VelbusClockAlarmConfiguration();\n+\n+    public VelbusSensorWithAlarmClockHandler(Thing thing) {\n+        this(thing, 0);\n+    }\n+\n+    public VelbusSensorWithAlarmClockHandler(Thing thing, int numberOfSubAddresses) {\n+        super(thing, numberOfSubAddresses);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        if (ALARM_CONFIGURATION_MEMORY_ADDRESSES.containsKey(thing.getThingTypeUID())) {\n+            this.clockAlarmConfigurationMemoryAddress = ALARM_CONFIGURATION_MEMORY_ADDRESSES\n+                    .get(thing.getThingTypeUID());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        super.handleCommand(channelUID, command);\n+\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        if (isAlarmClockChannel(channelUID) && command instanceof RefreshType) {\n+            sendReadMemoryBlockPacket(velbusBridgeHandler, this.clockAlarmConfigurationMemoryAddress + 0);\n+            sendReadMemoryBlockPacket(velbusBridgeHandler, this.clockAlarmConfigurationMemoryAddress + 4);\n+            sendReadMemoryPacket(velbusBridgeHandler, this.clockAlarmConfigurationMemoryAddress + 8);\n+        } else if (isAlarmClockChannel(channelUID)) {\n+            byte alarmNumber = determineAlarmNumber(channelUID);\n+            VelbusClockAlarm alarmClock = alarmClockConfiguration.getAlarmClock(alarmNumber);\n+\n+            if ((channelUID.equals(clockAlarm1Enabled) || channelUID.equals(clockAlarm2Enabled))\n+                    && command instanceof OnOffType) {\n+                boolean enabled = (command == OnOffType.ON) ? true : false;\n+                alarmClock.setEnabled(enabled);\n+            } else if ((channelUID.equals(clockAlarm1Type) || channelUID.equals(clockAlarm2Type))\n+                    && command instanceof StringType) {\n+                boolean isLocal = (((StringType) command).equals(ALARM_TYPE_LOCAL)) ? true : false;", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491217967", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NjgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489296827", "bodyText": "Just check the group id.", "author": "Hilbrand", "createdAt": "2020-09-16T09:27:57Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusSensorHandler.java", "diffHunk": "@@ -32,21 +37,62 @@\n  *\n  * @author Cedric Boon - Initial contribution\n  */\n+@NonNullByDefault\n public class VelbusSensorHandler extends VelbusThingHandler {\n     public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(\n-            Arrays.asList(THING_TYPE_VMB2PBN, THING_TYPE_VMB6IN, THING_TYPE_VMB6PBN, THING_TYPE_VMB7IN,\n-                    THING_TYPE_VMB8IR, THING_TYPE_VMB8PB, THING_TYPE_VMB8PBU, THING_TYPE_VMBPIRC, THING_TYPE_VMBPIRM));\n+            Arrays.asList(THING_TYPE_VMB6IN, THING_TYPE_VMB8IR, THING_TYPE_VMB8PB));\n+\n+    private static final StringType SET_LED = new StringType(\"SET_LED\");\n+    private static final StringType SLOW_BLINK_LED = new StringType(\"SLOW_BLINK_LED\");\n+    private static final StringType FAST_BLINK_LED = new StringType(\"FAST_BLINK_LED\");\n+    private static final StringType VERY_FAST_BLINK_LED = new StringType(\"VERY_FAST_BLINK_LED\");\n+    private static final StringType CLEAR_LED = new StringType(\"CLEAR_LED\");\n \n     public VelbusSensorHandler(Thing thing) {\n         this(thing, 0);\n     }\n \n     public VelbusSensorHandler(Thing thing, int numberOfSubAddresses) {\n-        super(thing, numberOfSubAddresses, null);\n+        super(thing, numberOfSubAddresses);\n     }\n \n     @Override\n     public void handleCommand(ChannelUID channelUID, Command command) {\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        if (isFeedbackChannel(channelUID) && command instanceof StringType) {\n+            byte commandByte;\n+\n+            StringType stringTypeCommand = (StringType) command;\n+            if (stringTypeCommand.equals(SET_LED)) {\n+                commandByte = COMMAND_SET_LED;\n+            } else if (stringTypeCommand.equals(SLOW_BLINK_LED)) {\n+                commandByte = COMMAND_SLOW_BLINK_LED;\n+            } else if (stringTypeCommand.equals(FAST_BLINK_LED)) {\n+                commandByte = COMMAND_FAST_BLINK_LED;\n+            } else if (stringTypeCommand.equals(VERY_FAST_BLINK_LED)) {\n+                commandByte = COMMAND_VERY_FAST_BLINK_LED;\n+            } else if (stringTypeCommand.equals(CLEAR_LED)) {\n+                commandByte = COMMAND_CLEAR_LED;\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \"The command '\" + command + \"' is not supported on channel '\" + channelUID + \"'.\");\n+            }\n+\n+            VelbusFeedbackLEDPacket packet = new VelbusFeedbackLEDPacket(\n+                    getModuleAddress().getChannelIdentifier(channelUID), commandByte);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        }\n+    }\n+\n+    private boolean isFeedbackChannel(ChannelUID channelUID) {\n+        return channelUID.getId().startsWith(\"feedback#\");", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxODE4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491218186", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5ODMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r489298318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Map<Byte, VelbusPacketListener> packetListeners = new HashMap<Byte, VelbusPacketListener>();\n          \n          \n            \n                protected Map<Byte, VelbusPacketListener> packetListeners = new HashMap<>();", "author": "Hilbrand", "createdAt": "2020-09-16T09:30:15Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusBridgeHandler.java", "diffHunk": "@@ -12,101 +12,134 @@\n  */\n package org.openhab.binding.velbus.internal.handler;\n \n-import static org.openhab.binding.velbus.internal.VelbusBindingConstants.PORT;\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n \n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.TooManyListenersException;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.thing.Bridge;\n import org.eclipse.smarthome.core.thing.ChannelUID;\n import org.eclipse.smarthome.core.thing.ThingStatus;\n import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n import org.eclipse.smarthome.core.types.Command;\n-import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n-import org.eclipse.smarthome.io.transport.serial.SerialPort;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n-import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n import org.openhab.binding.velbus.internal.VelbusPacketInputStream;\n import org.openhab.binding.velbus.internal.VelbusPacketListener;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetDatePacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetDaylightSavingsStatusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSetRealtimeClockPacket;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * {@link VelbusBridgeHandler} is the handler for a Velbus Serial-interface and connects it to\n+ * {@link VelbusBridgeHandler} is an abstract handler for a Velbus interface and connects it to\n  * the framework.\n  *\n  * @author Cedric Boon - Initial contribution\n  */\n-public class VelbusBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+@NonNullByDefault\n+public abstract class VelbusBridgeHandler extends BaseBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(VelbusBridgeHandler.class);\n \n-    private Logger logger = LoggerFactory.getLogger(VelbusBridgeHandler.class);\n-\n-    private static final int BAUD = 9600;\n-    private SerialPort serialPort;\n-    private final SerialPortManager serialPortManager;\n-    private OutputStream outputStream;\n-    private VelbusPacketInputStream inputStream;\n     private long lastPacketTimeMillis;\n \n-    private VelbusPacketListener defaultPacketListener;\n-    private final Map<Byte, VelbusPacketListener> packetListeners = new HashMap<>();\n+    protected @Nullable VelbusPacketListener defaultPacketListener;\n+    protected Map<Byte, VelbusPacketListener> packetListeners = new HashMap<Byte, VelbusPacketListener>();", "originalCommit": "798f00cf377672939117416ae770b50130ec6a75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxODM1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491218358", "bodyText": "Modified in commit 780323c", "author": "cedricboon", "createdAt": "2020-09-18T22:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5ODMxOA=="}], "type": "inlineReview"}, {"oid": "780323c7a485e9e17fdb82dfd9dd4c19f9e71954", "url": "https://github.com/openhab/openhab-addons/commit/780323c7a485e9e17fdb82dfd9dd4c19f9e71954", "message": "Changes after review\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-18T22:08:08Z", "type": "commit"}, {"oid": "93824bedc1a4558f46d27ec56e62fda4ef269530", "url": "https://github.com/openhab/openhab-addons/commit/93824bedc1a4558f46d27ec56e62fda4ef269530", "message": "Changes after review\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-18T23:05:14Z", "type": "forcePushed"}, {"oid": "5ca761c60a9a5733c6a3f565cf008082143b5464", "url": "https://github.com/openhab/openhab-addons/commit/5ca761c60a9a5733c6a3f565cf008082143b5464", "message": "Changes after review\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-18T23:09:15Z", "type": "commit"}, {"oid": "5ca761c60a9a5733c6a3f565cf008082143b5464", "url": "https://github.com/openhab/openhab-addons/commit/5ca761c60a9a5733c6a3f565cf008082143b5464", "message": "Changes after review\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-18T23:09:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MjgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491282819", "bodyText": "Better to use primitives:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) Integer timeUpdateInterval;\n          \n          \n            \n                public @NonNullByDefault({}) Integer reconnectionInterval;\n          \n          \n            \n                public int timeUpdateInterval;\n          \n          \n            \n                public int reconnectionInterval;", "author": "Hilbrand", "createdAt": "2020-09-19T06:02:40Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusBridgeConfig.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusBridgeConfig} class represents the configuration of a Velbus Bridge.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusBridgeConfig {\n+    public @NonNullByDefault({}) Integer timeUpdateInterval;\n+    public @NonNullByDefault({}) Integer reconnectionInterval;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNjE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491326194", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MjgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MzQwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491283404", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) String address;\n          \n          \n            \n                public @NonNullByDefault({}) Integer port;\n          \n          \n            \n                public String address = \"\";\n          \n          \n            \n                public int port;", "author": "Hilbrand", "createdAt": "2020-09-19T06:04:40Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusNetworkBridgeConfig.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusNetworkBridgeConfig} class represents the configuration of a Velbus Network Bridge.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusNetworkBridgeConfig {\n+    public @NonNullByDefault({}) String address;\n+    public @NonNullByDefault({}) Integer port;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNjI4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491326282", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MzQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MzQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491283468", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) Integer dimspeed;\n          \n          \n            \n            }\n          \n          \n            \n                public int dimspeed;\n          \n          \n            \n            }", "author": "Hilbrand", "createdAt": "2020-09-19T06:04:59Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusDimmerConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusDimmerConfig} class represents the configuration of a Velbus dimmer.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusDimmerConfig {\n+    public @NonNullByDefault({}) Integer dimspeed;\n+}", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNjQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491326419", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MzQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MzU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491283589", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) Integer refresh;\n          \n          \n            \n                public int refresh;", "author": "Hilbrand", "createdAt": "2020-09-19T06:05:22Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusSensorConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusSensorConfig} class represents the configuration of a Velbus Temperature Sensor.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusSensorConfig {\n+    public @NonNullByDefault({}) Integer refresh;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNjYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491326629", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4Mzc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491283777", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) String port;\n          \n          \n            \n                public String port = \"\";", "author": "Hilbrand", "createdAt": "2020-09-19T06:05:57Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusSerialBridgeConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusSerialBridgeConfig} class represents the configuration of a Velbus Serial Bridge.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusSerialBridgeConfig {\n+    public @NonNullByDefault({}) String port;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491327077", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4Mzc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4Mzg1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491283859", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) String address;\n          \n          \n            \n                public String address = \"\";", "author": "Hilbrand", "createdAt": "2020-09-19T06:06:15Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusThingConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusThingConfig} class represents the configuration of a Velbus thing.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusThingConfig {\n+    public @NonNullByDefault({}) String address;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzE5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491327192", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4Mzg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491284009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @NonNullByDefault({}) Double counter1PulseMultiplier;\n          \n          \n            \n                public @NonNullByDefault({}) Double counter2PulseMultiplier;\n          \n          \n            \n                public @NonNullByDefault({}) Double counter3PulseMultiplier;\n          \n          \n            \n                public @NonNullByDefault({}) Double counter4PulseMultiplier;\n          \n          \n            \n                public double counter1PulseMultiplier;\n          \n          \n            \n                public double counter2PulseMultiplier;\n          \n          \n            \n                public double counter3PulseMultiplier;\n          \n          \n            \n                public double counter4PulseMultiplier;", "author": "Hilbrand", "createdAt": "2020-09-19T06:06:46Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/config/VelbusVMB7INConfig.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link VelbusVMB7INConfig} class represents the configuration of a Velbus VMB7IN module.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusVMB7INConfig extends VelbusSensorConfig {\n+    public @NonNullByDefault({}) Double counter1PulseMultiplier;\n+    public @NonNullByDefault({}) Double counter2PulseMultiplier;\n+    public @NonNullByDefault({}) Double counter3PulseMultiplier;\n+    public @NonNullByDefault({}) Double counter4PulseMultiplier;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzMwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491327301", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzIwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491287209", "bodyText": "String comparison should not be using ==:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return channelUID.getGroupId() == ANALOG_OUTPUT_GROUP;\n          \n          \n            \n                    return ANALOG_OUTPUT_GROUP.equals(channelUID.getGroupId());", "author": "Hilbrand", "createdAt": "2020-09-19T06:16:49Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusVMB4ANHandler.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.VelbusChannelIdentifier;\n+import org.openhab.binding.velbus.internal.config.VelbusSensorConfig;\n+import org.openhab.binding.velbus.internal.packets.VelbusDimmerPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSensorReadoutRequestPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusStatusRequestPacket;\n+\n+/**\n+ * The {@link VelbusVMB4ANHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusVMB4ANHandler extends VelbusSensorWithAlarmClockHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMB4AN));\n+\n+    private static final String ALARM_GROUP = \"alarm\";\n+    private static final String ANALOG_INPUT_GROUP = \"analogInput\";\n+    private static final String ANALOG_OUTPUT_GROUP = \"analogOutput\";\n+    private static final String RAW_CHANNEL_SUFFIX = \"Raw\";\n+\n+    private static final byte VOLTAGE_SENSOR_TYPE = 0x00;\n+    private static final byte CURRENT_SENSOR_TYPE = 0x01;\n+    private static final byte RESISTANCE_SENSOR_TYPE = 0x02;\n+    private static final byte PERIOD_MEASUREMENT_SENSOR_TYPE = 0x03;\n+\n+    private String[] channelText = new String[] { \"\", \"\", \"\", \"\" };\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) VelbusSensorConfig sensorConfig;\n+\n+    public VelbusVMB4ANHandler(Thing thing) {\n+        super(thing, 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        this.sensorConfig = getConfigAs(VelbusSensorConfig.class);\n+\n+        super.initialize();\n+\n+        initializeAutomaticRefresh();\n+    }\n+\n+    private void initializeAutomaticRefresh() {\n+        int refreshInterval = sensorConfig.refresh;\n+\n+        if (refreshInterval > 0) {\n+            startAutomaticRefresh(refreshInterval);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+    }\n+\n+    private void startAutomaticRefresh(int refreshInterval) {\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            sendSensorReadoutRequest(velbusBridgeHandler, ALL_CHANNELS);\n+        }, 0, refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        super.handleCommand(channelUID, command);\n+\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        byte channelByte = convertChannelUIDToChannelByte(channelUID);\n+\n+        if (command instanceof RefreshType) {\n+            VelbusStatusRequestPacket packet = new VelbusStatusRequestPacket(channelByte);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        } else if (command instanceof PercentType && isAnalogOutputChannel(channelUID)) {\n+            VelbusDimmerPacket packet = new VelbusDimmerPacket(\n+                    new VelbusChannelIdentifier(this.getModuleAddress().getAddress(), channelByte), COMMAND_SET_VALUE,\n+                    ((PercentType) command).byteValue(), 0x00, false);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        }\n+    }\n+\n+    protected void sendSensorReadoutRequest(VelbusBridgeHandler velbusBridgeHandler, byte channel) {\n+        VelbusSensorReadoutRequestPacket packet = new VelbusSensorReadoutRequestPacket(getModuleAddress().getAddress(),\n+                channel);\n+\n+        byte[] packetBytes = packet.getBytes();\n+        velbusBridgeHandler.sendPacket(packetBytes);\n+    }\n+\n+    @Override\n+    public void onPacketReceived(byte[] packet) {\n+        super.onPacketReceived(packet);\n+\n+        logger.trace(\"onPacketReceived() was called\");\n+\n+        if (packet[0] == VelbusPacket.STX && packet.length >= 5) {\n+            byte command = packet[4];\n+\n+            if (command == COMMAND_SENSOR_RAW_DATA && packet.length >= 10) {\n+                byte channel = packet[5];\n+                byte operatingMode = packet[6];\n+                byte upperByteSensorValue = packet[7];\n+                byte highByteSensorValue = packet[8];\n+                byte lowByteSensorValue = packet[9];\n+\n+                double sensorValue = (((upperByteSensorValue & 0xff) << 16) + ((highByteSensorValue & 0xff) << 8)\n+                        + (lowByteSensorValue & 0xff));\n+                String channelUID = convertAnalogInputChannelByteToRawChannelUID(channel);\n+\n+                switch (operatingMode) {\n+                    case VOLTAGE_SENSOR_TYPE:\n+                        double voltageResolution = 0.25;\n+                        double voltageSensorValueState = sensorValue * voltageResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(voltageSensorValueState, MetricPrefix.MILLI(SmartHomeUnits.VOLT)));\n+                        break;\n+                    case CURRENT_SENSOR_TYPE:\n+                        double currentResolution = 5;\n+                        double currentSensorValueState = sensorValue * currentResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(currentSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.AMPERE)));\n+                        break;\n+                    case RESISTANCE_SENSOR_TYPE:\n+                        double resistanceResolution = 0.25;\n+                        double resistanceSensorValueState = sensorValue * resistanceResolution;\n+                        updateState(channelUID, new QuantityType<>(resistanceSensorValueState, SmartHomeUnits.OHM));\n+                        break;\n+                    case PERIOD_MEASUREMENT_SENSOR_TYPE:\n+                        double periodResolution = 0.5;\n+                        double periodSensorValueState = sensorValue * periodResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(periodSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.SECOND)));\n+                        break;\n+                }\n+            } else if (command == COMMAND_TEXT) {\n+                byte channel = packet[5];\n+                byte textStartPosition = packet[6];\n+\n+                StringBuilder contents = new StringBuilder();\n+                for (int i = 7; i < packet.length - 2; i++) {\n+                    byte currentChar = packet[i];\n+                    if (currentChar == (byte) -0x50) {\n+                        contents.append(\"\u00b0\");\n+                    } else if (currentChar != (byte) 0x00) {\n+                        contents.append((char) currentChar);\n+                    }\n+                }\n+\n+                channelText[channel - 9] = channelText[channel - 9].substring(0, textStartPosition)\n+                        + contents.toString()\n+                        + (channelText[channel - 9].length() > textStartPosition + 5 ? channelText[channel - 9]\n+                                .substring(textStartPosition + 5, channelText[channel - 9].length()) : \"\");\n+\n+                String channelUID = convertAnalogInputChannelByteToChannelUID(channel);\n+                updateState(channelUID, new StringType(channelText[channel - 9]));\n+            }\n+        }\n+    }\n+\n+    protected byte convertChannelUIDToChannelByte(ChannelUID channelUID) {\n+        if (isAlarmChannel(channelUID)) {\n+            return convertAlarmChannelUIDToChannelByte(channelUID);\n+        } else if (isTextAnalogInputChannel(channelUID)) {\n+            return convertTextAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isRawAnalogInputChannel(channelUID)) {\n+            return convertRawAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isAnalogOutputChannel(channelUID)) {\n+            return convertAnalogOutputChannelUIDToChannelByte(channelUID);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The channel '\" + channelUID + \"' is not supported on a VMB4AN module.\");\n+        }\n+    }\n+\n+    protected boolean isAlarmChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ALARM_GROUP;\n+    }\n+\n+    protected byte convertAlarmChannelUIDToChannelByte(ChannelUID channelUID) {\n+        return Byte.parseByte(channelUID.getIdWithoutGroup());\n+    }\n+\n+    protected boolean isTextAnalogInputChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ANALOG_INPUT_GROUP\n+                && !channelUID.getIdWithoutGroup().endsWith(RAW_CHANNEL_SUFFIX);\n+    }\n+\n+    protected boolean isRawAnalogInputChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ANALOG_INPUT_GROUP\n+                && channelUID.getIdWithoutGroup().endsWith(RAW_CHANNEL_SUFFIX);\n+    }\n+\n+    protected byte convertRawAnalogInputChannelUIDToChannelByte(ChannelUID channelUID) {\n+        return Byte.parseByte(channelUID.getIdWithoutGroup().replaceAll(RAW_CHANNEL_SUFFIX, \"\"));\n+    }\n+\n+    protected byte convertTextAnalogInputChannelUIDToChannelByte(ChannelUID channelUID) {\n+        return Byte.parseByte(channelUID.getIdWithoutGroup());\n+    }\n+\n+    protected String convertAnalogInputChannelByteToRawChannelUID(byte channelByte) {\n+        return convertAnalogInputChannelByteToChannelUID(channelByte) + RAW_CHANNEL_SUFFIX;\n+    }\n+\n+    protected String convertAnalogInputChannelByteToChannelUID(byte channelByte) {\n+        return ANALOG_INPUT_GROUP + \"#\" + channelByte;\n+    }\n+\n+    protected boolean isAnalogOutputChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ANALOG_OUTPUT_GROUP;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491327490", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491287394", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return channelUID.getGroupId() == ALARM_GROUP;\n          \n          \n            \n                    return ALARM_GROUP.equals(channelUID.getGroupId());", "author": "Hilbrand", "createdAt": "2020-09-19T06:17:20Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusVMB4ANHandler.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.VelbusChannelIdentifier;\n+import org.openhab.binding.velbus.internal.config.VelbusSensorConfig;\n+import org.openhab.binding.velbus.internal.packets.VelbusDimmerPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSensorReadoutRequestPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusStatusRequestPacket;\n+\n+/**\n+ * The {@link VelbusVMB4ANHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusVMB4ANHandler extends VelbusSensorWithAlarmClockHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMB4AN));\n+\n+    private static final String ALARM_GROUP = \"alarm\";\n+    private static final String ANALOG_INPUT_GROUP = \"analogInput\";\n+    private static final String ANALOG_OUTPUT_GROUP = \"analogOutput\";\n+    private static final String RAW_CHANNEL_SUFFIX = \"Raw\";\n+\n+    private static final byte VOLTAGE_SENSOR_TYPE = 0x00;\n+    private static final byte CURRENT_SENSOR_TYPE = 0x01;\n+    private static final byte RESISTANCE_SENSOR_TYPE = 0x02;\n+    private static final byte PERIOD_MEASUREMENT_SENSOR_TYPE = 0x03;\n+\n+    private String[] channelText = new String[] { \"\", \"\", \"\", \"\" };\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) VelbusSensorConfig sensorConfig;\n+\n+    public VelbusVMB4ANHandler(Thing thing) {\n+        super(thing, 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        this.sensorConfig = getConfigAs(VelbusSensorConfig.class);\n+\n+        super.initialize();\n+\n+        initializeAutomaticRefresh();\n+    }\n+\n+    private void initializeAutomaticRefresh() {\n+        int refreshInterval = sensorConfig.refresh;\n+\n+        if (refreshInterval > 0) {\n+            startAutomaticRefresh(refreshInterval);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+    }\n+\n+    private void startAutomaticRefresh(int refreshInterval) {\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            sendSensorReadoutRequest(velbusBridgeHandler, ALL_CHANNELS);\n+        }, 0, refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        super.handleCommand(channelUID, command);\n+\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        byte channelByte = convertChannelUIDToChannelByte(channelUID);\n+\n+        if (command instanceof RefreshType) {\n+            VelbusStatusRequestPacket packet = new VelbusStatusRequestPacket(channelByte);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        } else if (command instanceof PercentType && isAnalogOutputChannel(channelUID)) {\n+            VelbusDimmerPacket packet = new VelbusDimmerPacket(\n+                    new VelbusChannelIdentifier(this.getModuleAddress().getAddress(), channelByte), COMMAND_SET_VALUE,\n+                    ((PercentType) command).byteValue(), 0x00, false);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        }\n+    }\n+\n+    protected void sendSensorReadoutRequest(VelbusBridgeHandler velbusBridgeHandler, byte channel) {\n+        VelbusSensorReadoutRequestPacket packet = new VelbusSensorReadoutRequestPacket(getModuleAddress().getAddress(),\n+                channel);\n+\n+        byte[] packetBytes = packet.getBytes();\n+        velbusBridgeHandler.sendPacket(packetBytes);\n+    }\n+\n+    @Override\n+    public void onPacketReceived(byte[] packet) {\n+        super.onPacketReceived(packet);\n+\n+        logger.trace(\"onPacketReceived() was called\");\n+\n+        if (packet[0] == VelbusPacket.STX && packet.length >= 5) {\n+            byte command = packet[4];\n+\n+            if (command == COMMAND_SENSOR_RAW_DATA && packet.length >= 10) {\n+                byte channel = packet[5];\n+                byte operatingMode = packet[6];\n+                byte upperByteSensorValue = packet[7];\n+                byte highByteSensorValue = packet[8];\n+                byte lowByteSensorValue = packet[9];\n+\n+                double sensorValue = (((upperByteSensorValue & 0xff) << 16) + ((highByteSensorValue & 0xff) << 8)\n+                        + (lowByteSensorValue & 0xff));\n+                String channelUID = convertAnalogInputChannelByteToRawChannelUID(channel);\n+\n+                switch (operatingMode) {\n+                    case VOLTAGE_SENSOR_TYPE:\n+                        double voltageResolution = 0.25;\n+                        double voltageSensorValueState = sensorValue * voltageResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(voltageSensorValueState, MetricPrefix.MILLI(SmartHomeUnits.VOLT)));\n+                        break;\n+                    case CURRENT_SENSOR_TYPE:\n+                        double currentResolution = 5;\n+                        double currentSensorValueState = sensorValue * currentResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(currentSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.AMPERE)));\n+                        break;\n+                    case RESISTANCE_SENSOR_TYPE:\n+                        double resistanceResolution = 0.25;\n+                        double resistanceSensorValueState = sensorValue * resistanceResolution;\n+                        updateState(channelUID, new QuantityType<>(resistanceSensorValueState, SmartHomeUnits.OHM));\n+                        break;\n+                    case PERIOD_MEASUREMENT_SENSOR_TYPE:\n+                        double periodResolution = 0.5;\n+                        double periodSensorValueState = sensorValue * periodResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(periodSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.SECOND)));\n+                        break;\n+                }\n+            } else if (command == COMMAND_TEXT) {\n+                byte channel = packet[5];\n+                byte textStartPosition = packet[6];\n+\n+                StringBuilder contents = new StringBuilder();\n+                for (int i = 7; i < packet.length - 2; i++) {\n+                    byte currentChar = packet[i];\n+                    if (currentChar == (byte) -0x50) {\n+                        contents.append(\"\u00b0\");\n+                    } else if (currentChar != (byte) 0x00) {\n+                        contents.append((char) currentChar);\n+                    }\n+                }\n+\n+                channelText[channel - 9] = channelText[channel - 9].substring(0, textStartPosition)\n+                        + contents.toString()\n+                        + (channelText[channel - 9].length() > textStartPosition + 5 ? channelText[channel - 9]\n+                                .substring(textStartPosition + 5, channelText[channel - 9].length()) : \"\");\n+\n+                String channelUID = convertAnalogInputChannelByteToChannelUID(channel);\n+                updateState(channelUID, new StringType(channelText[channel - 9]));\n+            }\n+        }\n+    }\n+\n+    protected byte convertChannelUIDToChannelByte(ChannelUID channelUID) {\n+        if (isAlarmChannel(channelUID)) {\n+            return convertAlarmChannelUIDToChannelByte(channelUID);\n+        } else if (isTextAnalogInputChannel(channelUID)) {\n+            return convertTextAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isRawAnalogInputChannel(channelUID)) {\n+            return convertRawAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isAnalogOutputChannel(channelUID)) {\n+            return convertAnalogOutputChannelUIDToChannelByte(channelUID);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The channel '\" + channelUID + \"' is not supported on a VMB4AN module.\");\n+        }\n+    }\n+\n+    protected boolean isAlarmChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ALARM_GROUP;", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491327605", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491287544", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return channelUID.getGroupId() == ANALOG_INPUT_GROUP\n          \n          \n            \n                    return ANALOG_INPUT_GROUP.equals(channelUID.getGroupId())", "author": "Hilbrand", "createdAt": "2020-09-19T06:17:43Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusVMB4ANHandler.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.VelbusChannelIdentifier;\n+import org.openhab.binding.velbus.internal.config.VelbusSensorConfig;\n+import org.openhab.binding.velbus.internal.packets.VelbusDimmerPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSensorReadoutRequestPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusStatusRequestPacket;\n+\n+/**\n+ * The {@link VelbusVMB4ANHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusVMB4ANHandler extends VelbusSensorWithAlarmClockHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMB4AN));\n+\n+    private static final String ALARM_GROUP = \"alarm\";\n+    private static final String ANALOG_INPUT_GROUP = \"analogInput\";\n+    private static final String ANALOG_OUTPUT_GROUP = \"analogOutput\";\n+    private static final String RAW_CHANNEL_SUFFIX = \"Raw\";\n+\n+    private static final byte VOLTAGE_SENSOR_TYPE = 0x00;\n+    private static final byte CURRENT_SENSOR_TYPE = 0x01;\n+    private static final byte RESISTANCE_SENSOR_TYPE = 0x02;\n+    private static final byte PERIOD_MEASUREMENT_SENSOR_TYPE = 0x03;\n+\n+    private String[] channelText = new String[] { \"\", \"\", \"\", \"\" };\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) VelbusSensorConfig sensorConfig;\n+\n+    public VelbusVMB4ANHandler(Thing thing) {\n+        super(thing, 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        this.sensorConfig = getConfigAs(VelbusSensorConfig.class);\n+\n+        super.initialize();\n+\n+        initializeAutomaticRefresh();\n+    }\n+\n+    private void initializeAutomaticRefresh() {\n+        int refreshInterval = sensorConfig.refresh;\n+\n+        if (refreshInterval > 0) {\n+            startAutomaticRefresh(refreshInterval);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+    }\n+\n+    private void startAutomaticRefresh(int refreshInterval) {\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            sendSensorReadoutRequest(velbusBridgeHandler, ALL_CHANNELS);\n+        }, 0, refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        super.handleCommand(channelUID, command);\n+\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        byte channelByte = convertChannelUIDToChannelByte(channelUID);\n+\n+        if (command instanceof RefreshType) {\n+            VelbusStatusRequestPacket packet = new VelbusStatusRequestPacket(channelByte);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        } else if (command instanceof PercentType && isAnalogOutputChannel(channelUID)) {\n+            VelbusDimmerPacket packet = new VelbusDimmerPacket(\n+                    new VelbusChannelIdentifier(this.getModuleAddress().getAddress(), channelByte), COMMAND_SET_VALUE,\n+                    ((PercentType) command).byteValue(), 0x00, false);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        }\n+    }\n+\n+    protected void sendSensorReadoutRequest(VelbusBridgeHandler velbusBridgeHandler, byte channel) {\n+        VelbusSensorReadoutRequestPacket packet = new VelbusSensorReadoutRequestPacket(getModuleAddress().getAddress(),\n+                channel);\n+\n+        byte[] packetBytes = packet.getBytes();\n+        velbusBridgeHandler.sendPacket(packetBytes);\n+    }\n+\n+    @Override\n+    public void onPacketReceived(byte[] packet) {\n+        super.onPacketReceived(packet);\n+\n+        logger.trace(\"onPacketReceived() was called\");\n+\n+        if (packet[0] == VelbusPacket.STX && packet.length >= 5) {\n+            byte command = packet[4];\n+\n+            if (command == COMMAND_SENSOR_RAW_DATA && packet.length >= 10) {\n+                byte channel = packet[5];\n+                byte operatingMode = packet[6];\n+                byte upperByteSensorValue = packet[7];\n+                byte highByteSensorValue = packet[8];\n+                byte lowByteSensorValue = packet[9];\n+\n+                double sensorValue = (((upperByteSensorValue & 0xff) << 16) + ((highByteSensorValue & 0xff) << 8)\n+                        + (lowByteSensorValue & 0xff));\n+                String channelUID = convertAnalogInputChannelByteToRawChannelUID(channel);\n+\n+                switch (operatingMode) {\n+                    case VOLTAGE_SENSOR_TYPE:\n+                        double voltageResolution = 0.25;\n+                        double voltageSensorValueState = sensorValue * voltageResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(voltageSensorValueState, MetricPrefix.MILLI(SmartHomeUnits.VOLT)));\n+                        break;\n+                    case CURRENT_SENSOR_TYPE:\n+                        double currentResolution = 5;\n+                        double currentSensorValueState = sensorValue * currentResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(currentSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.AMPERE)));\n+                        break;\n+                    case RESISTANCE_SENSOR_TYPE:\n+                        double resistanceResolution = 0.25;\n+                        double resistanceSensorValueState = sensorValue * resistanceResolution;\n+                        updateState(channelUID, new QuantityType<>(resistanceSensorValueState, SmartHomeUnits.OHM));\n+                        break;\n+                    case PERIOD_MEASUREMENT_SENSOR_TYPE:\n+                        double periodResolution = 0.5;\n+                        double periodSensorValueState = sensorValue * periodResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(periodSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.SECOND)));\n+                        break;\n+                }\n+            } else if (command == COMMAND_TEXT) {\n+                byte channel = packet[5];\n+                byte textStartPosition = packet[6];\n+\n+                StringBuilder contents = new StringBuilder();\n+                for (int i = 7; i < packet.length - 2; i++) {\n+                    byte currentChar = packet[i];\n+                    if (currentChar == (byte) -0x50) {\n+                        contents.append(\"\u00b0\");\n+                    } else if (currentChar != (byte) 0x00) {\n+                        contents.append((char) currentChar);\n+                    }\n+                }\n+\n+                channelText[channel - 9] = channelText[channel - 9].substring(0, textStartPosition)\n+                        + contents.toString()\n+                        + (channelText[channel - 9].length() > textStartPosition + 5 ? channelText[channel - 9]\n+                                .substring(textStartPosition + 5, channelText[channel - 9].length()) : \"\");\n+\n+                String channelUID = convertAnalogInputChannelByteToChannelUID(channel);\n+                updateState(channelUID, new StringType(channelText[channel - 9]));\n+            }\n+        }\n+    }\n+\n+    protected byte convertChannelUIDToChannelByte(ChannelUID channelUID) {\n+        if (isAlarmChannel(channelUID)) {\n+            return convertAlarmChannelUIDToChannelByte(channelUID);\n+        } else if (isTextAnalogInputChannel(channelUID)) {\n+            return convertTextAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isRawAnalogInputChannel(channelUID)) {\n+            return convertRawAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isAnalogOutputChannel(channelUID)) {\n+            return convertAnalogOutputChannelUIDToChannelByte(channelUID);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The channel '\" + channelUID + \"' is not supported on a VMB4AN module.\");\n+        }\n+    }\n+\n+    protected boolean isAlarmChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ALARM_GROUP;\n+    }\n+\n+    protected byte convertAlarmChannelUIDToChannelByte(ChannelUID channelUID) {\n+        return Byte.parseByte(channelUID.getIdWithoutGroup());\n+    }\n+\n+    protected boolean isTextAnalogInputChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ANALOG_INPUT_GROUP", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491327910", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzYwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491287603", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return channelUID.getGroupId() == ANALOG_INPUT_GROUP\n          \n          \n            \n                    return ANALOG_INPUT_GROUP.equals(channelUID.getGroupId())", "author": "Hilbrand", "createdAt": "2020-09-19T06:17:59Z", "path": "bundles/org.openhab.binding.velbus/src/main/java/org/openhab/binding/velbus/internal/handler/VelbusVMB4ANHandler.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velbus.internal.handler;\n+\n+import static org.openhab.binding.velbus.internal.VelbusBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.velbus.internal.VelbusChannelIdentifier;\n+import org.openhab.binding.velbus.internal.config.VelbusSensorConfig;\n+import org.openhab.binding.velbus.internal.packets.VelbusDimmerPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusSensorReadoutRequestPacket;\n+import org.openhab.binding.velbus.internal.packets.VelbusStatusRequestPacket;\n+\n+/**\n+ * The {@link VelbusVMB4ANHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cedric Boon - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VelbusVMB4ANHandler extends VelbusSensorWithAlarmClockHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<>(Arrays.asList(THING_TYPE_VMB4AN));\n+\n+    private static final String ALARM_GROUP = \"alarm\";\n+    private static final String ANALOG_INPUT_GROUP = \"analogInput\";\n+    private static final String ANALOG_OUTPUT_GROUP = \"analogOutput\";\n+    private static final String RAW_CHANNEL_SUFFIX = \"Raw\";\n+\n+    private static final byte VOLTAGE_SENSOR_TYPE = 0x00;\n+    private static final byte CURRENT_SENSOR_TYPE = 0x01;\n+    private static final byte RESISTANCE_SENSOR_TYPE = 0x02;\n+    private static final byte PERIOD_MEASUREMENT_SENSOR_TYPE = 0x03;\n+\n+    private String[] channelText = new String[] { \"\", \"\", \"\", \"\" };\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) VelbusSensorConfig sensorConfig;\n+\n+    public VelbusVMB4ANHandler(Thing thing) {\n+        super(thing, 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        this.sensorConfig = getConfigAs(VelbusSensorConfig.class);\n+\n+        super.initialize();\n+\n+        initializeAutomaticRefresh();\n+    }\n+\n+    private void initializeAutomaticRefresh() {\n+        int refreshInterval = sensorConfig.refresh;\n+\n+        if (refreshInterval > 0) {\n+            startAutomaticRefresh(refreshInterval);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+    }\n+\n+    private void startAutomaticRefresh(int refreshInterval) {\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            sendSensorReadoutRequest(velbusBridgeHandler, ALL_CHANNELS);\n+        }, 0, refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        super.handleCommand(channelUID, command);\n+\n+        VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler();\n+        if (velbusBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        }\n+\n+        byte channelByte = convertChannelUIDToChannelByte(channelUID);\n+\n+        if (command instanceof RefreshType) {\n+            VelbusStatusRequestPacket packet = new VelbusStatusRequestPacket(channelByte);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        } else if (command instanceof PercentType && isAnalogOutputChannel(channelUID)) {\n+            VelbusDimmerPacket packet = new VelbusDimmerPacket(\n+                    new VelbusChannelIdentifier(this.getModuleAddress().getAddress(), channelByte), COMMAND_SET_VALUE,\n+                    ((PercentType) command).byteValue(), 0x00, false);\n+\n+            byte[] packetBytes = packet.getBytes();\n+            velbusBridgeHandler.sendPacket(packetBytes);\n+        }\n+    }\n+\n+    protected void sendSensorReadoutRequest(VelbusBridgeHandler velbusBridgeHandler, byte channel) {\n+        VelbusSensorReadoutRequestPacket packet = new VelbusSensorReadoutRequestPacket(getModuleAddress().getAddress(),\n+                channel);\n+\n+        byte[] packetBytes = packet.getBytes();\n+        velbusBridgeHandler.sendPacket(packetBytes);\n+    }\n+\n+    @Override\n+    public void onPacketReceived(byte[] packet) {\n+        super.onPacketReceived(packet);\n+\n+        logger.trace(\"onPacketReceived() was called\");\n+\n+        if (packet[0] == VelbusPacket.STX && packet.length >= 5) {\n+            byte command = packet[4];\n+\n+            if (command == COMMAND_SENSOR_RAW_DATA && packet.length >= 10) {\n+                byte channel = packet[5];\n+                byte operatingMode = packet[6];\n+                byte upperByteSensorValue = packet[7];\n+                byte highByteSensorValue = packet[8];\n+                byte lowByteSensorValue = packet[9];\n+\n+                double sensorValue = (((upperByteSensorValue & 0xff) << 16) + ((highByteSensorValue & 0xff) << 8)\n+                        + (lowByteSensorValue & 0xff));\n+                String channelUID = convertAnalogInputChannelByteToRawChannelUID(channel);\n+\n+                switch (operatingMode) {\n+                    case VOLTAGE_SENSOR_TYPE:\n+                        double voltageResolution = 0.25;\n+                        double voltageSensorValueState = sensorValue * voltageResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(voltageSensorValueState, MetricPrefix.MILLI(SmartHomeUnits.VOLT)));\n+                        break;\n+                    case CURRENT_SENSOR_TYPE:\n+                        double currentResolution = 5;\n+                        double currentSensorValueState = sensorValue * currentResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(currentSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.AMPERE)));\n+                        break;\n+                    case RESISTANCE_SENSOR_TYPE:\n+                        double resistanceResolution = 0.25;\n+                        double resistanceSensorValueState = sensorValue * resistanceResolution;\n+                        updateState(channelUID, new QuantityType<>(resistanceSensorValueState, SmartHomeUnits.OHM));\n+                        break;\n+                    case PERIOD_MEASUREMENT_SENSOR_TYPE:\n+                        double periodResolution = 0.5;\n+                        double periodSensorValueState = sensorValue * periodResolution;\n+                        updateState(channelUID,\n+                                new QuantityType<>(periodSensorValueState, MetricPrefix.MICRO(SmartHomeUnits.SECOND)));\n+                        break;\n+                }\n+            } else if (command == COMMAND_TEXT) {\n+                byte channel = packet[5];\n+                byte textStartPosition = packet[6];\n+\n+                StringBuilder contents = new StringBuilder();\n+                for (int i = 7; i < packet.length - 2; i++) {\n+                    byte currentChar = packet[i];\n+                    if (currentChar == (byte) -0x50) {\n+                        contents.append(\"\u00b0\");\n+                    } else if (currentChar != (byte) 0x00) {\n+                        contents.append((char) currentChar);\n+                    }\n+                }\n+\n+                channelText[channel - 9] = channelText[channel - 9].substring(0, textStartPosition)\n+                        + contents.toString()\n+                        + (channelText[channel - 9].length() > textStartPosition + 5 ? channelText[channel - 9]\n+                                .substring(textStartPosition + 5, channelText[channel - 9].length()) : \"\");\n+\n+                String channelUID = convertAnalogInputChannelByteToChannelUID(channel);\n+                updateState(channelUID, new StringType(channelText[channel - 9]));\n+            }\n+        }\n+    }\n+\n+    protected byte convertChannelUIDToChannelByte(ChannelUID channelUID) {\n+        if (isAlarmChannel(channelUID)) {\n+            return convertAlarmChannelUIDToChannelByte(channelUID);\n+        } else if (isTextAnalogInputChannel(channelUID)) {\n+            return convertTextAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isRawAnalogInputChannel(channelUID)) {\n+            return convertRawAnalogInputChannelUIDToChannelByte(channelUID);\n+        } else if (isAnalogOutputChannel(channelUID)) {\n+            return convertAnalogOutputChannelUIDToChannelByte(channelUID);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The channel '\" + channelUID + \"' is not supported on a VMB4AN module.\");\n+        }\n+    }\n+\n+    protected boolean isAlarmChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ALARM_GROUP;\n+    }\n+\n+    protected byte convertAlarmChannelUIDToChannelByte(ChannelUID channelUID) {\n+        return Byte.parseByte(channelUID.getIdWithoutGroup());\n+    }\n+\n+    protected boolean isTextAnalogInputChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ANALOG_INPUT_GROUP\n+                && !channelUID.getIdWithoutGroup().endsWith(RAW_CHANNEL_SUFFIX);\n+    }\n+\n+    protected boolean isRawAnalogInputChannel(ChannelUID channelUID) {\n+        return channelUID.getGroupId() == ANALOG_INPUT_GROUP", "originalCommit": "5ca761c60a9a5733c6a3f565cf008082143b5464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyODA3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8464#discussion_r491328073", "bodyText": "Modified in commit d57ba9d", "author": "cedricboon", "createdAt": "2020-09-19T08:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NzYwMw=="}], "type": "inlineReview"}, {"oid": "d57ba9d0185441e933d06a68f54b73489cc18472", "url": "https://github.com/openhab/openhab-addons/commit/d57ba9d0185441e933d06a68f54b73489cc18472", "message": "Changes after review\n\nSigned-off-by: Cedric Boon <cedric.boon@hotmail.com>", "committedDate": "2020-09-19T08:15:28Z", "type": "commit"}]}